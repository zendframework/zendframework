<?xml version="1.0" encoding="UTF-8"?>
<!-- EN-Revision: 15823 -->
<!-- Reviewed: no -->
<sect1 id="zend.application.theory-of-operation">
    <title>Theorie der Funktionsweise</title>

    <para>
        Um eine <acronym>MVC</acronym> Anwendung zu konfigurieren und bereit zur Auslieferung
        zu bekommen wird ein immer größerer Anteil an Code benötigt sobald mehr Features verfügbar
        sind: Setzen der Datenbank, Konfiguration der View und View Helfer, Konfiguration der
        Layouts, Registrierung der Plugins, Registrierung der Aktion Helfer, und andere.
    </para>

    <para>
        Zusätzlich will man oft den gleichen Code wiederverwenden um Tests zu bootstrappen, einen
        Cronjob, oder ein Service Skript zu haben. Wärend es sehr einfach ist sein Bootstrap Skript
        einzubauen, gibt es oft Initialisierungen die abhängig sind von der Umgebung - man könnte
        kein <acronym>MVC</acronym> für einen Cronjob benötigen, oder nur den DB Layer für ein
        Service Skript.
    </para>

    <para>
        <classname>Zend_Application</classname> zielt darauf ab das alles einfacher zu machen und
        bietet Wiederwervendbarkeit durch die Kapselung vom Bootstrapping in <acronym>OOP</acronym>
        Paradigmen.
    </para>

    <para>
        <classname>Zend_Application</classname> ist in drei Bereiche geteilt:
    </para>

    <itemizedlist>
        <listitem>
            <para>
                <classname>Zend_Application</classname>: Lädt die <acronym>PHP</acronym> Umgebung,
                inklusive Inklude-Pfade und Autoloading, und instanziiert die benötigte Bootstrap
                Klasse.
            </para>
        </listitem>
        <listitem>
            <para>
                <classname>Zend_Application_Bootstrap</classname>: Bietet Interfaces für Bootstrap
                Klassen. <classname>Zend_Application_Bootstrap_Bootstrap</classname> bietet übliche
                Funktionalitäten für die meisten Notwendigkeiten des Bootstrappings, inklusive
                Angorithmen um Abhängigkeiten zu prüfen und die Möglichkeit Bootstrap Ressourcen bei
                Bedarf zu laden.
            </para>
        </listitem>
        <listitem>
            <para>
                <classname>Zend_Application_Resource</classname> bietet ein Interface für Standard
                Bootstrap Ressourcen die bei Bedarf von einer Bootstrap Instanz geladen werden
                können, sowie verschiedene standardmäßige Ressource Implementationen.
            </para>
        </listitem>
    </itemizedlist>

    <para>
        Entwickler erstellen eine Bootstrap Klasse für Ihre Anwendung und erweitern
        <classname>Zend_Application_Bootstrap_Bootstrap</classname> oder implementieren (mindestens)
        <classname>Zend_Application_Bootstrap_BootstrapAbstract</classname>. Der Einstiegspunkt
        (z.B. <filename>public/index.php</filename>) lädt <classname>Zend_Application</classname>
        und initialisiert Sie, indem folgendes übergeben wird:
    </para>

    <itemizedlist>
        <listitem>
            <para>
                Die aktuelle Umgebung
            </para>
        </listitem>
        <listitem>
            <para>
                Optionen für das Bootstrapping
            </para>
        </listitem>
    </itemizedlist>

    <para>
        Die Bootstrap Optionen enthalten den Pfad zur Datei die die Bootstrap Klasse enthält und
        optional:
    </para>

    <itemizedlist>
        <listitem>
            <para>
                Jeden include_path der extra zu setzen ist
            </para>
        </listitem>
        <listitem>
            <para>
                Jeden Autoloader Namespace der zusätzlich zu registrieren ist
            </para>
        </listitem>
        <listitem>
            <para>
                Jede <filename>php.ini</filename> Einstellung die zu initialisieren ist
            </para>
        </listitem>
        <listitem>
            <para>
                Den Klassennamen für die Bootstrap Klasse (wenn diese nicht "Bootstrap" ist)
            </para>
        </listitem>
        <listitem>
            <para>
                Ressourcen Präfix zu Pfad Paare die zu verwenden sind
            </para>
        </listitem>
        <listitem>
            <para>
                Jede Ressource die zu verwenden ist (durch Name der Klasse oder Kurzname)
            </para>
        </listitem>
        <listitem>
            <para>
                Zusätzliche Pfade zu einer Konfigurationsdatei die zu laden ist
            </para>
        </listitem>
        <listitem>
            <para>
                Zusätzliche Konfigurations Optionen
            </para>
        </listitem>
    </itemizedlist>

    <para>
        Optionen können, ein Array, ein <classname>Zend_Config</classname> Objekt, oder der Pfad zu
        einer Konfigurationsdatei sein.
    </para>

    <sect2 id="zend.application.theory-of-operation.bootstrap">
        <title>Bootstrapping</title>

        <para>
            <classname>Zend_Application</classname>'s zweites Feld der Arbeit ist die Ausführung des
            Bootstraps der Anwendung. Bootstraps müssen mindestens
            <classname>Zend_Application_Bootstrap_Bootstrapper</classname> implementieren, welches
            die folgende <acronym>API</acronym> definiert:
        </para>

        <programlisting language="php"><![CDATA[
interface Zend_Application_Bootstrap_Bootstrapper
{
    public function __construct($application);
    public function setOptions(array $options);
    public function getApplication();
    public function getEnvironment();
    public function getClassResources();
    public function getClassResourceNames();
    public function bootstrap($resource = null);
    public function run();
}
]]></programlisting>

        <para>
            Diese <acronym>API</acronym> erlaubt es dem Bootstrap die Umgebung und die
            Konfiguration vom Objekt der Anwendung zu akzeptieren, die Ressourcen die für das
            Bootstrapping verantwortlich sind zu melden, und dann das Bootstrappen ausführen und
            die Anwendung zu starten.
        </para>

        <para>
            Man kann dieses Interface selbst implementieren,
            <classname>Zend_Application_Bootstrap_BootstrapAbstract</classname> erweitern, oder
            <classname>Zend_Application_Bootstrap_Bootstrap</classname> verwenden.
        </para>

        <para>
            Neben dieser Funktionalität gibt es eine Anzahl anderer Gebiete von Interesse mit denen
            man vertraut sein sollte.
        </para>

        <sect3 id="zend.application.theory-of-operation.bootstrap.resource-methods">
            <title>Methoden für Ressourcen</title>

            <para>
                Die Implementation von
                <classname>Zend_Application_Bootstrap_BootstrapAbstract</classname> bietet eine
                einfache Konvention für die Definition von Methoden für Ressourcen Klassen. Jede
                geschützte Methode (protected), deren Name mit <emphasis>_init</emphasis> beginnt
                wird als Ressourcemethode angenommen.
            </para>

            <para>
                Um eine einzelne Ressource Methode zu bootstrappen, muß die
                <methodname>bootstrap()</methodname> Methode verwendet, und der Name der Ressource
                übergeben werden. Der Name ist der Name der Methode ohne den
                <emphasis>_init</emphasis> Präfix.
            </para>

            <para>
                Um mehrere Ressourcen Methoden zu bootstrappen, muß ein Array von Namen übergeben
                werden. Um alle Ressourcen Methoden zu bootstrappen, darf nichts übergeben werden.
            </para>

            <para>
                Nehmen wir die folgende Bootstrap Klasse an:
            </para>

            <programlisting language="php"><![CDATA[
class Bootstrap extends Zend_Application_Bootstrap_Bootstrap
{
    protected function _initFoo()
    {
        // ...
    }

    protected function _initBar()
    {
        // ...
    }

    protected function _initBaz()
    {
        // ...
    }
}
]]></programlisting>

            <para>
                Um nur die <methodname>_initFoo()</methodname> Methode zu bootstrappen, machen wir
                das folgende:
            </para>

            <programlisting language="php"><![CDATA[
$bootstrap->bootstrap('foo');
]]></programlisting>

            <para>
                Um die Methoden <methodname>_initFoo()</methodname> und
                <methodname>_initBar()</methodname> zu bootstrappen, machen wir das folgende:
            </para>

            <programlisting language="php"><![CDATA[
$bootstrap->bootstrap(array('foo', 'bar));
]]></programlisting>

            <para>
                Um alle Ressourcen Methoden zu bootstrappen, rufen wir
                <methodname>bootstrap()</methodname> ohne Argumente auf:
            </para>

            <programlisting language="php"><![CDATA[
$bootstrap->bootstrap();
]]></programlisting>
        </sect3>

        <sect3 id="zend.application.theory-of-operation.bootstrap.resource-plugins">
            <title>Bootstraps die Ressourcen Plugins benutzen</title>

            <para>
                Um Bootstraps wiederverwendbarer zu machen wurde die Fähigkeit zur Verfügung
                gestellt Ressourcen in Ressource Plugin Klassen zu geben. Das erlaubt es Ressourcen
                einfach über die Konfiguration zu mischen und zu sehen ob Sie passen. Wir behandeln
                später <link linkend="zend.application.theory-of-operation.resources">wie
                    Ressourcen erstellt werden</link>; in diesem Abschnitt zeigen wir nur wie Sie
                angepasst werden können.
            </para>

            <para>
                Wenn die Bootstrap dazu in der Lage sein soll Ressource Plugins zu verwenden muß
                man ein zusätzliches Interface implementieren,
                <classname>Zend_Application_Bootstrap_ResourceBootstrapper</classname>. Dieses
                Interface definiert eine <acronym>API</acronym> für das Erkennen, Registrieren und
                Laden von Ressource Plugins:
            </para>

        <programlisting language="php"><![CDATA[
interface Zend_Application_Bootstrap_ResourceBootstrapper
{
    public function registerPluginResource($resource, $options = null);
    public function unregisterPluginResource($resource);
    public function hasPluginResource($resource);
    public function getPluginResource($resource);
    public function getPluginResources();
    public function getPluginResourceNames();
    public function setPluginLoader(Zend_Loader_PluginLoader_Interface $loader);
    public function getPluginLoader();
}
]]></programlisting>

            <para>
                Ressource Plugins bieten grundsätzlich die Fähigkeit Ressource Initialisierer zu
                Erstellen die zwischen Anwendungen wiederverwendet werden können. Das erlaubt es
                die aktuelle Bootstrap relativ klein zu halten, und neue Ressourcen einzuführen
                ohne Sie in der Bootstrap selbst anzugreifen.
            </para>

            <para>
                <classname>Zend_Application_Bootstrap_BootstrapAbstract</classname> (und bei
                Erweiterung <classname>Zend_Application_Bootstrap_Bootstrap</classname>)
                implementiert dieses Interface genauso, und erlaubt es Ressource Plugins zu
                verwenden.
            </para>

            <para>
                Um Ressource  Plugins zu verwenden müssen diese in den Optionen spezifiziert
                werden, die dem Anwendungs Objekt und-oder der Bootstrap übergeben werden. Diese
                Optionen können von einer Konfigurationsdatei kommen, oder manuell übergeben
                werden. Optionen sind Paare von Schlüssel zu Optionspaaren, wobei der Schlüssel
                den Namen der Ressource repräsentiert. Der Ressourcename ist das Segment das
                dem Klassenpräfix folgt. Die Ressourcen, die zum Beispiel mit Zend Framework
                ausgeliefert werden, haben den Klassenpräfix
                "<classname>Zend_Application_Resource_</classname>"; alles was folgt würde der
                Name der Ressource sein. Als Beispiel:
            </para>

            <programlisting language="php"><![CDATA[
$application = new Zend_Application(APPLICATION_ENV, array(
    'resources' => array(
        'FrontController' => array(
            'controllerDirectory' => APPLICATION_PATH . '/controllers',
        ),
    ),
));
]]></programlisting>

            <para>
                Das zeigt das die "FrontController" verwendet werden sollte, mit den spezifizierten
                Optionen.
            </para>

            <para>
                Wenn man beginnt eigene Ressource Plugins zu schreiben, oder Ressource Plugins von
                dritten anzupassen, muß man der eigenen Bootstrap mitteilen wo nach Ihnen zu suchen
                ist. Intern verwendet die Bootstrap <classname>Zend_Loader_PluginLoader</classname>
                so dass man nur die üblichen Klassenpräfix und Pfadpaare angeben muß.
            </para>

            <para>
                Als Beispiel nehmen wir an das wir eigene Ressource Plugins in
                <filename>APPLICATION_PATH/resources/</filename> haben, und das sie den gemeinsamen
                Klassenpräfix <classname>My_Resource</classname> teilen. Man würde diese
                Information de Anwendungsobjekt wie folgt übergeben:
            </para>

            <programlisting language="php"><![CDATA[
$application = new Zend_Application(APPLICATION_ENV, array(
    'pluginPaths' => array(
        'My_Resource' => APPLICATION_PATH . '/resources/',
    ),
    'resources' => array(
        'FrontController' => array(
            'controllerDirectory' => APPLICATION_PATH . '/controllers',
        ),
    ),
));
]]></programlisting>

            <para>
                Man ist jetzt in der Lage Ressource von diesem Verzeichnis zu verwenden.
            </para>

            <para>
                Wie Ressource Methoden kann die <methodname>bootstrap()</methodname> Methode
                verwendet werden um Ressource Plugins zu verwenden. Wie bei Ressource Methoden
                kann man entweder einzelne Ressource Plugins spezifizieren, mehrere Plugins
                (über ein Array), oder alle Plugins. Zusätzlich kann man mischen und entsprechende
                Ressource Methoden genauso ausführen.
            </para>

            <programlisting language="php"><![CDATA[
// Eine ausführen:
$bootstrap->bootstrap('FrontController');

// Mehrere ausführen:
$bootstrap->bootstrap(array('FrontController', 'Foo'));

// Alle Ressource Methoden und Plugins ausführen:
$bootstrap->bootstrap();
]]></programlisting>
        </sect3>

        <sect3 id="zend.application.theory-of-operation.bootstrap.registry">
            <title>Ressource Registry</title>

            <para>
                Viele, wenn nicht sogar alle, der eigenen Ressource Methoden oder Plugins
                initialisieren Objekte, und in vielen Fällen werden diese Objekte an anderen
                Orten der Anwendung benötigt. Wie man man auf Sie zugreifen?
            </para>

            <para>
                <classname>Zend_Application_Bootstrap_BootstrapAbstract</classname>
                bietet eine locale Registry für diese Objekte. Um eigene Objekte in Ihr zu
                Speichern müssen diese einfach von den eigenen Ressourcen zurückgegeben werden.
            </para>

            <para>
                For maximum flexibility, this registry is referred to as a
                "container" internally; its only requirements are that it is an
                object. Resources are then registered as properties named after
                the resource name. By default, an instance of
                <classname>Zend_Registry</classname> is used, but you may also specify any
                other object you wish. The methods <methodname>setContainer()</methodname>
                and <methodname>getContainer()</methodname> may be used to manipulate the
                container itself. <methodname>getResource($resource)</methodname> can be
                used to fetch a given resource from the container, and
                <methodname>hasResource($resource)</methodname> to check if the resource has
                actually been registered.
            </para>

            <para>
                As an example, consider a basic view resource:
            </para>

            <programlisting language="php"><![CDATA[
class Bootstrap extends Zend_Application_Bootstrap_Bootstrap
{
    protected function _initView()
    {
        $view = new Zend_View();
        // more initialization...

        return $view;
    }
}
]]></programlisting>

            <para>
                You can then check for it and/or fetch it as follows:
            </para>

            <programlisting language="php"><![CDATA[
// Using the has/getResource() pair:
if ($bootstrap->hasResource('view')) {
    $view = $bootstrap->getResource('view');
}

// Via the container:
$container = $bootstrap->getContainer();
if (isset($container->view)) {
    $view = $container->view;
}
]]></programlisting>

            <para>
                Please note that the registry and also the container is not global. This
                means that you need access to the bootstrap in order to fetch
                resources. <classname>Zend_Application_Bootstrap_Bootstrap</classname>
                provides some convenience for this: during its
                <methodname>run()</methodname> execution, it registers itself as the front
                controller parameter "bootstrap", which allows you to fetch it
                from the router, dispatcher, plugins, and action controllers.
            </para>

            <para>
                As an example, if you wanted access to the view resource from
                above within your action controller, you could do the following:
            </para>

            <programlisting language="php"><![CDATA[
class FooController extends Zend_Controller_Action
{
    public function init()
    {
        $bootstrap = $this->getInvokeArg('bootstrap');
        $view = $bootstrap->getResource('view');
        // ...
    }
}
]]></programlisting>
        </sect3>

        <sect3 id="zend.application.theory-of-operation.bootstrap.dependency-tracking">
            <title>Dependency Tracking</title>

            <para>
                In addition to executing resource methods and plugins, it's
                necessary to ensure that these are executed once and once
                only; these are meant to bootstrap an application, and
                executing multiple times can lead to resource overhead.
            </para>

            <para>
                At the same time, some resources may depend on other
                resources being executed. To solve these two issues,
                <classname>Zend_Application_Bootstrap_BootstrapAbstract</classname>
                provides a simple, effective mechanism for dependency
                tracking.
            </para>

            <para>
                As noted previously, all resources -- whether methods or plugins
                -- are bootstrapped by calling <methodname>bootstrap($resource)</methodname>,
                where <varname>$resource</varname> is the name of a resource, an array
                of resources, or, left empty, indicates all resources should be
                run.
            </para>

            <para>
                If a resource depends on another resource, it should call
                <methodname>bootstrap()</methodname> within its code to ensure that resource
                has been executed. Subsequent calls to it will then be ignored.
            </para>

            <para>
                In a resource method, such a call would look like this:
            </para>

            <programlisting language="php"><![CDATA[
class Bootstrap extends Zend_Application_Bootstrap_Bootstrap
{
    protected function _initRequest()
    {
        // Ensure the front controller is initialized
        $this->bootstrap('FrontController');

        // Retrieve the front controller from the bootstrap registry
        $front = $this->getResource('FrontController');

        $request = new Zend_Controller_Request_Http();
        $request->setBaseUrl('/foo');
        $front->setRequest($request);

        // Ensure the request is stored in the bootstrap registry
        return $request;
    }
}
]]></programlisting>
        </sect3>
    </sect2>

    <sect2 id="zend.application.theory-of-operation.resources">
        <title>Resource Plugins</title>

        <para>
            <link
                linkend="zend.application.theory-of-operation.bootstrap.resource-plugins">As noted
                previously</link>, a good way to create re-usable bootstrap resources and to
            offload much of your coding to discrete classes is to utilize resource
            plugins. While Zend Framework ships with a number of standard
            resource plugins, the intention is that developers should write
            their own to encapsulate their own intialization needs.
        </para>

        <para>
            Resources need only implement
            <classname>Zend_Application_Resource_Resource</classname>, or, more simply
            still, extend
            <classname>Zend_Application_Resource_ResourceAbstract</classname>. The basic
            interface is simply this:
        </para>

        <programlisting language="php"><![CDATA[
interface Zend_Application_Resource_Resource
{
    public function __construct($options = null);
    public function setBootstrap(
        Zend_Application_Bootstrap_Bootstrapper $bootstrap
    );
    public function getBootstrap();
    public function setOptions(array $options);
    public function getOptions();
    public function init();
}
]]></programlisting>

        <para>
            The interface defines simply that a resource should accept options
            to the constructor, have mechanisms for setting and retrieving
            options, have mechanisms for setting and retrieving the bootstrap
            object, and an initialization method.
        </para>

        <para>
            As an example, let's assume you have a common view intialization you
            use in your applications. You have a common doctype, <acronym>CSS</acronym> and
            JavaScript, and you want to be able to pass in a base document title
            via configuration. Such a resource might look like this:
        </para>

        <programlisting language="php"><![CDATA[
class My_Resource_View extends Zend_Application_Resource_ResourceAbstract
{
    protected $_view;

    public function init()
    {
        // Return view so bootstrap will store it in the registry
        return $this->getView();
    }

    public function getView()
    {
        if (null === $this->_view) {
            $options = $this->getOptions();
            $title   = '';
            if (array_key_exists('title', $options)) {
                $title = $options['title'];
                unset($options['title']);
            }

            $view = new Zend_View($options);
            $view->doctype('XHTML1_STRICT');
            $view->headTitle($title);
            $view->headLink()->appendStylesheet('/css/site.css');
            $view->headScript()->appendfile('/js/analytics.js');

            $viewRenderer =
                Zend_Controller_Action_HelperBroker::getStaticHelper(
                    'ViewRenderer',
                );
            $viewRenderer->setView($view);

            $this->_view = $view;
        }
        return $this->_view;
    }
}
]]></programlisting>

        <para>
            As long as you register the prefix path for this resource plugin,
            you can then use it in your application. Even better, because it
            uses the plugin loader, you are effectively overriding the shipped
            "View" resource plugin, ensuring that your own is used instead.
        </para>
    </sect2>
</sect1>
