<?xml version="1.0" encoding="UTF-8"?>
<!-- EN-Revision: 14978 -->
<!-- Reviewed: no -->
<sect1 id="zend.cache.frontends">
    <title>Zend_Cache Frontends</title>

    <sect2 id="zend.cache.frontends.core">
        <title><classname>Zend_Cache_Core</classname></title>
        <sect3 id="zend.cache.frontends.core.introduction">
            <title>Einführung</title>
            <para>
                <classname>Zend_Cache_Core</classname> ist ein spezielles Frontend, da es der Kern dieses Moduls ist.
                Es ist ein generelles Cache Frontend und wurde von anderen Klassen erweitert.
            </para>
            <note>
                <para>
                    Alle Frontends sind von <classname>Zend_Cache_Core</classname> abgeleitet, so dass deren Methoden und
                    Optionen (wie folgt beschrieben) auch in anderen Frontends vorhanden sind. Deswegen werden
                    sie dort nicht dokumentiert.
                </para>
            </note>
        </sect3>
        <sect3 id="zend.cache.frontends.core.options">
            <title>Mögliche Optionen</title>
            <para>
                Diese Optionen werden der Factory Methode übergeben wie im nachfolgenden Beispiel demonstriert.
            </para>
            <table id="zend.cache.frontends.core.options.table">
                <title>Core Frontend Optionen</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Daten Typ</entry>
                            <entry>Standardwert</entry>
                            <entry>Beschreibung</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>caching</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  Ein- / Ausschalten vom Caching (kann sehr nützlich für das
                                  Debuggen von gecachten Skripten sein)
                              </entry>
                          </row>
                          <row>
                              <entry><code>cache_id_prefix</code></entry>
                              <entry><code>string</code></entry>
                              <entry><code>null</code></entry>
                              <entry>
                                  Ein Präfix für alle Cache IDs. Wenn er auf <code>null</code>
                                  gesetzt wird, wird kein Cache ID Präfix verwendet. Der Cache ID
                                  Präfix erstellt grundsätzlich einen Namespace im Cache, der
                                  verschiedenen Anwendungen oder Websites die Verwendung eines
                                  gemeinsamen Caches erlaubt. Jede Anwendung oder Website kann
                                  einen anderen Cache ID Prüfix verwenden sodas spezielle Cache IDs
                                  mehr als einmal verwendet werden können.
                              </entry>
                          </row>
                          <row>
                              <entry><code>lifetime</code></entry>
                              <entry><code>int</code></entry>
                              <entry><code>3600</code></entry>
                              <entry>
                                Cache Lebensdauer (in Sekunden), wenn auf <code>null</code> gesetzt, ist
                                der Cache für immer gültig.
                              </entry>
                          </row>
                          <row>
                              <entry><code>logging</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                Wenn auf true gesetzt, wird das Logging durch <classname>Zend_Log</classname> aktiviert
                                (aber das System wird langsamer)
                              </entry>
                          </row>
                          <row>
                              <entry><code>write_control</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                Ein- / Ausschalten der Schreibkontrolle (der Cache wird gleich gelesen, nachdem
                                er geschrieben wurde, um fehlerhafte Einträge zu finden); das Einschalten der
                                Schreibkontrolle wird das Schreiben des Caches etwas verlangsamen, aber nicht das
                                Lesen des Caches (es können defekte Cache Dateien entdeckt werden, aber es ist
                                keine perfekte Kontrolle)
                              </entry>
                          </row>
                          <row>
                              <entry><code>automatic_serialization</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                Ein- / Ausschalten der automatischen Serialisierung, kann dafür benutzt werden, um
                                Daten direkt zu speichern, welche keine Strings sind (aber es ist langsamer)
                              </entry>
                          </row>
                          <row>
                              <entry><code>automatic_cleaning_factor</code></entry>
                              <entry><code>int</code></entry>
                              <entry><code>10</code></entry>
                              <entry>
                                Ausschalten / Abgleichen des automatischen Löschprozesses (Garbage Collector):
                                0 heißt keine automatische Löschung des Caches, 1 heißt Systematische Cache
                                Löschung und x &gt; 1 heißt automatisches zufälliges Löschen 1 mal nach
                                x Schreiboperationen.
                              </entry>
                          </row>
                          <row>
                              <entry><code>ignore_user_abort</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                Auf true gesetzt, wird der Kern das PHP Flag ignore_user_abort innerhalb der
                                save() Methode setzen um Cache Korruption in einigen fällen zuverhindern
                              </entry>
                          </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>

        <sect3 id="zend.cache.core.examples">
            <title>Beispiele</title>
            <para>
                Ein Beispiel wird ganz am Anfang des Handbuches gegeben.
            </para>
            <para>
                Wenn nur Strings in den Cache gespeichert werden (denn mit der "automatic_serialization" Option
                wäre es möglich Booleans zu speichern), kann ein kompakterer Weg wie folgt gewählt werden:
            </para>
                 <programlisting role="php"><![CDATA[
// Es wird angenommen das $cache existiert

$id = 'myBigLoop'; // Die Cache ID von dem "das gecached werden soll"

if (!($data = $cache->load($id))) {
    // Cache miss

    $data = '';
    for ($i = 0; $i < 10000; $i++) {
        $data = $data . $i;
    }

    $cache->save($data);

}

// [...] Irgendwas mit $data machen (ausgeben, verarbeiten, usw.)
]]>
            </programlisting>
            <para>
                Wenn mehrere Blöcke von Daten oder Daten Instanzen gecached werden sollen, ist die
                Idee dahinter die gleiche:
            </para>
                 <programlisting role="php"><![CDATA[
// Sicherstellen, dass eindeutige Identifizierer verwendet werden:
$id1 = 'foo';
$id2 = 'bar';

// Block 1
if (!($data = $cache->load($id1))) {
    // Cache miss

    $data = '';
    for ($i=0;$i<10000;$i++) {
        $data = $data . $i;
    }

    $cache->save($data);

}
echo($data);

// Hier wird NIE gecached
echo('NIE GECACHED! ');

// Block 2
if (!($data = $cache->load($id2))) {
    // Cache miss

    $data = '';
    for ($i=0;$i<10000;$i++) {
        $data = $data . '!';
    }

    $cache->save($data);

}
echo($data);
]]>
            </programlisting>

            <para>
                Wenn spezielle Werte gecached werden sollen (boolean mit der "automatic_serialization" Option)
                oder leere Strings kann die kompakte Erstellung wie oben gezeigt nicht verwendet werden.
                Der Cache Eintrag muß formell getestet werden.
            </para>

            <programlisting role="php"><![CDATA[
// Die kompakte Erstellung
// (nicht gut wenn leere Strings und/oder boolsche Werte gecached werden)
if (!($data = $cache->load($id))) {

    // Cache fehlgeschlagen

    // [...] wir erstellen $data

    $cache->save($data);

}

// wir machen etwas mit $data

// [...]

// die komplette Erstellung (funktioniert in jedem Fall)
if (!($cache->test($id))) {

    // Cache fehlgeschlagen

    // [...] wir erstellen $data

    $cache->save($data);

} else {

    // Cache getroffen

    $data = $cache->load($id);

}

// Wir machen irgendetwas mit $data
]]>
            </programlisting>

       </sect3>

    </sect2>

    <sect2 id="zend.cache.frontends.output">
        <title><classname>Zend_Cache_Frontend_Output</classname></title>
        <sect3 id="zend.cache.frontends.output.introduction">
            <title>Einführung</title>
            <para>
                <classname>Zend_Cache_Frontend_Output</classname> ist ein Ausgabe-Empfangendes Frontend. Es verwendet den
                Ausgabe Puffer in PHP, um alles zwischen der <code>start()</code> und der <code>end()</code> Methode
                zu fangen.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontends.output.options">
            <title>Mögliche Optionen</title>
            <para>
                Dieses Frontend hat keine bestimmten Optionen zusätzlich zu denen von
                <classname>Zend_Cache_Core</classname>.
            </para>
        </sect3>

        <sect3 id="zend.cache.frontends.output.examples">
            <title>Beispiele</title>
            <para>
                Ein Beispiel wird ganz am Anfang des Handbuches gegeben. Hier ist es mit kleinen Änderungen:
            </para>
                 <programlisting role="php"><![CDATA[
// Wenn es ein Cache Miss ist, wird das puffern der Ausgabe ausgelöst
if( ! ($cache->start('mypage'))) {

    // Alle wie gewohnt ausgeben
    echo 'Hallo Welt! ';
    echo 'Das wird gecached ('.time().') ';

    $cache->end(); // Ausgabepufferung beenden

}

echo 'Hier wird nie gecached ('.time().').';
]]>
            </programlisting>
            <para>
                Die Verwendung dieser Form ist ziemlich einfach, um Ausgabe caching in einem bereits bestehenden
                Projekt, mit nur wenig oder gar keinen Codeänderungen, zu erhalten.
            </para>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.function">
        <title><classname>Zend_Cache_Frontend_Function</classname></title>
        <sect3 id="zend.cache.frontends.function.introduction">
            <title>Einführung</title>
            <para>
                <classname>Zend_Cache_Frontend_Function</classname> cached das Ergebnis von Funktionsaufrufen. Es hat
                eine einzelne Hauptmethode genannt <code>call()</code>, welche den Funktionsnamen und Parameter
                für den Aufruf in einem Array entgegennimmt.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontends.function.options">
            <title>Mögliche Optionen</title>
            <table id="zend.cache.frontends.function.options.table">
                <title>Cache Frontend Optionen</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Daten Typ</entry>
                            <entry>Standardwert</entry>
                            <entry>Beschreibung</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>cache_by_default</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  Wenn true, wird der Funktionsaufruf standardmäßig gecached
                              </entry>
                         </row>
                         <row>
                              <entry><code>cached_functions</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  Funktionsnamen, die immer gecached werden sollen
                              </entry>
                         </row>
                         <row>
                              <entry><code>non_cached_functions</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  Funktionsnamen, die nie gecached werden sollen
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>

        <sect3 id="zend.cache.frontends.function.examples">
            <title>Beispiele</title>
            <para>
                Die Verwendung der <code>call()</code> Funktion ist die gleiche, wie die von
                <code>call_user_func_array()</code> in PHP:
            </para>
                 <programlisting role="php"><![CDATA[
$cache->call('veryExpensiveFunc', $params);

// $params ist ein Array
// Für das Aufrufen von veryExpensiveFunc(1, 'foo', 'bar') mit Caching kann,
// z.B. $cache->call('veryExpensiveFunc', array(1, 'foo', 'bar')) benutzt
// werden
]]>
            </programlisting>
            <para>
                <classname>Zend_Cache_Frontend_Function</classname> ist elegant genug, um beides zu cachen, den
                Rückgabewert der Funktion und deren interne Ausgabe.
            </para>
            <note><para>
                Man kann jede eingebaute oder benutzerdefinierte Funktion übergeben, mit ausnahme von
                <code>array()</code>, <code>echo()</code>, <code>empty()</code>, <code>eval()</code>,
                <code>exit()</code>, <code>isset()</code>, <code>list()</code>, <code>print()</code>
                und <code>unset()</code>.
            </para></note>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.class">
        <title><classname>Zend_Cache_Frontend_Class</classname></title>
        <sect3 id="zend.cache.frontends.class.introduction">
            <title>Einführung</title>
            <para>
                <classname>Zend_Cache_Frontend_Class</classname> ist unterschiedlich zu <classname>Zend_Cache_Frontend_Function</classname>,
                weil es das Cachen von Objekten und statischen Methodenaufrufen erlaubt.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontends.class.options">
            <title>Mögliche Optionen</title>
            <table id="zend.cache.frontends.class.options.table">
                <title>Class Frontend Optionen</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Datentyp</entry>
                            <entry>Standardwert</entry>
                            <entry>Beschreibung</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>cached_entity</code> (Notwendig)</entry>
                              <entry><code>mixed</code></entry>
                              <entry></entry>
                              <entry>
                                  Wenn auf einen Klassennamen gesetzt, wird eine abstrakte Klasse gecached und
                                  es werden statische Aufrufe verwendet; wenn auf ein Objekt gesetzt, wird deren
                                  Objektmethoden gecached
                              </entry>
                         </row>
                         <row>
                              <entry><code>cache_by_default</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  Wenn true, wird der Aufruf standardmäßig gecached
                              </entry>
                         </row>
                         <row>
                              <entry><code>cached_methods</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  Methodennamen, die immer gecached werden sollen
                              </entry>
                         </row>
                         <row>
                              <entry><code>non_cached_methods</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  Methodennamen, die nie gecached werden sollen
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>

        <sect3 id="zend.cache.frontends.class.examples">
            <title>Beispiele</title>
            <para>
                zum Beispiel, um einen statischen Aufruf zu cachen:
            </para>
                <programlisting role="php"><![CDATA[
class Test {

    // Statische Methode
    public static function foobar($param1, $param2) {
        echo "foobar_output($param1, $param2)";
        return "foobar_return($param1, $param2)";
    }

}

// [...]
$frontendOptions = array(
    'cached_entity' => 'Test' // Der Name der Klasse
);
// [...]

// Der gecachte Aufruf
$result = $cache->foobar('1', '2');
]]>
            </programlisting>
            <para>
                Um klassische Methodenaufrufe zu cachen :
            </para>
                <programlisting role="php"><![CDATA[
class Test {

    private $_string = 'Hallo !';

    public function foobar2($param1, $param2) {
        echo($this->_string);
        echo "foobar2_output($param1, $param2)";
        return "foobar2_return($param1, $param2)";
    }

}

// [...]
$frontendOptions = array(
    'cached_entity' => new Test() // Eine Instanz der Klasse
);
// [...]

// Der gecachte Aufruf
$res = $cache->foobar2('1', '2');
]]>
            </programlisting>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.file">
        <title><classname>Zend_Cache_Frontend_File</classname></title>
        <sect3 id="zend.cache.frontends.file.introduction">
            <title>Einführung</title>
            <para>
                <classname>Zend_Cache_Frontend_File</classname> ist ein Frontend angetrieben durch den
                Änderungszeitpunkt einer "Masterdatei". Es ist wirklich interessant für Beispiele
                in Konfigurations- oder Templateanwendungen. Es ist auch möglich mehrere Masterdateien
                zu verwenden.
            </para>
            <para>
                Zum Beispiel eine XML Konfigurationsdatei, welche von einer Funktion geparsed wird
                und die ein "Config Objekt" zurückgibt (wie durch <classname>Zend_Config</classname>). Mit
                <classname>Zend_Cache_Frontend_File</classname> kann das "Config Objekt" im Cache gespeichert
                werden (um zu Verhindern, das die XML Konfiguration jedes mal geparsed wird), aber mit
                einer strengen Abhängigkeit zur "Masterdatei". Wenn also die XML Konfigurationsdatei
                geändert wird, wird der Cache sofort ungültig.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontends.file.options">
            <title>Mögliche Optionen</title>
            <table id="zend.cache.frontends.file.options.table">
                <title>File Frontend Optionen</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Daten Typ</entry>
                            <entry>Standardwert</entry>
                            <entry>Beschreibung</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>master_File (depreciated)</code></entry>
                              <entry><code>string</code></entry>
                              <entry><code></code></entry>
                              <entry>
                                  Der komplette Pfad und Name der Master Datei
                              </entry>
                          </row>
                          <row>
                              <entry><code>master_files</code></entry>
                              <entry><code>array</code></entry>
                              <entry><code></code></entry>
                              <entry>
                                  Ein Array der kompletten Pfade der Masterdateien
                              </entry>
                          </row>
                          <row>
                              <entry><code>master_files_mode</code></entry>
                              <entry><code>string</code></entry>
                              <entry><classname>Zend_Cache_Frontend_File::MODE_OR</classname></entry>
                              <entry>
                                  <classname>Zend_Cache_Frontend_File::MODE_AND</classname> oder
                                  <classname>Zend_Cache_Frontend_File::MODE_OR</classname> ;
                                  bei <code>MODE_AND</code> müssen alle Masterdateien angegriffen werden um einen
                                  Cache ungültig zu machen, bei <code>MODE_OR</code> ist eine eizelne angegriffene
                                  Datei genug um den Cache ungültig zu machen
                              </entry>
                          </row>
                          <row>
                              <entry><code>ignore_missing_master_files</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                  bei true werden fehlende Masterdateien leise ignoriert (andernfalls wird eine
                                  Exception geworfen)
                              </entry>
                          </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>
        <sect3 id="zend.cache.frontends.file.examples">
            <title>Beispiele</title>
            <para>
                Die Verwendung dieses Frontends ist die gleiche wie die von <classname>Zend_Cache_Core</classname>.
                Es gibt kein eigenes Beispiel - was als einziges gemacht werden muß, ist das <code>master_File</code>
                zu definieren, wenn die Factory verwendet wird.
            </para>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.page">
        <title><classname>Zend_Cache_Frontend_Page</classname></title>
        <sect3 id="zend.cache.frontends.page.introduction">
            <title>Einführung</title>
            <para>
                <classname>Zend_Cache_Frontend_Page</classname> ist wie <classname>Zend_Cache_Frontend_Output</classname>
                aber entwickelt für eine komplette Seite. Es ist unmöglich <classname>Zend_Cache_Frontend_Page</classname>
                nur für das Cachen eines einzelnen Blockes zu verwenden.
            </para>
            <para>
                Andererseits wird die "Cache ID" automatisch berechnet mit <code>$_SERVER['REQUEST_URI']</code> und
                (abhängig von den Optionen) mit
                <code>$_GET</code>, <code>$_POST</code>, <code>$_SESSION</code>, <code>$_COOKIE</code>, <code>$_FILES</code>.
                Trotzdem muß nur eine Methode aufgerufen werden (<code>start()</code>), weil der Aufruf von
                <code>end()</code> immer vollautomatisch ist, wenn die Seite endet.
            </para>
            <para>
                Zur Zeit ist es nicht eingebaut, aber es ist ein HTTP abhängiges System geplant, um Bandbreiten zu
                sparen (das System wird ein "HTTP 304 nicht geändert" schicken, wenn der Cache gefunden wurde und wenn
                der Browser bereits eine gültige Version hat).
            </para>
        </sect3>
        <sect3 id="zend.cache.frontends.page.options">
            <title>Mögliche Optionen</title>
            <table id="zend.cache.frontends.page.options.table">
                <title>Page Frontend Optionen</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Daten Typ</entry>
                            <entry>Standardwert</entry>
                            <entry>Beschreibung</entry>
                        </row>
                     </thead>
                     <tbody>
                            <row>
                              <entry><code>http_conditional</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                  Verwendung des http_conditional Systems (zur Zeit nicht implementiert)
                              </entry>
                         </row>
                         <row>
                              <entry><code>debug_header</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                    Wenn true, wird eine Debugging Text for jeder gecacheten Seite hinzugefügt
                              </entry>
                         </row>
                         <row>
                               <entry><code>default_options</code></entry>
                              <entry><code>array</code></entry>
                              <entry><code>array(...siehe unten...)</code></entry>
                              <entry>
                                  Ein assoziatives Array mit Default Optionen:
                                  <itemizedlist>
                                      <listitem>
                                          <para>
                                              <code>(boolean, true per Default) cache</code> :
                                              Cache ist aktiviert wenn true
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(boolean, false per Default) cache_with_get_variables</code> :
                                              wenn true, ist der Cache weiterhin aktiviert, selbst wenn es
                                              einige Variables im <code>$_GET</code> Array gibt
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(boolean, false per Default) cache_with_post_variables</code> :
                                              wenn true, ist der Cache weiterhin aktiviert, selbst wenn es
                                              einige Variables im <code>$_POST</code> Array gibt
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(boolean, false per Default) cache_with_session_variables</code> :
                                              wenn true, ist der Cache weiterhin aktiviert, selbst wenn es
                                              einige Variables im <code>$_SESSION</code> Array gibt
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(boolean, false per Default) cache_with_files_variables</code> :
                                              wenn true, ist der Cache weiterhin aktiviert, selbst wenn es
                                              einige Variables im <code>$_FILES</code> Array gibt
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(boolean, false per Default) cache_with_cookie_variables</code> :
                                              wenn true, ist der Cache weiterhin aktiviert, selbst wenn es
                                              einige Variables im <code>$_COOKIE</code> Array gibt
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(boolean, true per Default) make_id_with_get_variables</code> :
                                              wenn true, wird die Cache ID vom Inhalt des <code>$_GET</code>
                                              Arrays abhängig sein
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(boolean, true per Default) make_id_with_post_variables</code> :
                                              wenn true, wird die Cache ID vom Inhalt des <code>$_POST</code>
                                              Arrays abhängig sein
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(boolean, true per Default) make_id_with_session_variables</code> :
                                              wenn true, wird die Cache ID vom Inhalt des <code>$_SESSION</code>
                                              Arrays abhängig sein
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(boolean, true per Default) make_id_with_files_variables</code> :
                                              wenn true, wird die Cache ID vom Inhalt des <code>$_FILES</code>
                                              Arrays abhängig sein
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(boolean, true per Default) make_id_with_cookie_variables</code> :
                                              wenn true, wird die Cache ID vom Inhalt des <code>$_COOKIE</code>
                                              Arrays abhängig sein
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(int, false by default) specific_lifetime</code> :
                                              wenn nicht false, wird die angegebene Lifetime für das ausgewählte
                                              Regex verwendet
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(array, array() by default) tags</code> : Tags für den
                                              Cache Eintrag
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(int, null by default) priority</code> : Priorität
                                              (wenn das Backend das unterstützt)
                                          </para>
                                      </listitem>
                                  </itemizedlist>
                              </entry>
                         </row>
                         <row>
                              <entry><code>regexps</code></entry>
                              <entry><code>array</code></entry>
                              <entry><code>array()</code></entry>
                              <entry>
                                    Ein assoziatives Array, um Optionen nur für einige REQUEST_URI zu setzen. Die Schlüssel
                                    sind reguläre Ausdrücke (PCRE), die Werte sind ein assoziatives Array mit spezifischen
                                    Optionen, die gesetzt werden sollen, wenn der reguläre Ausdruck auf $_SERVER['REQUEST_URI']
                                    passt (siehe die default_options für eine Liste der verfügbaren Optionen); wenn verschiedene
                                    reguläre Ausdrücke auf $_SERVER['REQUEST_URI'] passen, wird nur der letzte verwendet.
                              </entry>
                         </row>
                         <row>
                              <entry><code>memorize_headers</code></entry>
                              <entry><code>array</code></entry>
                              <entry><code>array()</code></entry>
                              <entry>
                                   Ein Array von Strings die zu einem HTTP Headernamen korrespondieren.
                                   Aufgelistete Header werden mit den Cache Daten gespeichert und wieder
                                   "abgespielt" wenn der Cache getroffen wird.
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>
        <sect3 id="zend.cache.frontends.page.examples">
            <title>Beispiele</title>
            <para>
                Die Verwendung von <classname>Zend_Cache_Frontend_Page</classname> ist wirklich trivial :
            </para>
            <programlisting role="php"><![CDATA[
// [...] // Benötigt, Konfiguration und Factory

$cache->start();
// Wenn der Cache gefunden wurde, wird das Ergebnis zum Browser geschickt,
// und das Skript stoppt hier

// Rest der Seite ...
]]>
            </programlisting>
            <para>
                Ein etwas komplexeres Beispiel, welches einen Weg zeigt, um ein zentralisiertes
                Cache Management in einer Bootstrap Datei zu erhalten (um es z.B. mit <classname>Zend_Controller</classname>
                zu verwenden)
            </para>
            <programlisting role="php"><![CDATA[
/*
 * Es sollte vermieden werden, zu viele Zeilen vor dem Cache Bereich zu setzen
 * zum Beispiel sollten für optimale Performanz "require_once" oder
 * "Zend_Loader::loadClass" nach dem Cache Bereich stehen
 */

$frontendOptions = array(
   'lifetime' => 7200,
   'debug_header' => true, // für das Debuggen
   'regexps' => array(
       // cache den gesamten IndexController
       '^/$' => array('cache' => true),

       // cache den gesamten IndexController
       '^/index/' => array('cache' => true),

       // wir cachen nicht den ArticleController...
       '^/article/' => array('cache' => false),

       // ...aber wir cachen die "View" Aktion von diesem ArticleController
       '^/article/view/' => array(
           'cache' => true,

           // und wir cachen sogar wenn es einige Variablen in $_POST gibt
           'cache_with_post_variables' => true,

           // aber die Cache Id wird vom $_POST Array abhängig sein
           'make_id_with_post_variables' => true,
       )
   )
);

$backendOptions = array(
    'cache_dir' => '/tmp/'
);

// erhalte ein Zend_Cache_Frontend_Page Objekt
$cache = Zend_Cache::factory('Page',
                             'File',
                             $frontendOptions,
                             $backendOptions);

$cache->start();

// Wenn der Cache gefunden wurde, wird das Ergebnis zum Browser geschickt,
// und das Skript stoppt hier

// [...] das Ende der Bootstrap Datei
// diese Zeilen werden nicht ausgeführt, wenn der Cache ausgegeben wurde
]]>
            </programlisting>
        </sect3>
        <sect3 id="zend.cache.frontends.page.cancel">
            <title>Die spezielle cancel Methode</title>
            <para>
                Aus Designgründen, kann es in einigen Fällen (zum Beispiel bei Verwendung von nicht HTTP/200
                Return Codes), notwendig sein den aktuellen Cacheprozess zu unterbrechen. Deshalb zeigen wir
                für dieses spezielle Frontend die cancel() Methode.
            </para>
            <programlisting role="php"><![CDATA[
// [...] // Benötigt, Konfiguration und Factory

$cache->start();

// [...]

if ($someTest) {
    $cache->cancel();
    // [...]
}

// [...]
]]>
            </programlisting>
        </sect3>

    </sect2>

</sect1>
