<?xml version="1.0" encoding="UTF-8"?>
<!-- EN-Revision: 20766 -->
<!-- Reviewed: no -->
<sect1 id="zend.db.select">
    <title>Zend_Db_Select</title>

    <sect2 id="zend.db.select.introduction">
        <title>Einführung</title>

        <para>
            Das <classname>Zend_Db_Select</classname> Objekt repräsentiert ein
            <acronym>SQL</acronym> <acronym>SELECT</acronym> Anfrage Statement. Die Klasse bietet
            Methoden um einzelne Teile der Anfrage hinzuzufügen. Einzelne Teile der Anfrage können
            mit Hilfe von <acronym>PHP</acronym> Methoden und Datenstrukturen angegeben werden, und
            die Klasse erzeugt korrekte <acronym>SQL</acronym> Syntax. Nachdem die Anfrage
            formuliert wurde kann sie ausgeführt werden als wäre sie mit einem normalen String
            geschrieben worden.
        </para>

        <para>
            <classname>Zend_Db_Select</classname> bietet folgenden Nutzen:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    Objekt Orientierte Methoden um <acronym>SQL</acronym> Anfragen Stück für Stück
                    zu formulieren.
                </para>
            </listitem>

            <listitem>
                <para>
                    Datenbank unabhängige Abstraktion einiger Teile der <acronym>SQL</acronym>
                    Anfrage.
                </para>
            </listitem>

            <listitem>
                <para>
                    In den meisten Fällen automatische Quotierung von Metadaten um Bezeichner zu
                    unterstützen welche reservierte <acronym>SQL</acronym> Wörter und spezielle
                    Zeichen enthalten.
                </para>
            </listitem>

            <listitem>
                <para>
                    Quotierung von Bezeichnern und Werten um dabei zu helfen das Risiko von
                    <acronym>SQL</acronym> Injektion Attacken zu reduzieren.
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Nutzung von <classname>Zend_Db_Select</classname> ist nicht zwingend erforderlich. Für
            einfache SELECT Anfragen ist es normalerweise einfacher die gesamte
            <acronym>SQL</acronym> Anfrage in einem String zu formulieren und mit Hilfe der Methoden
            der Adapterklasse, wie <methodname>query()</methodname> oder
            <methodname>fetchAll()</methodname>, auszuführen. Die Nutzung von
            <classname>Zend_Db_Select</classname> ist hilfreich wenn eine SELECT Anfrage prozedural
            oder basierend auf der konditionellen Logik der Anwendung zusammengesetzt wird.
        </para>
    </sect2>

    <sect2 id="zend.db.select.creating">
        <title>Erzeugung eines Select Objekts</title>

        <para>
            Die Instanz eines <classname>Zend_Db_Select</classname> Objekts kann mit Hilfe der
            <methodname>select()</methodname> Methode des
            <classname>Zend_Db_Adapter_Abstract</classname> Objekts erzeugt werden.
        </para>

        <example id="zend.db.select.creating.example-db">
            <title>Beispiel für die Nutzung der select() Methode der Datenbankadapterklasse</title>

            <programlisting language="php"><![CDATA[
$db = Zend_Db::factory( ...Optionen... );
$select = $db->select();
]]></programlisting>
        </example>

        <para>
            Ein anderer Weg ein <classname>Zend_Db_Select</classname> Objekt zu erzeugen ist die
            Nutzung des Konstruktors unter Angabe des Datenbankadapters als Argument.
        </para>

        <example id="zend.db.select.creating.example-new">
            <title>Beispiel für die Erzeugung eines Select Objektes</title>

            <programlisting language="php"><![CDATA[
$db = Zend_Db::factory( ...Optionen... );
$select = new Zend_Db_Select($db);
]]></programlisting>
        </example>
    </sect2>

    <sect2 id="zend.db.select.building">
        <title>Erstellung von Select Anfragen</title>

        <para>
            Wenn die Anfrage erstellt wird können Bedingungen der Anfrage nacheinander hinzugefügt
            werden. Es gibt eine separate Methode für das Hinzufügen von verschiedenen Bedingungen
            zum <classname>Zend_Db_Select</classname> Objekt.
        </para>

        <example id="zend.db.select.building.example">
            <title>Beispiele für die Nutzung der Methoden zum Hinzufügen von Bedingungen</title>

            <programlisting language="php"><![CDATA[
// Erzeugung des Zend_Db_Select Objekts
$select = $db->select();

// Hinzufügen einer FROM Bedingung
$select->from( ...Angabe von Tabelle und Spalten... )

// Hinzufügen einer WHERE Bedingung
$select->where( ...Angabe von Suchkriterien... )

// Hinzufügen einer ORDER BY Bedingung
$select->order( ...Angabe von Sortierkriterien... );
]]></programlisting>
        </example>

        <para>
            Die meisten Methoden des <classname>Zend_Db_Select</classname> Objekts lassen sich auch
            über das bequeme Fluent Interface nutzen. Fluent Interface bedeutet das jede Methode
            eine Referenz auf das aufrufende Objekt zurück gibt, daher kann direkt eine andere
            Methode aufgerufen werden.
        </para>

        <example id="zend.db.select.building.example-fluent">
            <title>Beispiel für die Nutzung der flüssigen Schnittstelle</title>

            <programlisting language="php"><![CDATA[
$select = $db->select()
    ->from( ...Angabe von Tabelle und Spalten... )
    ->where( ...Angabe von Suchkriterien... )
    ->order( ...Angabe von Sortierkriterien... );
]]></programlisting>
        </example>

        <para>
            Die Beispiele in diesem Abschnitt zeigen die Nutzung des Fluent Interface, es kann aber
            auch immer das normale Interface verwendet werden. Häufig ist es nötig das normale
            Interface zu nutzen, zum Beispiel wenn die Anwendung vor dem Hinzufügen der Bedingung
            Berechnungen durchführen muss.
        </para>

        <sect3 id="zend.db.select.building.from">
            <title>Hinzufügen eines FROM Abschnitts</title>

            <para>
                Um die Tabelle für die Anfrage an zu geben wird die <methodname>from()</methodname>
                Methode verwendet. Der Tabellenname kann als einfacher String übergeben werden.
                <classname>Zend_Db_Select</classname> wendet Bezeichner Quotierung an, es können
                also auch spezielle Zeichen verwendet werden.
            </para>

            <example id="zend.db.select.building.from.example">
                <title>Beispiel für die from() Methode</title>

                <programlisting language="php"><![CDATA[
// Erstellen dieser Anfrage:
//   SELECT *
//   FROM "products"

$select = $db->select()
             ->from( 'products' );
]]></programlisting>
            </example>

            <para>
                Es kann auch der Beziehungsname (auch Aliasname genannt) einer Tabelle angegeben
                werden. Anstelle eines einfachen Strings muss dann ein assoziatives Array übergeben
                werden, welches den Beziehungsnamen dem tatsächlichen Tabellennamen zuordnet. In
                anderen Bedingungen der <acronym>SQL</acronym> Anfrage kann dann dieser
                Beziehungsname verwendet werden. Wenn die Anfrage mehr als eine Tabelle verbindet,
                generiert <classname>Zend_Db_Select</classname> eindeutige Beziehungsnamen basierend
                auf den Tabellennamen, wenn keine Beziehungsnamen angegeben wurden.
            </para>

            <example id="zend.db.select.building.from.example-cname">
                <title>Beispiel für das Angeben eines Beziehungsnamens</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT p.*
//   FROM "products" AS p

$select = $db->select()
             ->from( array('p' => 'products') );
]]></programlisting>
            </example>

            <para>
                Einige <acronym>RDBMS</acronym> Marken unterstützen einen voran stehenden
                Schemenbezeichner für eine Tabelle. Der Tabellenname kann mit
                "<code>schemaName.tabellenName</code>" angegeben werden,
                <classname>Zend_Db_Select</classname> Quotiert die einzelnen Teile für sich. Der
                Schemaname kann aber auch separat angegeben werden. Ein Schemaname, der mit dem
                Tabellennamen angegeben wurde bekommt Vorrang, falls beides angegeben wurde.
            </para>

            <example id="zend.db.select.building.from.example-schema">
                <title>Beispiel für das Angeben eines Schemanamens</title>

                <programlisting language="php"><![CDATA[
// Erzeut diese Anfrage:
//   SELECT *
//   FROM "myschema"."products"

$select = $db->select()
             ->from( 'myschema.products' );

// oder

$select = $db->select()
             ->from('products', '*', 'myschema');
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.select.building.columns">
            <title>Hinzufügen von Spalten</title>

            <para>
                Im zweiten Argument der <methodname>from()</methodname> Methode kann angegeben
                werden, welche Spalten der Tabelle ausgelesen werden sollen. Werden keine
                Spalten angegeben, so gilt der Standardwert <code>*</code>, der
                <acronym>SQL</acronym> Platzhalter für alle Spalten.
            </para>

            <para>
                Die Spalten können in einem einfachen Array von Strings oder einem assoziativen
                Array, in dem Aliasnamen den Spaltennamen zugewiesen werden, angegeben werden. Soll
                nur eine einzelne Spalte ohne Aliasnamen ausgelesen werden, so kann auch ein
                einfacher String übergeben werden.
            </para>

            <para>
                Wird ein leeres Array übergeben, so werden auch keine Spalten der Tabelle in den
                Ergebnissatz aufgenommen. Ein Codebeispiel gibt es unter
                <link linkend="zend.db.select.building.join.example-no-columns">code example</link>
                bei der <methodname>join()</methodname> Methode.
            </para>

            <para>
                Der Spaltenname kann mit "<code>beziehungsName.spaltenName</code>" angegeben
                werden. <classname>Zend_Db_Select</classname> Quotiert die einzelnen Teile für sich.
                Wird kein Beziehungsname für die Spalte angegeben, dann wird der Beziehungsname der
                Tabelle der aktuellen <methodname>from()</methodname> Methode verwendet.
            </para>

            <example id="zend.db.select.building.columns.example">
                <title>Beispiele für das Angeben von Spalten</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id', 'product_name'));

// Erzeugt dieselbe Anfrage, Angabe von Beziehungsnamen:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('p.product_id', 'p.product_name'));

// Erzeugt diese Anfrage mit einem Alias für eine Spalte:
//   SELECT p."product_id" AS prodno, p."product_name"
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('prodno' => 'product_id', 'product_name'));
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.select.building.columns-expr">
            <title>Hinzufügen von Spalten mit Expressions</title>

            <para>
                Spalten in einer <acronym>SQL</acronym> Anfrage sind manchmal Expressions, keine
                einfachen Spaltennamen einer Tabelle. Expressions dürfen keine Beziehungsnamen oder
                Quotierungen bekommen. Wenn der Spaltenstring runde Klammern enthält erkennt
                <classname>Zend_Db_Select</classname> dies als eine Expression.
            </para>

            <para>
                Es kann auch ein Objekt des Typs <classname>Zend_Db_Expr</classname> erzeugt werden
                um zu verhindern das ein String wie ein Spaltenname behandelt wird.
                <classname>Zend_Db_Expr</classname> ist eine Minimalklasse die einen String enthält.
                <classname>Zend_Db_Select</classname> erkennt Objekte des Typs
                <classname>Zend_Db_Expr</classname> und konvertiert diese in Strings, nimmt aber
                keine Änderungen daran vor, wie Quotierung oder Beziehungsnamen.
            </para>

            <note>
                <para>
                    Benutzung von <classname>Zend_Db_Expr</classname> für Spaltennamen ist nicht
                    nötig wenn Spaltennamen Expressions runde Klammern enthalten.
                    <classname>Zend_Db_Select</classname> erkennt diese und behandelt den String als
                    eine Expression und lässt Quotierung und Beziehungsnamen aus.
                </para>
            </note>

            <example id="zend.db.select.building.columns-expr.example">
                <title>Beispiel für das angeben von Spaltennamen, die Expressions enthalten</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT p."product_id", LOWER(product_name)
//   FROM "products" AS p
// Eine Expression eingeschlossen von runden Klammern wird zu Zend_Db_Expr.

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id', 'LOWER(product_name)'));

// Erzeugt diese Anfrage:
//   SELECT p."product_id", (p.cost * 1.08) AS cost_plus_tax
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id',
                          'cost_plus_tax' => '(p.cost * 1.08)'));

// Erzeugt diese Anfrage unter ausdrücklicher Verwendung  von Zend_Db_Expr:
//   SELECT p."product_id", p.cost * 1.08 AS cost_plus_tax
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id',
                          'cost_plus_tax' =>
                              new Zend_Db_Expr('p.cost * 1.08'))
                    );
]]></programlisting>
            </example>

            <para>
                In den oben stehenden Fällen ändern <classname>Zend_Db_Select</classname> den String
                nicht mit Beziehungsnamen oder Bezeichnerquotierung. Wenn diese Änderungen notwendig
                sein sollten um doppeldeutigkeiten auf zu lösen, muss dies manuell am String
                geändert werden.
            </para>

            <para>
                Wenn die Spaltennamen aus <acronym>SQL</acronym> Schlüsselwörtern besteht oder
                spezielle Zeichen enthält sollte die <methodname>quoteIdentifier()</methodname>
                Methode verwendet werden und der Rückgabewert in den String eingefügt werden. Die
                <methodname>quoteIdentifier()</methodname> Methode verwendet <acronym>SQL</acronym>
                Quotierung um Bezeichner abzugrenzen, wodurch klar wird, das es sich um einen
                Bezeichner für eine Tabelle oder Spalte handelt, und nicht um einem anderen Teil der
                <acronym>SQL</acronym> Syntax.
            </para>

            <para>
                Der Code wird Datenbank unabhängiger wenn die
                <methodname>quoteIdentifier()</methodname> Methode anstelle von direkter Eingabe
                der Quotierungszeichen verwendet wird, da einige <acronym>RDBMS</acronym> Marken
                nicht-Standard Symbole für die Quotierung von Bezeichnern verwenden. Die
                <methodname>quoteIdentifier()</methodname> Methode wählt die passenden
                Quotierungssymbole für den Adaptertyp aus. Die
                <methodname>quoteIdentifier()</methodname> Methode ersetzt außerdem alle
                Quotierungszeichen innerhalb des Bezeichners.
            </para>

            <example id="zend.db.select.building.columns-quoteid.example">
                <title>Beispiel für die Quotierung von Spalten in einer Expression</title>

                <programlisting language="php"><![CDATA[
// Erzeugt folgende Anfrage und Quotiert dabei einen Spaltennamen
// "from" in der Expression:
//   SELECT p."from" + 10 AS origin
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('origin' =>
                          '(p.' . $db->quoteIdentifier('from') . ' + 10)')
                   );
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.select.building.columns-atomic">
            <title>Spalten zu einer existierenden FROM oder JOIN Tabelle hinzufügen</title>

            <para>
                Es kann Fälle geben wo es gewünscht ist Spalten zu einer bestehenden FROM oder JOIN
                Tabelle hinzuzufügen nachdem diese Methoden aufgerufen wurde. Die
                <methodname>columns()</methodname> Methode erlaubt es spezifische Spalten an jedem
                Punkt hinzuzufügen bevor die Abfrage aufgeführt wird. Die Spalte kann entweder als
                String oder <classname>Zend_Db_Expr</classname> oder als Array dieser Elemente
                angegeben werden. Das zweite Argument dieser Methode kann unterdrückt werden, was
                impliziert das die Spalten zu der FROM Tabelle hinzugefügt werden sollen,
                andernfall muß ein bestehender Korrelationsname verwendet werden.
            </para>

            <example id="zend.db.select.building.columns-atomic.example">
                <title>Beispiel für das Hinzufügen von Spalten mit der columns() Methode</title>

                <programlisting language="php"><![CDATA[
// Diese Abfrage bauen:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'), 'product_id')
             ->columns('product_name');

// Die selbe Abfrage bauen, durch spezifizierung der Korrelationsnamen:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'), 'p.product_id')
             ->columns('product_name', 'p');
             // Alternativ kann columns('p.product_name') verwendet werden
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.select.building.join">
            <title>Hinzufügen einer weiteren Tabelle zu der Anfrage mit JOIN</title>

            <para>
                Viele nützliche Anfragen benötigen ein <acronym>JOIN</acronym> um mehrere Spalten
                verschiedener Tabellen miteinander zu kombinieren. Tabellen können zu einer
                <classname>Zend_Db_Select</classname> Anfrage mit der
                <methodname>join()</methodname> Methode hinzugefügt werden. Die Nutzung dieser
                Methode ist ähnlich der <methodname>from()</methodname> Methode, außer das in den
                meisten Fällen zusätzlich eine Join Bedingung angegeben werden kann.
            </para>

            <example id="zend.db.select.building.join.example">
                <title>Beispiel für die join() Methode</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT p."product_id", p."product_name", l.*
//   FROM "products" AS p JOIN "line_items" AS l
//     ON p.product_id = l.product_id

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id', 'product_name'))
             ->join(array('l' => 'line_items'),
                    'p.product_id = l.product_id');
]]></programlisting>
            </example>

            <para>
                Das zweite Argument der <methodname>join()</methodname> Methode ist ein String mit
                der Join Bedingung. Dies ist eine Exspression die Kriterien angibt, welche Zeilen
                in der einen Tabelle mit Zeilen einer anderen Tabelle verknüpft werden. Es können
                Beziehungsnamen in dieser Expression verwendet werden.
            </para>

            <note>
               <para>
                    Es wird keine Quotierung auf die Expression für die Join Bedingung angewendet.
                    Werden Spaltennamen verwendet, welche Quotierung benötigen, so muss
                    <methodname>quoteIdentifier()</methodname> verwendet werden wenn der String für
                    die Join Bedingung formuliert wird.
                </para>
            </note>

            <para>
                Das dritte Argument für <methodname>join()</methodname> ist ein Array von
                Spaltennahmen, entsprechend des Arrays der <methodname>from()</methodname> Methode.
                Der Standard ist ebenfalls "<code>*</code>" und unterstützt Beziehungsnamen,
                Expressions und <classname>Zend_Db_Expr</classname> in der gleichen Weise wie dem
                Array von Spaltennamen der <methodname>from()</methodname> Methode.
            </para>

            <para>
                Wenn keine Spalten einer Tabelle ausgewählt werden soll muss ein leeres Array für
                die Liste der Spaltennamen übergeben werden. Diese Nutzung funktioniert ebenfalls
                in der <methodname>from()</methodname> Methode, aber normalerweise werden einige
                Spalten der primären Tabelle in den Anfragen benötigt, während möglicherweise keine
                Spalten der verbundenen Tabelle ausgewählt werden sollen.
            </para>

            <example id="zend.db.select.building.join.example-no-columns">
                <title>Beispiel für das Angeben keiner Spalten</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p JOIN "line_items" AS l
//     ON p.product_id = l.product_id

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id', 'product_name'))
             ->join(array('l' => 'line_items'),
                    'p.product_id = l.product_id',
                    array() ); // leere Liste von Spalten
]]></programlisting>

                <para>
                    Zu beachten ist das leere <methodname>array()</methodname> in dem oben
                    stehenden Beispiel, am Stelle einer Liste von Spalten der verbundenen Tabelle.
                </para>
            </example>

            <para>
                <acronym>SQL</acronym> kennt verschiedene Typen von Joins. In der unten stehen Liste
                sind Methoden zu finden, für die verschiedenen Join Typen die
                <classname>Zend_Db_Select</classname> unterstützt.
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        <command>INNER JOIN</command> mit den
                        <methodname>join(tabelle, join, [spalten])</methodname> oder
                        <methodname>joinInner(tabelle, join, [spalten])</methodname> Methoden.
                    </para>

                    <para>
                        Dies wird der gebräuchlichste Typ von Join sein. Zeilen jeder Tabelle
                        werden mit Hilfe der angegebenen Join Bedingung verglichen. Der
                        Ergebnissatz enthält nur die Zeilen die der Join Bedingungen entsprechen.
                        Der Ergebnissatz kann leer sein, wenn keine Zeile die Bedingung erfüllt.
                    </para>

                    <para>
                        Alle <acronym>RDBMS</acronym> Marken unterstützen diesen Join Typ.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <command>LEFT JOIN</command> mit der
                        <methodname>joinLeft(tabelle, bedingung, [spalten])</methodname> Methode.
                    </para>

                    <para>
                        Alle Zeilen der links vom Operanden stehenden Tabelle sind enthalten,
                        passende Zeilen der rechts stehenden Tabelle sind ebenfalls enthalten. Die
                        Spalten der rechts stehenden Tabelle werden mit <constant>NULL</constant>
                        aufgefüllt, wenn keine zu der linken Tabelle passenden Zeilen existieren.
                    </para>

                    <para>
                        Alle <acronym>RDBMS</acronym> Marken unterstützen diesen Join Typ.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <command>RIGHT JOIN</command> mit der
                        <methodname>joinRight(tabelle, bedingung, [spalten])</methodname> Methode.
                    </para>

                    <para>
                        Right Outer Join ist das Gegenstück zu Left Outer Join. Alle Zeilen der
                        rechts vom Operanden stehenden Tabelle sind enthalten, passende Zeilen der
                        links stehenden Tabelle sind ebenfalls enthalten. Die Spalten der links
                        stehenden Tabelle werden mit <constant>NULL</constant> aufgefüllt, wenn
                        keine zu der rechten Tabelle passenden Zeilen existieren.
                    </para>

                    <para>
                        Einige <acronym>RDBMS</acronym> Marken unterstützen diesen Join Typ nicht,
                        aber grundsätzlich kann jeder Right Join durch einen Left Join mit
                        umgekehrter Sortierung der Tabellen dargestellt werden.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <command>FULL JOIN</command> mit der
                        <methodname>joinFull(tabelle, bedingung, [spalten])</methodname> Methode.
                    </para>

                    <para>
                        Ein Full Outer Join ist wie eine Kombination eines Left Outer Join mit
                        einem Right Outer Join. Alle Zeilen beider Tabellen sind enthalten, gepaart
                        miteinander in der gleichen Zeile des Ergebnissatzes wenn die Join
                        Bedingung erfüllt wird, oder wenn nicht, mit <constant>NULL</constant>'s an
                        Stelle der Spalten der anderen Tabelle.
                    </para>

                    <para>
                        Einige <acronym>RDBMS</acronym> Marken unterstützen diesen Join Typ nicht.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <command>CROSS JOIN</command> mit der
                        <methodname>joinCross(tabelle, [spalten])</methodname> Methode.
                    </para>

                    <para>
                        Ein Cross Join ist ein Kartesisches Produkt. Jede Zeile der ersten Tabelle
                        wird mit jeder Zeile der zweiten Tabelle verbunden. Daher ist die Anzahl
                        der Zeilen im Ergebnissatz gleich dem Produkt der Zeilenanzahlen der beiden
                        Tabellen. Der Ergebnissatz kann mit Bedingungen einer WHERE Bedingung
                        gefiltert werden. Ein Cross Join ist ähnlich der alten
                        SQL-89 JOIN Syntax.
                    </para>

                    <para>
                        Die <methodname>joinCross()</methodname> Methode hat keinen Parameter für
                        die Join Bedingung. Einige <acronym>RDBMS</acronym> Marken unterstützen
                        diesen Join Typ nicht.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <command>NATURAL JOIN</command> mit der
                        <methodname>joinNatural(tabelle, [spalten])</methodname> Methode.
                    </para>

                    <para>
                        Ein Natural Join vergleicht alle Spalten die in beiden Tabellen mit
                        gleichem Namen vorkommen. Der Vergleich prüft Gleichheit aller Spalten, ein
                        Vergleich auf Ungleichheit ist kein Natural Join. Von dieser
                        <acronym>API</acronym> werden nur Natural Inner Joins unterstützt, auch wenn
                        <acronym>SQL</acronym> auch Natural Outer Joins erlaubt.
                    </para>

                    <para>
                        Die <methodname>joinNatural()</methodname> Methode hat keinen Parameter für
                        die Join Bedingung.
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                Zusätzlich zu diesen Join Methoden können Abfragen durch Verwendung der JoinUsing
                Methoden vereinfacht werden. Statt das eine komplette Definition des Joins
                angegeben wird, kann einfach der Spaltenname übergeben werden auf welchem gejoint
                werden soll und das <classname>Zend_Db_Select</classname> Objekt vervollständigt die
                Bedingung alleine.
            </para>

            <example id="zend.db.select.building.joinusing.example">
                <title>Beispiel für die joinUsing() Methode</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Abfrage
//   SELECT *
//   FROM "table1"
//   JOIN "table2"
//   ON "table1".column1 = "table2".column1
//   WHERE column2 = 'foo'

$select = $db->select()
             ->from('table1')
             ->joinUsing('table2', 'column1')
             ->where('column2 = ?', 'foo');
]]></programlisting>
            </example>

            <para>
                Jede der anwendbaren Join Methoden in der <classname>Zend_Db_Select</classname>
                Komponente hat eine entsprechende 'using' Methode.
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        <methodname>joinUsing(table, join, [columns])</methodname> und
                        <methodname>joinInnerUsing(table, join, [columns])</methodname>
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <methodname>joinLeftUsing(table, join, [columns])</methodname>
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <methodname>joinRightUsing(table, join, [columns])</methodname>
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <methodname>joinFullUsing(table, join, [columns])</methodname>
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>

        <sect3 id="zend.db.select.building.where">
            <title>Hinzufügen eines WHERE Abschnitts</title>

            <para>
                Es können Kriterien die den Ergebnissatz einschränken mit der
                <methodname>where()</methodname> Methode angegeben werden. Das erste Argument
                dieser Methode ist eine <acronym>SQL</acronym> Expression, welche in einer
                <acronym>SQL</acronym> <acronym>WHERE</acronym> Klausel der Anfrage steht.
            </para>

            <example id="zend.db.select.building.where.example">
                <title>Beispiel für die where() Methode</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT product_id, product_name, price
//   FROM "products"
//   WHERE price > 100.00

$select = $db->select()
             ->from('products',
                    array('product_id', 'product_name', 'price'))
             ->where('price > 100.00');
]]></programlisting>
            </example>

            <note>
                <para>
                    Auf Expressions die an <methodname>where()</methodname> oder
                    <methodname>orWhere()</methodname> Methoden übergeben werden, wird keine
                    Quotierung angewendet. Werden Spaltennamen verwendet die Quotiert werden
                    müssen, so muss <methodname>quoteIdentifier()</methodname> verwendet werden
                    wenn der String für die Bedingung formuliert wird.
                </para>
            </note>

            <para>
                Das zweite Argument der <methodname>where()</methodname> Methode ist optional. Es
                ist ein Wert der in die Expression eingesetzt wird.
                <classname>Zend_Db_Select</classname> Quotiert den Wert und ersetzt ihn für ein
                Fragezeichen ("<code>?</code>") in der Expression.
            </para>

            <example id="zend.db.select.building.where.example-param">
                <title>Beispiel für einen Parameter in der where() Methode</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT product_id, product_name, price
//   FROM "products"
//   WHERE (price > 100.00)

$minimumPrice = 100;

$select = $db->select()
             ->from('products',
                    array('product_id', 'product_name', 'price'))
             ->where('price > ?', $minimumPrice);
]]></programlisting>
            </example>

            <para>
                Man kann als zweiten Parameter ein Array an die <methodname>where()</methodname>
                Methode übergeben wenn der SQL IN Operator verwendet wird.
            </para>

            <example id="zend.db.select.building.where.example-array">
                <title>Beispiel eines Array Parameters in der where() Methode</title>

                <programlisting language="php"><![CDATA[
// Diese Abrage wird gebaut:
//   SELECT product_id, product_name, price
//   FROM "products"
//   WHERE (product_id IN (1, 2, 3))

$productIds = array(1, 2, 3);

$select = $db->select()
             ->from('products',
                    array('product_id', 'product_name', 'price'))
             ->where('product_id IN (?)', $productIds);
]]></programlisting>
            </example>

            <para>
                Die <methodname>where()</methodname> Methode kann mehrere Male in dem selben
                <classname>Zend_Db_Select</classname> Objekt aufgerufen werden. Die daraus folgenden
                Anfrage kombiniert die unterschiedlichen Ausdrücke unter Benutzung von
                <acronym>AND</acronym> zwischen ihnen.
            </para>

            <example id="zend.db.select.building.where.example-and">
                <title>Beispiel für mehrfach Aufruf der where() Methode</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT product_id, product_name, price
//   FROM "products"
//   WHERE (price > 100.00)
//     AND (price < 500.00)

$minimumPrice = 100;
$maximumPrice = 500;

$select = $db->select()
            ->from('products',
                   array('product_id', 'product_name', 'price'))
            ->where('price > ?', $minimumPrice)
            ->where('price < ?', $maximumPrice);
]]></programlisting>
            </example>

            <para>
                Wenn mehrere Ausdrücke mit <acronym>OR</acronym> verknüpft werden sollen kann die
                <methodname>orWhere()</methodname> Methode verwendet werden. Sie wird genauso
                benutzt wie die <methodname>where()</methodname> Methode, außer das dem angegebene
                Ausdruck ein <acronym>OR</acronym> vorangestellt wird, anstelle eines
                <acronym>AND</acronym>.
            </para>

            <example id="zend.db.select.building.where.example-or">
                <title>Beispiel für die orWhere() Methode</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT product_id, product_name, price
//   FROM "products"
//   WHERE (price < 100.00)
//     OR (price > 500.00)

$minimumPrice = 100;
$maximumPrice = 500;

$select = $db->select()
             ->from('products',
                    array('product_id', 'product_name', 'price'))
             ->where('price < ?', $minimumPrice)
             ->orWhere('price > ?', $maximumPrice);
]]></programlisting>
            </example>

            <para>
                <classname>Zend_Db_Select</classname> klammert Expressions automatisch mit runden
                Klammern ein wenn sie mit der <methodname>where()</methodname> oder
                <methodname>orWhere()</methodname> Methode angegeben wurden. Dies hilft sicher zu
                stellen dass das voranstellen von Boolean Operatoren keine unerwarteten Ergebnisse
                nach sich zieht.
            </para>

            <example id="zend.db.select.building.where.example-parens">
                <title>Beispiel für das Einklammern von Boolean Expressions</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT product_id, product_name, price
//   FROM "products"
//   WHERE (price < 100.00 OR price > 500.00)
//     AND (product_name = 'Apple')

$minimumPrice = 100;
$maximumPrice = 500;
$prod = 'Apple';

$select = $db->select()
             ->from('products',
                    array('product_id', 'product_name', 'price'))
             ->where("price < $minimumPrice OR price > $maximumPrice")
             ->where('product_name = ?', $prod);
]]></programlisting>
            </example>

            <para>
                In dem oben stehenden Beispiel währen die Ergebnisse ohne den Klammern ziemlich
                anders, weil <acronym>AND</acronym> eine höhere Priorität als <acronym>OR</acronym>
                hat. <classname>Zend_Db_Select</classname> erzeugt runde Klammern wodurch jede
                Expression von aufeinander folgenden Aufrufen der <methodname>where()</methodname>
                Methode fester binden als das <acronym>AND</acronym> welches die Expressions
                kombiniert.
            </para>
        </sect3>

        <sect3 id="zend.db.select.building.group">
            <title>Hinzufügen eines GROUP BY Abschnitts</title>

            <para>
                In <acronym>SQL</acronym> ermöglicht der <command>GROUP BY</command> Abschnitt die
                Zeilenzahl des Ergebnissatzes auf eine Zeile pro eindeutigem Wert der Spalte(n),
                welche in dem <command>GROUP BY</command> Abschnitt benannt sind, einzuschränken.
            </para>

            <para>
                In <classname>Zend_Db_Select</classname> können diese Spalte(n) mit der
                <methodname>group()</methodname> Methode angegeben werden. Das Argument der Methode
                ist ein Spaltenname oder ein Array von Spaltennamen, welche im
                <command>GROUP BY</command> Abschnitt stehen sollen.
            </para>

            <example id="zend.db.select.building.group.example">
                <title>Beispiel für die group() Methode</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT p."product_id", COUNT(*) AS line_items_per_product
//   FROM "products" AS p JOIN "line_items" AS l
//     ON p.product_id = l.product_id
//   GROUP BY p.product_id

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id'))
             ->join(array('l' => 'line_items'),
                    'p.product_id = l.product_id',
                    array('line_items_per_product' => 'COUNT(*)'))
             ->group('p.product_id');
]]></programlisting>
            </example>

            <para>
                Wie in dem Array von Spaltennamen der <methodname>from()</methodname> Methode, so
                können auch hier Beziehungsnamen in den Strings der Spaltennamen verwendet werden,
                und der Spaltenname wird als Bezeichner Quotiert, wenn er nicht in runden Klammern
                steht oder ein Objekt des Typs <classname>Zend_Db_Expr</classname> ist.
            </para>
        </sect3>

        <sect3 id="zend.db.select.building.having">
            <title>Hinzufügen eines HAVING Abschnittes</title>

            <para>
                In <acronym>SQL</acronym> fügt der <constant>HAVING</constant> Abschnitt eine
                Beschränkungsbedingung für Gruppen von Zeilen ein. Dies ist ähnlich der
                Einschränkungsbedingungen auf Zeilen, des <constant>WHERE</constant> Abschnittes.
                Die beiden Abschnitte unterscheiden sich jedoch, denn die <constant>WHERE</constant>
                Bedingungen werden abgewendet bevor Gruppen definiert wurden. Im Gegensatz werden
                <constant>HAVING</constant> Bedingungen erst angewendet nach dem Gruppen definiert
                wurden.
            </para>

            <para>
                In <classname>Zend_Db_Select</classname> können Bedingungen für die Einschränkung
                von Gruppen mit der <methodname>having()</methodname> Methode angegeben werden. Die
                Nutzung ist ähnlich wie die der <methodname>where()</methodname> Methode. Das erste
                Argument ist ein String, welcher eine <acronym>SQL</acronym> Expression enthält. Das
                zweite Argument ist optional und wird verwendet um einen positionierten Parameter
                Platzhalter in der <acronym>SQL</acronym> Expression zu ersetzen. Expressions die
                durch mehrfaches Aufrufen der <methodname>having()</methodname> Methode erzeugt
                wurden werden mit dem Boolean <constant>AND</constant> Operator verknüpft, oder mit
                dem <code>OR</code> Operator wenn die <methodname>orHaving()</methodname> Methode
                verwendet wird.
            </para>

            <example id="zend.db.select.building.having.example">
                <title>Beispiel für die having() Methode</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT p."product_id", COUNT(*) AS line_items_per_product
//   FROM "products" AS p JOIN "line_items" AS l
//     ON p.product_id = l.product_id
//   GROUP BY p.product_id
//   HAVING line_items_per_product > 10

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id'))
             ->join(array('l' => 'line_items'),
                    'p.product_id = l.product_id',
                    array('line_items_per_product' => 'COUNT(*)'))
             ->group('p.product_id')
             ->having('line_items_per_product > 10');
]]></programlisting>
            </example>

            <note>
                <para>
                    Es wird keine Quotierung bei den Expressions welche an die
                    <methodname>having()</methodname> oder <methodname>orHaving()</methodname>
                    Methoden übergeben werden. Werden Spaltennamen verwendet die Quotiert werden
                    müssen, so muss <methodname>quoteIdentifier()</methodname> verwendet werden
                    wenn der String für die Bedingung formuliert wird.
                </para>
            </note>
        </sect3>

        <sect3 id="zend.db.select.building.order">
            <title>Hinzufügen eines ORDER BY Abschnitts</title>

            <para>
                In <acronym>SQL</acronym> gibt der <code>ORDER BY</code> Abschnitt eine oder mehrere
                Spalten oder Expressions an, wonach ein Ergebnissatz sortiert wird. Wenn mehrere
                Spalten angegeben sind, werden die sekundären Spalten verwendet um "ties"
                aufzulösen; die Sortierung wird von sekundären Spalten bestimmt, wenn vorhergehende
                Spalten identische Werte enthalten. Die standard Sortierung ist vom kleinsten zum
                größten Wert. Dieses Verhalten kann umgekehrt werden, wenn das Schlüsselwort
                <constant>DESC</constant> nach der Spalte angegeben wird.
            </para>

            <para>
                In <classname>Zend_Db_Select</classname> kann die <methodname>order()</methodname>
                Methode verwendet werden um Spalten, oder Arrays von Spalten, anzugeben, nach denen
                sortiert werden soll. Jedes Element des Arrays ist ein String, welcher die Spalte
                benennt. Optional kann auf den Namen eines der Schlüsselwörter
                <constant>ASC</constant> <constant>DESC</constant> folgen, abgetrennt durch ein
                Leerzeichen.
            </para>

            <para>
                Wie in den <methodname>from()</methodname> und <methodname>group()</methodname>
                Methoden, werden Spalten als Bezeichner Quotiert, wenn sie nicht von runden
                Klammern eingeschlossen oder vom Objekttyp <classname>Zend_Db_Expr</classname>
                sind.
            </para>

            <example id="zend.db.select.building.order.example">
                <title>Beispiel für die order() Methode</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT p."product_id", COUNT(*) AS line_items_per_product
//   FROM "products" AS p JOIN "line_items" AS l
//     ON p.product_id = l.product_id
//   GROUP BY p.product_id
//   ORDER BY "line_items_per_product" DESC, "product_id"

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id'))
             ->join(array('l' => 'line_items'),
                    'p.product_id = l.product_id',
                    array('line_items_per_product' => 'COUNT(*)'))
             ->group('p.product_id')
             ->order(array('line_items_per_product DESC',
                           'product_id'));
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.select.building.limit">
            <title>Hinzufügen eines LIMIT Abschnitts</title>

            <para>
                Einige <acronym>RDBMS</acronym> Marken erweitern <acronym>SQL</acronym> mit einem
                Anfrage Abschnitt, bekannt als <constant>LIMIT</constant> Abschnitt. Dieser
                Abschnitt begrenzt die Anzahl der Zeilen in einem Ergebnissatz auf die angegebene
                Höchstanzahl. Es kann ebenfalls angegeben werden, dass eine Anzahl von Zeilen
                ausgelassen werden soll. Dieses Feature erlaubt es eine Untermenge des
                Ergebnissatzes zu holen, zum Beispiel wenn Anfrage Ergebnisse auf aufeinander
                folgenden Seiten angezeigt werden sollen.
            </para>

            <para>
                In <classname>Zend_Db_Select</classname> kann die <methodname>limit()</methodname>
                Methode verwendet werden um die Anzahl von Zeilen und die Anzahl der auszulassenden
                Spalten anzugeben. Das <emphasis>erste</emphasis> Argument dieser Methode ist die
                gewünschte Anzahl an Zeilen. Das <emphasis>zweite</emphasis> Argument gibt die
                Anzahl der auszulassenden Zeilen an.
            </para>

            <example id="zend.db.select.building.limit.example">
                <title>Beispiel für die limit() Methode</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p
//   LIMIT 10, 20
// Identisch zu:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p
//   LIMIT 20 OFFSET 10

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id', 'product_name'))
             ->limit(20, 10);
]]></programlisting>
            </example>

            <note>
                <para>
                    Die <constant>LIMIT</constant> Syntax wird nicht von allen
                    <acronym>RDBMS</acronym> Marken unterstützt. Einige <acronym>RDBMS</acronym>
                    benötigen eine unterschiedliche Syntax für eine ähnliche Funktionalität. Jede
                    <classname>Zend_Db_Adapter_Abstract</classname> Klasse enthält eine Methode um
                    für das <acronym>RDBMS</acronym> passende <acronym>SQL</acronym> Syntax zu
                    erzeugen.
                </para>
            </note>

            <para>
                Die <methodname>limitPage()</methodname> Methode kann als alternativer Weg
                verwendet werden um Zeilenanzahl und Offset zu spezifizieren. Diese Methode erlaubt
                den Ergebnissatz auf einen Subset, aus einer Serie von Subsets mit Reihen einer
                fixe Länge, auf dem totalen Ergebnissatz der Abfrage, zu limitieren. In anderen
                Worten, spezifiziert man die Länge einer Seite ("page") von Ergebnissen, und die
                ordinale Anzahl an Ergebnissen einer einzelnen Seite, die als von der Abfrage
                zurück gegeben werden sollen. Die Seitennummer ist das erste Argument der
                <methodname>limitPage()</methodname> Methode, und die Seitenlänge ist das zweite
                Argument. Beide Argumente werden benötigt; sie haben keinen Standardwert.
            </para>

            <example id="zend.db.select.building.limit.example2">
                <title>Beispiel der limitPage() Methode</title>

                <programlisting language="php"><![CDATA[
// Erstelle diese Abfrage:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p
//   LIMIT 10, 20

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id', 'product_name'))
             ->limitPage(2, 10);
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.select.building.distinct">
            <title>Hinzufügen des DISTINCT Anfragewandlers</title>

            <para>
                Die <methodname>distinct()</methodname> Methode ermöglicht es
                <constant>DISTINCT</constant> Schlüsselworte in die <acronym>SQL</acronym> Syntax
                einzufügen.
            </para>

            <example id="zend.db.select.building.distinct.example">
                <title>Beispiel für die distinct() Methode</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT DISTINCT p."product_name"
//   FROM "products" AS p

$select = $db->select()
             ->distinct()
             ->from(array('p' => 'products'), 'product_name');
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.select.building.for-update">
            <title>Hinzufügen des FOR UPDATE Anfragewandlers</title>

            <para>
                Die <methodname>forUpdate()</methodname> Methode ermöglicht es
                <code>FOR UPDATE</code> Schlüsselworte in die <acronym>SQL</acronym> Syntax
                einzufügen.
            </para>

            <example id="zend.db.select.building.for-update.example">
                <title>Beispiel der forUpdate() Methode</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT FOR UPDATE p.*
//   FROM "products" AS p

$select = $db->select()
             ->forUpdate()
             ->from(array('p' => 'products'));
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.select.building.union">
            <title>Eine UNION Abfrage erstellen</title>

            <para>
                Man kann Union Abfragen mit <classname>Zend_Db_Select</classname> erstellen indem
                ein Array von <classname>Zend_Db_Select</classname> oder SQL Query Strings an die
                <methodname>union()</methodname> Methode übergeben wird. Als zweiter Parameter
                können die Konstanten <constant>Zend_Db_Select::SQL_UNION</constant> oder
                <constant>Zend_Db_Select::SQL_UNION_ALL</constant> übergeben werden um den Typ der
                Union zu spezifizieren den man ausführen will.
            </para>

            <example id="zend.db.select.building.union.example">
                <title>Beispiel der union() Methode</title>

                <programlisting language="php"><![CDATA[
$sql1 = $db->select();
$sql2 = "SELECT ...";

$select = $db->select()
    ->union(array($sql1, $sql2))
    ->order("id");
]]></programlisting>
            </example>
        </sect3>
    </sect2>

    <sect2 id="zend.db.select.execute">
        <title>Ausführen von SELECT Anfrage</title>

        <para>
            Dieser Abschnitt beschreibt wie Anfragen ausgeführt werden, die durch ein
            <classname>Zend_Db_Select</classname> Objekt repräsentiert werden.
        </para>

        <sect3 id="zend.db.select.execute.query-adapter">
            <title>Ausführen von Select Anfragen aus dem Db Adapter</title>

            <para>
                Die Anfrage, die durch das <classname>Zend_Db_Select</classname> Objekt
                repräsentiert wird kann ausgeführt werden, indem sie als erstes Argument an die
                <methodname>query()</methodname> Methode des
                <classname>Zend_Db_Adapter_Abstract</classname> Objekts übergeben wird. Dabei wird
                das <classname>Zend_Db_Select</classname> anstelle eines Strings verwendet.
            </para>

            <para>
                Die <methodname>query()</methodname> Methode gibt ein Objekt vom Typ
                <classname>Zend_Db_Statement</classname> oder PDOStatement
                zurück, je nachdem welcher Adaptertyp verwendet wird.
            </para>

            <example id="zend.db.select.execute.query-adapter.example">
                <title>Beispiel für die Nutzung der query() Methode des Db Adapters</title>

                <programlisting language="php"><![CDATA[
$select = $db->select()
             ->from('products');

$stmt = $db->query($select);
$result = $stmt->fetchAll();
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.select.execute.query-select">
            <title>Ausführen von Select Anfragen mit dem objekt</title>

            <para>
                Als Alternative zur Nutzung der <methodname>query()</methodname> Methode des
                Adapterobjekts kann auch die <methodname>query()</methodname> Methode des
                <classname>Zend_Db_Select</classname> Objekts verwendet werden. Beide Methoden
                geben ein Objekt vom Typ <classname>Zend_Db_Statement</classname> oder
                PDOStatement zurück, je nachdem welcher Adaptertyp verwendet wird.
            </para>

            <example id="zend.db.select.execute.query-select.example">
                <title>Beispiel für die Nutzung der query() Methode des Select Objekts</title>

                <programlisting language="php"><![CDATA[
$select = $db->select()
             ->from('products');

$stmt = $select->query();
$result = $stmt->fetchAll();
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.select.execute.tostring">
            <title>Konvertieren eines Select Objekts in einen SQL String</title>

            <para>
                Wenn Zugriff zu auf eine String Repräsentante der <acronym>SQL</acronym> Anfrage,
                entsprechend dem <classname>Zend_Db_Select</classname>, benötigt wird, kann die
                <methodname>__toString()</methodname> Methode verwendet werden.
            </para>

            <example id="zend.db.select.execute.tostring.example">
                <title>Beispiel für die __toString() Methode</title>

                <programlisting language="php"><![CDATA[
$select = $db->select()
             ->from('products');

$sql = $select->__toString();
echo "$sql\n";

// Ausgabe ist dieser String:
//   SELECT * FROM "products"
]]></programlisting>
            </example>
        </sect3>
    </sect2>

    <sect2 id="zend.db.select.other">
        <title>Andere Methoden</title>

        <para>
            Dieser Abschnitt beschreibt andere Methoden der <classname>Zend_Db_Select</classname>
            Klasse, welche bisher nicht beschrieben wurden: <methodname>getPart()</methodname> und
            <methodname>reset()</methodname>.
        </para>

        <sect3 id="zend.db.select.other.get-part">
            <title>Abfragen von Teilen des Select Objekts</title>

            <para>
                Die <methodname>getPart()</methodname> Methode gibt eine Repräsentante eines Teils
                der <acronym>SQL</acronym> Anfrage zurück. Zum Beispiel kann diese Methode verwendet
                werden um, ein Array von Expressions des <constant>WHERE</constant> Abschnitts, ein
                Array von Spalten (oder Spalten Expressions) von <constant>SELECT</constant> oder
                die Werte der Spaltenzahl und Auslassungen des <constant>LIMIT</constant>
                Abschnitts, zu erhalten.
            </para>

            <para>
                Die Rückgabe ist kein String der ein Fragment der <acronym>SQL</acronym> Syntax
                enthält. Der Rückgabewert ist eine interne Repräsentante, was typischerweise eine
                Arraystruktur ist, welche Werte und Expressions enthält. Jeder Teil der Anfrage hat
                eine unterschiedliche Struktur.
            </para>

            <para>
                Das einzige Argument der <methodname>getPart()</methodname> Methode ist ein String
                der den zurück zu gebenden Teil der Anfrage bezeichnet. Zum Beispiel bezeichnet der
                String <code>'from'</code> den Teil des Select Objekts, welcher Informationen über
                den <constant>FROM</constant> Abschnitt, einschließlich verbundener Tabellen
                enthält.
            </para>

            <para>
                Die <classname>Zend_Db_Select</classname> Klasse definiert Konstanten die für Teile
                der <acronym>SQL</acronym> Anfrage verwendet werden können. Es können die
                Konstantendefinitionen oder die literalen Strings verwendet werden.
            </para>

            <table id="zend.db.select.other.get-part.table">
                <title>Konstanten die von getPart() und reset() verwendet werden</title>

                <tgroup cols="2">
                    <thead>
                        <row>
                            <entry>Konstante</entry>
                            <entry>String Wert</entry>
                        </row>
                    </thead>

                    <tbody>
                        <row>
                            <entry><constant>Zend_Db_Select::DISTINCT</constant></entry>
                            <entry><code>'distinct'</code></entry>
                        </row>

                        <row>
                            <entry><constant>Zend_Db_Select::FOR_UPDATE</constant></entry>
                            <entry><code>'forupdate'</code></entry>
                        </row>

                        <row>
                            <entry><constant>Zend_Db_Select::COLUMNS</constant></entry>
                            <entry><code>'columns'</code></entry>
                        </row>

                        <row>
                            <entry><constant>Zend_Db_Select::FROM</constant></entry>
                            <entry><code>'from'</code></entry>
                        </row>

                        <row>
                            <entry><constant>Zend_Db_Select::WHERE</constant></entry>
                            <entry><code>'where'</code></entry>
                        </row>

                        <row>
                            <entry><constant>Zend_Db_Select::GROUP</constant></entry>
                            <entry><code>'group'</code></entry>
                        </row>

                        <row>
                            <entry><constant>Zend_Db_Select::HAVING</constant></entry>
                            <entry><code>'having'</code></entry>
                        </row>

                        <row>
                            <entry><constant>Zend_Db_Select::ORDER</constant></entry>
                            <entry><code>'order'</code></entry>
                        </row>

                        <row>
                            <entry><constant>Zend_Db_Select::LIMIT_COUNT</constant></entry>
                            <entry><code>'limitcount'</code></entry>
                        </row>

                        <row>
                            <entry><constant>Zend_Db_Select::LIMIT_OFFSET</constant></entry>
                            <entry><code>'limitoffset'</code></entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

            <example id="zend.db.select.other.get-part.example">
                <title>Beispiel der getPart() Methode</title>

                <programlisting language="php"><![CDATA[
$select = $db->select()
             ->from('products')
             ->order('product_id');

// Ein literaler String kann verwendet werden um den Abschnitt zu definieren
$orderData = $select->getPart( 'order' );

// Eine Konstante kann verwendet werden um den selben Abschnitt zu definieren
$orderData = $select->getPart( Zend_Db_Select::ORDER );

// Der zurückgegebene Wert kann eine Array Struktur sein, kein String.
// Jeder Abschnitt hat eine unterschiedliche Struktur.
print_r( $orderData );
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.select.other.reset">
            <title>Zurücksetzen von Teilen des Select Objekts</title>

            <para>
                Die <methodname>reset()</methodname> Methode ermöglicht es einen angegebenen Teil
                der <acronym>SQL</acronym> Anfrage zu löschen oder, wenn der Parameter ausgelassen
                ist, alle Teile der <acronym>SQL</acronym> Anfrage zu löschen.
            </para>

            <para>
                Das einzige Argument ist optional. Es kann der Teil der Anfrage angegeben werden,
                der gelöscht werden soll, unter Nutzung des gleichen Strings wie er als Argument
                der <methodname>getPart()</methodname> Methode verwendet wird. Der angegebene Teil
                wird auf ein Standardwert zurück gesetzt.
            </para>

            <para>
                Wenn der Parameter ausgelassen wird, setzt <methodname>reset()</methodname> alle
                geänderten Teile auf einen Standardwert zurück. Dadurch ist das
                <classname>Zend_Db_Select</classname> Objekt gleichwertig mit einem neuen Objekt,
                wie wenn es gerade Instanziiert wurde.
            </para>

            <example id="zend.db.select.other.reset.example">
                <title>Beispiel der reset() Methode</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT p.*
//   FROM "products" AS p
//   ORDER BY "product_name"

$select = $db->select()
             ->from(array('p' => 'products')
             ->order('product_name');

// Geänderte Anforderungen, stattdessen sortiert nach einer anderen Spalte:
//   SELECT p.*
//   FROM "products" AS p
//   ORDER BY "product_id"

// Lösche einen Abschnitt damit er neu defniert werden kann
$select->reset( Zend_Db_Select::ORDER );

// und definiere eine andere Spalte
$select->order('product_id');

// Lösche alle Abschnitte von der Abfrage
$select->reset();
]]></programlisting>
            </example>
        </sect3>
    </sect2>
</sect1>
