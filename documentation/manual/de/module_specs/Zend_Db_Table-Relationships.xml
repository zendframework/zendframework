<?xml version="1.0" encoding="utf-8"?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="zend.db.table.relationships"><info><title>Zend_Db_Table Relationships</title></info>
    

    <section xml:id="zend.db.table.relationships.introduction"><info><title>Einführung</title></info>
        

        <para>
            In einer relationalen Datenbank haben Tabellen Relationen zueinander. Eine Entität in
            einer Tabelle kann zu einer oder mehrerer Entitäten in einer anderen Tabelle, durch
            Verwendung von referentiellen Integritätsverknüpfungen die im Datenbank Schema
            definiert sind, verknüpft werden.
        </para>

        <para>
            Die <classname>Zend_Db_Table_Row</classname> Klasse besitzt Methoden für die Abfrage von
            verknüpften Zeilen in anderen Tabellen.
        </para>
    </section>

    <section xml:id="zend.db.table.relationships.defining"><info><title>Verknüpfungen definieren</title></info>
        

        <para>
            Die Klassen für jede eigene Tabelle müssen durch das Erweitern der abstrakten Klasse
            <classname>Zend_Db_Table_Abstract</classname>, wie in <link linkend="zend.db.table.defining">diesem Kapitel</link> beschrieben, definiert
            werden. Siehe auch in <link linkend="zend.db.adapter.example-database">diesem
                Kapitel</link> für die Beschreibung einer Beispieldatenbank für welche der folgende
            Beispielcode designed wurde.
        </para>

        <para>
            Anbei sind die <acronym>PHP</acronym> Klassendefinitionen für diese Tabellen:
        </para>

        <programlisting language="php"><![CDATA[
class Accounts extends Zend_Db_Table_Abstract
{
    protected $_name            = 'accounts';
    protected $_dependentTables = array('Bugs');
}

class Products extends Zend_Db_Table_Abstract
{
    protected $_name            = 'products';
    protected $_dependentTables = array('BugsProducts');
}

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name            = 'bugs';

    protected $_dependentTables = array('BugsProducts');

    protected $_referenceMap    = array(
        'Reporter' => array(
            'columns'           => 'reported_by',
            'refTableClass'     => 'Accounts',
            'refColumns'        => 'account_name'
        ),
        'Engineer' => array(
            'columns'           => 'assigned_to',
            'refTableClass'     => 'Accounts',
            'refColumns'        => 'account_name'
        ),
        'Verifier' => array(
            'columns'           => array('verified_by'),
            'refTableClass'     => 'Accounts',
            'refColumns'        => array('account_name')
        )
    );
}

class BugsProducts extends Zend_Db_Table_Abstract
{
    protected $_name = 'bugs_products';

    protected $_referenceMap    = array(
        'Bug' => array(
            'columns'           => array('bug_id'),
            'refTableClass'     => 'Bugs',
            'refColumns'        => array('bug_id')
        ),
        'Product' => array(
            'columns'           => array('product_id'),
            'refTableClass'     => 'Products',
            'refColumns'        => array('product_id')
        )
    );

}
]]></programlisting>

        <para>
            Wenn <classname>Zend_Db_Table</classname> verwendet wird um kaskadierende
            <constant>UPDATE</constant> und <constant>DELETE</constant> Operationen zu emulieren,
            muß das <varname>$_dependentTables</varname> Array in der Klasse für die Eltern-Tabelle
            definiert werden. Der Klassenname muß für jede abhängige Komponente aufgelistet werden.
            Hierbei muß der Klassenname und nicht der physikalische Name der <acronym>SQL</acronym>
            Tabelle verwendet werden.
        </para>

        <note>
            <para>
                Die Deklaration von <varname>$_dependentTables</varname> sollte übergangen werden
                wenn referentielle Integritätsverknüpfungen im <acronym>RDBMS</acronym> Server
                verwendet werden um kaskadierende Operationen zu implementieren. Siehe
                <link linkend="zend.db.table.relationships.cascading">dieses Kapitel</link> für
                weitere Informationen.
            </para>
        </note>

        <para>
            Das <varname>$_referenceMap</varname> Array muß in der Klasse für jede abhängige
            Tabelle deklariert werden. Das ist ein assoziatives Array von Referenz-"Regeln". Eine
            Referenzregel identifiziert welche Tabelle in der Relation die Elterntabelle ist, und
            listet auch welche Spalten in der abhängigen Tabelle welche Spalten in der
            Elterntabelle referenzieren.
        </para>

        <para>
            Der Schlüssel der Regel ist ein String der als Index zum
            <varname>$_referenceMap</varname> Array verwendet wird. Dieser Regelschlüssel wird
            verwendet um jede Referenzen von Abhängigkeiten zu idenzifizieren. Es sollte ein
            sprechender Name für diesen Regelschlüssel ausgewählt werden. Deshalb ist es das beste
            einen String zu verwendet welcher Teil eines <acronym>PHP</acronym> Methodennamens sein
            kann, wie man später sieht.
        </para>

        <para>
            Im Beispiel <acronym>PHP</acronym> Code von oben, sind die Regelschlüssel in der Bugs
            Tabelle folgende: <command>'Reporter'</command>, <command>'Engineer'</command>,
            <command>'Verifier'</command>, und <command>'Product'</command>.
        </para>

        <para>
            Die Werte von jedem Regeleintrag im <varname>$_referenceMap</varname> Array sind auch
            ein assoziatives Array. Die Elemente dieses Regeleintrages werden im folgenden
            beschrieben:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <emphasis>columns</emphasis> =&gt; Ein String oder ein Array von
                    Strings welche die Namen der entfernten Schlüsselspalte der abhängigen Tabelle
                    benennen.
                </para>

                <para>
                    Es ist üblich das dies eine einzelne Spalte ist, aber einige Tabellen haben
                    mehr-spaltige Schlüssel.
                </para>
            </listitem>

            <listitem>
                <para>
                    <emphasis>refTableClass</emphasis> =&gt; Der Klassenname der
                    Elterntabelle. Es sollte der Klassenname und nicht der physikalische Name der
                    <acronym>SQL</acronym> Tabelle verwendet werden.
                </para>

                <para>
                    Es ist für eine abhängige Tabelle üblich eine eigene Referenz zu Ihrer
                    Elterntabelle zu haben, aber einige Tabellen haben mehrfache Referenzen zu der
                    gleichen Elterntabelle. In der Beispieldatenbank gibt es eine Referenz von der
                    <command>bugs</command> Tabelle zu der <command>products</command> Tabelle, aber
                    drei Referenzen von der <command>bugs</command> Tabelle zur
                    <command>accounts</command> Tabelle. Jede Referenz sollte in einen separaten
                    Eintrag im <varname>$_referenceMap</varname> Array gegeben werden.
                </para>
            </listitem>

            <listitem>
                <para>
                    <emphasis>refColumns</emphasis> =&gt; Ein String oder ein Array von
                    Strings die den Spaltennamen des primären Schlüssels in der Elterntabelle
                    benennen.
                </para>

                <para>
                    Es ist üblich das dies eine einzelne Spalte ist, aber einige Tabellen haben
                    mehr-spaltige Schlüssel. Wenn die Referenz einen mehr-spaltigen Schlüssel
                    verwendet, muß die Reihenfolge der Spalten im <command>'columns'</command>
                    Eintrag der Reihenfolge der Spalten im <command>'refColumns'</command> Eintrag
                    entsprechen.
                </para>

                <para>
                    Dieses Element kann optional spezifiziert werden. Wenn
                    <property>refColumns</property> nicht spezifiziert wird, werden standardmäßig
                    die Spalten verwendet, die als primäre Schlüsselspalten in der Elterntabelle
                    bekannt sind.
                </para>
            </listitem>

            <listitem>
                <para>
                    <emphasis>onDelete</emphasis> =&gt; Eine Regel für eine Aktion die
                    ausgeführt wird wenn eine Zeile in der Elterntabelle gelöscht wird. Siehe auch
                    <link linkend="zend.db.table.relationships.cascading">dieses Kapitel</link> für
                    weitere Informationen.
                </para>
            </listitem>

            <listitem>
                <para>
                    <emphasis>onUpdate</emphasis> =&gt; Eine Regel für eine Aktion die
                    ausgeführt wird wenn Werte in der primären Schlüsselspalte der Elterntabelle
                    aktualisiert werden. Siehe auch
                    <link linkend="zend.db.table.relationships.cascading">dieses Kapitel</link> für
                    weitere Informationen.
                </para>
            </listitem>
        </itemizedlist>
    </section>

    <section xml:id="zend.db.table.relationships.fetching.dependent"><info><title>Eine abhängige Zeile holen</title></info>
        

        <para>
            Wenn man ein Zeilen Objekt als Ergebnis einer Abfrage auf einer Elterntabelle hat,
            können Zeilen der abhängigen Tabellen geholt werden, welche die aktuelle Zeile
            referenzieren. Hierbei kann die folgende Methode verwendet werden:
        </para>

        <programlisting language="php"><![CDATA[
$row->findDependentRowset($table, [$rule]);
]]></programlisting>

        <para>
            Diese Methode gibt ein <classname>Zend_Db_Table_Rowset_Abstract</classname> Objekt
            zurück, welche ein Set von Zeilen der abhängigen Tabelle <varname>$table</varname>
            enthält die die Zeile referenzieren die durch das <varname>$row</varname> Objekt
            identifiziert werden.
        </para>

        <para>
            Das erste Argument <varname>$table</varname> kann ein String sein, der die abhängige
            Tabelle durch Ihren Klassennamen spezifiziert. Man kann die abhängige Tabelle auch durch
            Verwendung eines Objekts dieser Tabellenklasse spezifizieren.
        </para>

        <example xml:id="zend.db.table.relationships.fetching.dependent.example"><info><title>Eine abhängige Zeile holen</title></info>
            

            <para>
                Dieses Beispiel zeigt wie man ein Zeilenobjekt von der Tabelle
                <command>Accounts</command> erhält und die <command>Bugs</command> findet die durch
                diesen Account mitgeteilt wurden.
            </para>

            <programlisting language="php"><![CDATA[
$accountsTable = new Accounts();
$accountsRowset = $accountsTable->find(1234);
$user1234 = $accountsRowset->current();

$bugsReportedByUser = $user1234->findDependentRowset('Bugs');
]]></programlisting>
        </example>

        <para>
            Das zweite Argument <varname>$rule</varname> ist optional. Es ist ein String der den
            Regelschlüssel im <varname>$_referenceMap</varname> Array der abhängigen Tebellenklasse
            benennt. Wenn keine Regel spezifiziert wird, wird die erste Regel im Array verwendet
            welche die Elterntabelle referenziert. Wenn eine andere Regel als die erste verwendet
            werden soll, muß der Schlüssel spezifiziert werden.
        </para>

        <para>
            Im obigen Beispiel wird der Regelschlüssel nicht spezifiziert, sodas standardmäßig die
            Regel verwendet wird die als erste der Elterntabelle entspricht. Das ist die Regel
            <command>'Reporter'</command>.
        </para>

        <example xml:id="zend.db.table.relationships.fetching.dependent.example-by"><info><title>Eine anhängige Zeile durch eine spezifische Regel erhalten</title></info>
            

            <para>
                Das Beispiel zeigt wie ein Zeilenobjekt von der <command>Accounts</command> Tabelle
                erhalten werden kann, und die zugeordneten <command>Bugs</command> die vom Benutzer
                dieses Accounts bereits gefixed wurden, gefunden werden können. Der String des
                Regelschlüssels der zu dieser Referenziellen Abhängigkeit in dem Beispiel
                korrespondiert ist <command>'Engineer'</command>.
            </para>

            <programlisting language="php"><![CDATA[
$accountsTable = new Accounts();
$accountsRowset = $accountsTable->find(1234);
$user1234 = $accountsRowset->current();

$bugsAssignedToUser = $user1234->findDependentRowset('Bugs', 'Engineer');
]]></programlisting>
        </example>

        <para>
            Es können auch Kriterien, Sortierungen und Limits zur Relation hinzugefügt werden indem
            das Select Objekt der Elternzeilen verwendet wird.
        </para>

        <example xml:id="zend.db.table.relationships.fetching.dependent.example-by-select"><info><title>
                Ein anhängiges Zeilenset erhalten indem Zend_Db_Table_Select verwendet wird
            </title></info>
            

            <para>
                Dieses Beispiel zeigt wir ein Zeilenobjekt von der Tabelle
                <command>Accounts</command> empfangen werden kann, und die zugeordneten
                <command>Bugs</command> die vom Benutzer dieses Zugangs zu beheben sind, gefunden
                werden können, beschränkt auf 3 Zeilen und nach Name sortiert.
            </para>

            <programlisting language="php"><![CDATA[
$accountsTable = new Accounts();
$accountsRowset = $accountsTable->find(1234);
$user1234 = $accountsRowset->current();
$select = $accountsTable->select()->order('name ASC')
                                  ->limit(3);

$bugsAssignedToUser = $user1234->findDependentRowset('Bugs',
                                                     'Engineer',
                                                     $select);
]]></programlisting>
        </example>

        <para>
            Alternativ können Zeilen von einer abhängigen Tabelle abgefragt werden indem ein
            spezieller Mechanismus verwendet wird der "magische Methode" genannt wird.
            <classname>Zend_Db_Table_Row_Abstract</classname> ruft die Methode:
            <methodname>findDependentRowset('&lt;TabellenKlasse&gt;', '&lt;Regel&gt;')</methodname>
            auf wenn eine Methode am Zeilenobjekt aufgerufen wird die einem der folgenden Patterns
            entspricht:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <command>$row-&gt;find&lt;TabellenKlasse&gt;()</command>
                </para>
            </listitem>

            <listitem>
                <para>
                    <command>$row-&gt;find&lt;TabellenKlasse&gt;By&lt;Regel&gt;()</command>
                </para>
            </listitem>
        </itemizedlist>

        <para>
            In den obigen Patterns, sind <command>&lt;TabellenKlasse&gt;</command> und
            <command>&lt;Regel&gt;</command> Strings die mit dem Klassennamen der abhängigen Tabelle
            korrespondieren, und der Regelschlüssel der abhängigen Tabelle der die Enterntabelle
            referenziert.
        </para>

        <note>
            <para>
                Einige Applikationsframeworks, wie Ruby on Rails, verwenden einen Mechanismus der
                "inflection" genannt wird um die Änderung der Schreibweise von Identifizierern
                abhängig von der Verwendung zu erlauben. Der Einfachheit halber, bietet
                <classname>Zend_Db_Table_Row</classname> keinen Inflection Mechanismus an. Die
                Identität der Tabelle und der Regelschlüssel die im Methodenaufruf genannt werden
                müssen der Schreibweise der Klasse und des Regelschlüssels exakt entsprechen.
            </para>
        </note>

        <example xml:id="zend.db.table.relationships.fetching.dependent.example-magic"><info><title>Holen von abhängigen Zeilen durch Verwendung der magischen Methode</title></info>
            

            <para>
                Dieses Beispiel zeigt wie abhängige Zeilen gefunden werden, entsprechend des
                vorherigen Beispiel. In diesem Fall, verwendet die Anwendung den magischen
                Methodenaufruf anstatt die Tabelle und Regel als String zu spezifizieren.
            </para>

            <programlisting language="php"><![CDATA[
$accountsTable = new Accounts();
$accountsRowset = $accountsTable->find(1234);
$user1234 = $accountsRowset->current();

// Verwendung der standard Referenzregel
$bugsReportedBy = $user1234->findBugs();

// Eine Referenzregel spezifizieren
$bugsAssignedTo = $user1234->findBugsByEngineer();
]]></programlisting>
        </example>
    </section>

    <section xml:id="zend.db.table.relationships.fetching.parent"><info><title>Eine Elternzeile holen</title></info>
        

        <para>
            Wenn man ein Zeilenobjekt als Ergebnis einer Abfrage auf eine abhängige Tabelle hat,
            kann man die Zeile vom Elternteil zu der die abhängige Zeile referenziert holen.
            Hierbei verwendet man die Methode:
        </para>

        <programlisting language="php"><![CDATA[
$row->findParentRow($table, [$rule]);
]]></programlisting>

        <para>
            Es sollte immer exakt eine Zeile in der Elterntabelle durch eine abhängige Zeile
            referenziert sein, deshalb gibt diese Methode ein Zeilen Objekt und kein Zeilenset
            Objekt zurück.
        </para>

        <para>
            Das erste Argument <varname>$table</varname> kann ein String sein der die Elterntabelle
            durch Ihren Klassennamen spezifiziert. Man kann die Elterntabelle auch durch Verwendung
            eines Objektes dieser Tabellenklasse spezifizieren.
        </para>

        <example xml:id="zend.db.table.relationships.fetching.parent.example"><info><title>Eine Elternzeile holen</title></info>
            

            <para>
                Dieses Beispiel zeigt wie ein Zeilen Objekt von der Tabelle <command>Bugs</command>
                geholt werden kann (zum Beispiel einer dieser Fehler mit Status 'NEW'), und die
                Zeile in der <command>Accounts</command> Tabelle für diesen Benutzer, der den Fehler
                gemeldet hat, gefunden werden kann.
            </para>

            <programlisting language="php"><![CDATA[
$bugsTable = new Bugs();
$bugsRowset = $bugsTable->fetchAll(array('bug_status = ?' => 'NEW'));
$bug1 = $bugsRowset->current();

$reporter = $bug1->findParentRow('Accounts');
]]></programlisting>
        </example>

        <para>
            Das zweite Argument <varname>$rule</varname> ist optional. Es ist ein Strung der den
            Regelschlüssel im <varname>$_referenceMap</varname> Array der abhängigen Tabellenklasse
            benennt. Wenn diese Regel nicht spezifiziert wird, wird die erste Regel im Array
            genommen das die Elterntabelle referenziert. Wenn eine andere Regel als der erste
            genommen werden muß, dann muß der Schlüssel spezifiziert werden.
        </para>

        <para>
            Im obigen Beispiel wird der Regelschlüssel nicht spezifiziert, sodas standardmäßig die
            Regel verwendet wird die als erste der Elterntabelle entspricht. Das ist die Regel
            <command>'Reporter'</command>.
        </para>

        <example xml:id="zend.db.table.relationships.fetching.parent.example-by"><info><title>Eine Elternzeile durch eine spezifizierte Regel holen</title></info>
            

            <para>
                Dieses Beispiel zeigt wie ein Zeilenobjekt von der Tabelle <command>Bugs</command>
                geholt werden kann, und der Account für den Ingenieur der zugeordnet wurde, diesen
                Fehler zu beheben, gefunden werden kann. Der Regelschlüssel der in diesem Beispiel
                der referenzierten Abhängigkeit entspricht ist <command>'Engineer'</command>.
            </para>

            <programlisting language="php"><![CDATA[
$bugsTable = new Bugs();
$bugsRowset = $bugsTable->fetchAll(array('bug_status = ?', 'NEW'));
$bug1 = $bugsRowset->current();

$engineer = $bug1->findParentRow('Accounts', 'Engineer');
]]></programlisting>
        </example>

        <para>
            Alternativ, können Zeilen von der Elterntabelle abgefragt werden indem eine
            "magische Methode" verwendet wird. <classname>Zend_Db_Table_Row_Abstract</classname>
            ruft die Methode:
            <methodname>findParentRow('&lt;TableClass&gt;', '&lt;Rule&gt;')</methodname> auf
            wenn eine Methode auf dem Zeilenobjekt aufgerufen wird die einer der folgenden Pattern
            entspricht:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <command>$row-&gt;findParent&lt;TabellenKlasse&gt;([Zend_Db_Table_Select
                        $select])</command>
                </para>
            </listitem>

            <listitem>
                <para>
                    <command>$row-&gt;findParent&lt;TabellenKlasse&gt;By&lt;Regel&gt;(
                        [Zend_Db_Table_Select $select])</command>
                </para>
            </listitem>
        </itemizedlist>

        <para>
            In den obigen Pattern sind, <command>&lt;TabellenKlasse&gt;</command> und
            <command>&lt;Regel&gt;</command> Strings die dem Klassennamen der Elterntabelle
            entsprechen, und der Regelname der abhängigen Tabelle der die Elterntabelle
            referenziert.
        </para>

        <note>
            <para>
                Die Identität der Tabelle und des Regelschlüssels die im Aufruf der Methode genannt
                werden, müssen der Schreibweise der Klasse und des Regelschlüssels exakt
                entsprechen.
            </para>
        </note>

        <example xml:id="zend.db.table.relationships.fetching.parent.example-magic"><info><title>Die Elternzeile durch verwenden der magischen Methode holen</title></info>
            

            <para>
                Dieses Beispiel zeigt wie Elternzeilen gefunden werden, ähnlich dem vorherigen
                Beispiel. In diesem Fall verwendet die Anwendung den Aufruf der magischen Methode
                statt der Spezifizierung von Tabelle und Regel als Strings.
            </para>

            <programlisting language="php"><![CDATA[
$bugsTable = new Bugs();
$bugsRowset = $bugsTable->fetchAll(array('bug_status = ?', 'NEW'));
$bug1 = $bugsRowset->current();

// Verwenden der standardmäßigen Referenzregel
$reporter = $bug1->findParentAccounts();

// Die Referenzregel spezifizieren
$engineer = $bug1->findParentAccountsByEngineer();
]]></programlisting>
        </example>
    </section>

    <section xml:id="zend.db.table.relationships.fetching.many-to-many"><info><title>Ein Zeilenset über eine Viele-zu-Viele Verknüpfung holen</title></info>
        

        <para>
            Wenn man ein Zeilenobjekt als Ergebnis einer Abfrage auf eine Tabelle in einer
            Viele-Zu-Viele Verknüpfung hat (für die Zwecke dieses Beispiels, nennen wir das die
            "Original" Tabelle), können entsprechende Zeilen in der anderen Tabelle (nennen wir das
            die "Ziel" Tabelle) über eine Verknüpfungstabelle geholt werden. Hierbei wird die
            folgende Methode verwendet:
        </para>

        <programlisting language="php"><![CDATA[
$row->findManyToManyRowset($table,
                           $intersectionTable,
                           [$rule1,
                               [$rule2,
                                   [Zend_Db_Table_Select $select]
                               ]
                           ]);
]]></programlisting>

        <para>
            Diese Methode gibt ein <classname>Zend_Db_Table_Rowset_Abstract</classname> zurück
            welches Zeilen von der Tabelle <varname>$table</varname> enthält, und der Viele-Zu-Viele
            Abhängigkeit entspricht. Das aktuelle Zeilenobjekt <varname>$row</varname> von der
            originalen Tabelle wird verwendet um Zeilen in der Verknüpfungstabelle zu finden, und es
            ist mit der Zieltabelle verbunden.
        </para>

        <para>
            Das erste Argument <varname>$table</varname> kann ein String sein der die Zieltabelle in
            der Viele-Zu-Viele Verknüpfung durch seinen Klassennamen spezifiziert. Es kann auch die
            Zieltabelle durch Verwendung eines Objekts dieser Tabellenklasse spezifiziert werden.
        </para>

        <para>
            Das zweite Argument <varname>$intersectionTable</varname> kann ein String sein, der die
            Verknüpfungstabelle zwischen diesen zwei Tabellen in der Viele-Zu-Viele Verknüpfung,
            durch seinen Klassennamen, spezifiziert. Die Verknüpfungstabelle kann auch durch
            Verwendung eines Objektes dieser Tabellenklasse spezifiziert werden.
        </para>

        <example xml:id="zend.db.table.relationships.fetching.many-to-many.example"><info><title>Ein Zeilenset mit einer Viele-Zu-Viele Methode holen</title></info>
            

            <para>
                Dieses Beispiel zeigt wie man ein Zeilenobjekt von der Originaltabelle
                <command>Bugs</command> erhält, und wie Zeilen von der Zieltabelle
                <command>Products</command> gefunden werden können die Produkte repräsentieren
                welche diesem Bug zugeordnet sind.
            </para>

            <programlisting language="php"><![CDATA[
$bugsTable = new Bugs();
$bugsRowset = $bugsTable->find(1234);
$bug1234 = $bugsRowset->current();

$productsRowset = $bug1234->findManyToManyRowset('Products',
                                                 'BugsProducts');
]]></programlisting>
        </example>

        <para>
            Das dritte und vierte Argument <varname>$rule1</varname> und <varname>$rule2</varname>
            sind optional. Das sind Strings die den Regelschlüssel im
            <varname>$_referenceMap</varname> Array der verknüpfungstabelle benennen.
        </para>

        <para>
            Der <varname>$rule1</varname> Schlüssel benennt die Regel für die Verknüpfung der
            Verknüpfungstabelle zur Originaltabelle. In diesem Beispiel ist das die verknüpfung von
            <command>BugsProducts</command> zu <command>Bugs</command>.
        </para>

        <para>
            Der <varname>$rule2</varname> Schlüssel benennt die Regel für die Verknüpfung der
            Verknüpfungstabelle zur Zieltabelle. In diesem Beispiel ist der die Verknüpfung von
            <command>Bugs</command> zu <command>Products</command>.
        </para>

        <para>
            Ähnlich den Methoden für das finden von Eltern- und abhängigen Zeilen verwendet die
            Methode, wenn keine Regel spezifiziert wird, die erste Regel im
            <varname>$_referenceMap</varname> Array das den Tabellen in der Verknüpfung entspricht.
            Wenn eine andere Regel als die erste verwendet werden soll, muß der Schlüssel
            spezifiziert werden.
        </para>

        <para>
            Im obigen Beispiel wird der Regelschlüssel nicht spezifiziert, sodas standardmäßig die
            ersten passenden Regeln verwendet werden. In diesem Fall ist <varname>$rule1</varname>
            <command>'Reporter'</command> und <varname>$rule2</varname> ist
            <command>'Product'</command>.
        </para>

        <example xml:id="zend.db.table.relationships.fetching.many-to-many.example-by"><info><title>
                Ein Zeilenset mit einer Viele-Zu-Viele Methode durch eine spezielle Regel holen
            </title></info>
            

            <para>
                Dieses Beispiel zeigt wie man ein Zeilenobjekt von der Originaltabelle
                <command>Bugs</command> erhält, und Zeilen von der Zieltabelle
                <command>Products</command> findet die Produkte repräsentieren die dem Fehler
                zugeordnet sind.
            </para>

            <programlisting language="php"><![CDATA[
$bugsTable = new Bugs();
$bugsRowset = $bugsTable->find(1234);
$bug1234 = $bugsRowset->current();

$productsRowset = $bug1234->findManyToManyRowset('Products',
                                                 'BugsProducts',
                                                 'Bug');
]]></programlisting>
        </example>

        <para>
            Alternativ können Zeilen von der Zieltabelle in einer Viele-Zu-Viele Verknüpfung
            abgefragt werden inden eine "magische Methode" verwendet wird.
            <classname>Zend_Db_Table_Row_Abstract</classname> ruft die Methode:
            <command>findManyToManyRowset('&lt;TabellenKlasse&gt;',
                '&lt;VerknüpfungTabellenKlasse&gt;', '&lt;Regel1&gt;', '&lt;Regel2&gt;')</command>
            auf, wenn eine Methode aufgerufen wird die einem der folgenden Pattern entspricht:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <command>$row-&gt;find&lt;TabellenKlasse&gt;Via&lt;VerknüpfungsTabellenKlasse&gt;
                        ([Zend_Db_Table_Select $select])</command>
                </para>
            </listitem>

            <listitem>
                <para>
                    <command>$row-&gt;find&lt;TabellenKlasse&gt;Via&lt;VerknüpfungsTabellenKlasse&gt;By&lt;Regel1&gt;
                        ([Zend_Db_Table_Select $select])</command>
                </para>
            </listitem>

            <listitem>
                <para>
                    <command>$row-&gt;find&lt;TabellenKlasse&gt;Via&lt;VerknüpfungsTabellenKlasse&gt;By&lt;Regel1&gt;And&lt;Regel2&gt;
                        ([Zend_Db_Table_Select $select])</command>
                </para>
            </listitem>
        </itemizedlist>

        <para>
            In den oben gezeigten Pattern sind <command>&lt;TabellenKlasse&gt;</command> und
            <command>&lt;VerknüpfungsTabellenKlasse&gt;</command> Strings die den Klassennamen der
            Zieltabelle und der Verknüpfungstabelle entsprechen. <command>&lt;Regel1&gt;</command>
            und <command>&lt;Regel2&gt;</command> sind Strings die den Regelschlüssel in der
            Verknüpfungstabelle entsprechen, welche die Originaltabelle und die Zieltabelle
            referenzieren.
        </para>

        <note>
            <para>
                Die Tabelleneinheiten und die Regelschlüssel die in der aufgerufenen Methode
                benannt werden, müssen exakt der Schreibweise der Klasse und des Regelschlüssels
                entsprechen.
            </para>
        </note>

        <example xml:id="zend.db.table.relationships.fetching.many-to-many.example-magic"><info><title>Zeilensets durch Verwendung der magischen Viele-Zu-Viele Methode holen</title></info>
            

            <para>
                Dieses Beispiel zeigt wie Zeilen in der Zieltabelle einer Viele-Zu-Viele
                Verknüpfung gefunden werden können, in der Produkte die einen Bezug zu einem
                angegebenen Fehler haben, entsprechen.
            </para>

            <programlisting language="php"><![CDATA[
$bugsTable = new Bugs();
$bugsRowset = $bugsTable->find(1234);
$bug1234 = $bugsRowset->current();

// Verwendung der standardmäßigen Referenzregel
$products = $bug1234->findProductsViaBugsProducts();

// Spezifizieren der Referenzregel
$products = $bug1234->findProductsViaBugsProductsByBug();
]]></programlisting>
        </example>
    </section>

    <section xml:id="zend.db.table.relationships.cascading"><info><title>Schreiboperationen kaskadieren</title></info>
        

        <note><info><title>Deklarieren von DRI in der Datenbank:</title></info>
            

            <para>
                Die Deklaration von kaskadierenden Operationen in
                <classname>Zend_Db_Table</classname> <emphasis>nur</emphasis> für
                <acronym>RDBMS</acronym> Marken gedacht die keine deklarative referentielle
                Integrität unterstützen (<acronym>DRI</acronym>).
            </para>

            <para>
                Zum Beispiel, bei der Verwendung von MySQL's MyISAM Speicherengine oder SQLite.
                Diese Lösungen unterstützen kein <acronym>DRI</acronym>. Hierbei ist es hilfreich
                die kaskadierenden Operationen mit <classname>Zend_Db_Table</classname> zu
                deklarieren.
            </para>

            <para>
                Wenn die eigene <acronym>RDBMS</acronym> <acronym>DRI</acronym> implementiert sowie
                die ON <constant>DELETE</constant> und ON <constant>UPDATE</constant> Klauseln,
                sollten diese Klauseln im eigenen Datenbank Schema deklariert werden, anstatt das
                kaskadierende Feature von <classname>Zend_Db_Table</classname> zu verwenden. Die
                Deklaration von <acronym>DRI</acronym> Regeln in der <acronym>RDBMS</acronym> ist
                besser für die Geschwindigkeit der Datenbank, Konsistenz und Integrität.
            </para>

            <para>
                Am wichtigsten ist aber das die kaskadierenden Operationen nicht in beiden, der
                <acronym>RDBMS</acronym> und der eigenen <classname>Zend_Db_Table</classname>
                Klasse deklariert werden.
            </para>
        </note>

        <para>
            Kaskadierende Operationen können deklariert werden um anhand einer abhängigen Tabelle
            ausgeführt zu werden wenn ein <constant>UPDATE</constant> oder ein
            <constant>DELETE</constant> an einer Zeile in einer Elterntabelle ausgeführt wird.
        </para>

        <example xml:id="zend.db.table.relationships.cascading.example-delete"><info><title>Beispiel für ein kaskadierendes Löschen</title></info>
            

            <para>
                Dieses Beispiel zeigt das Löschen einer Zeile in der <command>Products</command>
                Tabelle, welche konfiguriert ist um automatisch abhängige Zeilen in der
                <command>Bugs</command> Tabelle zu löschen.
            </para>

            <programlisting language="php"><![CDATA[
$productsTable = new Products();
$productsRowset = $productsTable->find(1234);
$product1234 = $productsRowset->current();

$product1234->delete();
// Kaskadiert automatisch zur Bugs Tabelle und löscht abhängige Zeilen.
]]></programlisting>
        </example>

        <para>
            Genauso kann es gewünscht sein, wenn man ein <constant>UPDATE</constant> verwendet um
            den Wert eines primären Schlüssels in einer Elterntabelle zu verändern, das sich auch
            den Wert im entfernten Schlüssel der abhängigen Tabellen automatisch von selbst
            aktualisiert um dem neuen Wert zu entsprechen, sodas solche Referenzen aktuel gehalten
            werden.
        </para>

        <para>
            Normalerweise ist es nicht notwendig die Werte eines primären Schlüssels, der durch
            eine Sequenz von anderen Mechanismen erstellt wurde, zu aktualisieren. Aber wenn man
            einen <emphasis>natürlichen Schlüssel</emphasis> verwendet, der den Wert plötzlich
            ändert, ist es besser kaskadierende Aktualisierungen auf abhängigen Tabellen
            durchzuführen.
        </para>

        <para>
            Um eine kaskadierende Abhängigkeit in <classname>Zend_Db_Table</classname> zu
            deklarieren, müssen die Regeln in <varname>$_referenceMap</varname> bearbeitet werden.
            Die assoziativen Arrayschlüssel <command>'onDelete'</command> und
            <command>'onUpdate'</command> müssen auf den String 'cascade' (oder die Konstante
            <constant>self::CASCADE</constant>) gesetzt werden. Bevor eine Zeile von der
            Elterntabelle gelöscht wird oder dessen Wert des primären Schlüssels aktualisiert wird,
            werden alle Zeilen in der abhängigen Tabelle, welche die Eltern-Zeilen referenzieren,
            zuerst gelöscht oder aktualisiert.
        </para>

        <example xml:id="zend.db.table.relationships.cascading.example-declaration"><info><title>Beispieldeklaration einer kaskadierenden Operation</title></info>
            

            <para>
                Im unten angeführten Beispiel, werden die Zeilen in der <command>Bugs</command>
                Tabelle automatisch gelöscht wenn eine Zeile in der <command>Products</command>
                Tabelle zu der Sie referenzieren gelöscht wird. Das <command>'onDelete'</command>
                Element des Referenzplan Eintrages wird auf <constant>self::CASCADE</constant>
                gesetzt.
            </para>

            <para>
                Es wird in diesem Beispiel keine kaskadierende Aktualisierung durchgeführt wenn der
                primäre Schlüsselwert in der Elternklasse verändert wird. Das
                <command>'onUpdate'</command> Element des Referenzplan Eintrages ist
                <constant>self::RESTRICT</constant>. Das gleiche Ergebnis erhält man durch
                Unterdrückung des <command>'onUpdate'</command> Eintrages.
            </para>

            <programlisting language="php"><![CDATA[
class BugsProducts extends Zend_Db_Table_Abstract
{
    ...
    protected $_referenceMap = array(
        'Product' => array(
            'columns'           => array('product_id'),
            'refTableClass'     => 'Products',
            'refColumns'        => array('product_id'),
            'onDelete'          => self::CASCADE,
            'onUpdate'          => self::RESTRICT
        ),
        ...
    );
}
]]></programlisting>
        </example>

        <section xml:id="zend.db.table.relationships.cascading.notes"><info><title>Notizen betreffend kaskadierenden Operationen</title></info>
            

            <para>
                <emphasis>Kaskadierende Operationen die durch <classname>Zend_Db_Table</classname>
                aufgerufen werden sind nicht atomar.</emphasis>
            </para>

            <para>
                Das bedeutet, das wenn die eigene Datenbank referentielle integrative Verknüpfungen
                implementiert und erzwingt, ein kaskadierends <constant>UPDATE</constant> das durch
                eine <classname>Zend_Db_Table</classname> Klasse ausgeführt wird mit der Verknüpfung
                kollidiert, und in einem referentiellen integrativen Verstoß mündet. Ein
                kaskadierendes <constant>UPDATE</constant> kann in
                <classname>Zend_Db_Table</classname> <emphasis>nur</emphasis> dann verwendet werden
                wenn die eigene Datenbank die referentielle integrative Verknüpfung nicht erzwingt.
            </para>

            <para>
                Ein kaskadierendes <constant>DELETE</constant> erleidet weniger durch das Problem
                des referentiellen integrativen Verstoßes. Abhängige Zeilen können genauso gelöscht
                werden wie durch eine nicht-atomare Aktion bevor die Elternzeile welche diese
                referenziert gelöscht wird.
            </para>

            <para>
                Trotzdem, für beide <constant>UPDATE</constant> und <constant>DELETE</constant>,
                erzeugt die Änderung der Datenbank in einem nicht-atomaren Weg auch das Risiko das
                ein anderer Datenbankbenutzer die Daten in einem inkonsistenten Status sieht. Wenn,
                zum Beispiel, eine Zeile und alle Ihre abhängigen Zeilen, gelöscht werden, gibt es
                eine kleine Chance das ein anderes Datenbank Clientprogramm die Datenbank abfragen
                kann nachdem die abhängigen Zeilen gelöscht wurden, aber bevor die Elternzeilen
                gelöscht wurden. Dieses Clientprogramm kann die Elternzeilen ohne abhängige Zeilen
                sehen, und diese als gewünschten Status der Daten annehmen. Es gibt keinen Weg für
                diesen Clienten herauszufinden das die Abfrage der Datenbank mitten wärend einer
                Änderung gelesen wurde.
            </para>

            <para>
                Der Fall von nicht-atomaren Änderungen kann durch die Verwendung von Transaktionen
                entschärft werden indem die Änderungen isoliert werden. Aber einige
                <acronym>RDBMS</acronym> Marken unterstützen keine Transaktionen, oder erlauben dem
                Clienten "schmutzige" Änderungen zu lesen die noch nicht fertiggestellt wurden.
            </para>

            <para>
                <emphasis>Kaskadierende Operationen in <classname>Zend_Db_Table</classname> werden
                nur durch <classname>Zend_Db_Table</classname> aufgerufen.</emphasis>
            </para>

            <para>
                Kaskadierendes Löschen und Aktualisieren welches in den eigenen
                <classname>Zend_Db_Table</classname> Klassen definiert wurde werden ausgeführt wenn
                die <methodname>save()</methodname> oder <methodname>delete()</methodname> Methoden
                der Zeilenklasse ausgeführt werden. Trotzdem, wenn ein Update oder Löschen von
                Daten durch Verwendung eines anderen Interfaces durchgeführt wird, wie durch ein
                Abfragetool oder eine andere Anwendung, werden die kaskadierenden Operationen nicht
                ausgeführt. Selbst wenn die <methodname>update()</methodname> und
                <methodname>delete()</methodname> Methoden in der
                <classname>Zend_Db_Adapter</classname> Klasse verwendet werden, werden die
                kaskadierenden Operationen die in der eigenen <classname>Zend_Db_Table</classname>
                Klasse definiert wurden, nicht ausgeführt.
            </para>

            <para>
                <emphasis>Kein kaskadierendes <constant>INSERT</constant>.</emphasis>
            </para>

            <para>
                Es gibt keine Unterstützung für ein kaskadierendes <constant>INSERT</constant>. Man
                muß eine Zeile in eine Elterntabelle in einer Operation hinzufügen, und Zeilen zu
                einer abhängigen Tabelle in einer unabhängigen Operation hinzufügen.
            </para>
        </section>
    </section>
</section>
