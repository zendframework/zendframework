<?xml version="1.0" encoding="utf-8"?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="zend.filter.input"><info><title>Zend_Filter_Input</title></info>
    

    <para>
        <classname>Zend_Filter_Input</classname> bietet ein ausgezeichnetes Interface um mehrere
        Filter und Prüfer zu assoziieren, Sie Kollektionen von Daten hinzuzufügen, und Eingabewerte
        zu empfangen nachdem diese durch die Filter und Prüfer bearbeitet wurden. Werte werden
        standardmäßig in kommentiertem Format zurückgegeben für sichere <acronym>HTML</acronym>
        Ausgabe.
    </para>

    <para>
        Angenommen das diese Klasse ein Käfig für externe Daten ist. Daten betreten die Anwendung
        von externen Quellen, wie <acronym>HTTP</acronym> Anfrageparameter, <acronym>HTTP</acronym>
        Header, ein Web Service, oder sogar durch Lesen von eine Datenbank oder anderen Dateien.
        Daten werden zuerst in den Käfig gesperrt, und die Anwendung kann diese Daten nur dann Stück
        für Stück empfangen wenn dem Käfig gesagt wird, was diese Daten sein sollten und wie geplant
        ist diese zu verwenden. Der Käfig inspiziert die Daten auf Gültigkeit. Es kann passieren das
        er die Datenwerte kommentiert für den entsprechenden Kontext. Der Käfig entlässt die Daten
        nur wen diese alle Notwendigkeiten komplett erfüllen. Mit einem einzigen und bequemen
        Interface, wird gutes Programmierverhalten ermöglicht und es lässt Entwickler darüber
        nachdenken wie die Daten verwendet werden.
    </para>

    <itemizedlist>
        <listitem>
            <para>
                <emphasis>Filter</emphasis> wandeln Eingabewerte um, inden Sie Zeichen in dem Wert
                entfernen oder Ändern. Das Ziel ist es Eingabewerte zu "normalisieren" bis diese
                einem erwarteten Format entsprechen. Zum Beispiel, wenn ein String von nummerischen
                Zeichen benötigt wird, und der Eingabewert "abc123" ist dann könnte eine erwartete
                Umwandlung die Änderung des Wertes in den String "123" sein.
            </para>
        </listitem>

        <listitem>
            <para>
                <emphasis>Prüfer</emphasis> prüfen Eingabewerte gegenüber Kriterien und melden ob
                diese den Test bestanden haben oder nicht. Der Wert wird nicht geändert, aber die
                Prüfung kann fehlschlagen. Zum Beispiel, wenn ein String wie eine Email Adresse
                aussehen muß, und der Eingabewert "abc123" ist, dann wird der Wert als nicht gültig
                angenommen.
            </para>
        </listitem>

        <listitem>
            <para>
                <emphasis>Auskommentierer</emphasis> wandeln einen Wert um indem Sie magisches
                Verhalten von bestimmten Zeichen entfernen. In einigen Ausgabekontexten haben
                speziellen Zeichen eine Bedeutung. Zum Beispiel das Zeichen '&lt;' und '&gt;'
                begrenzen <acronym>HTML</acronym> Tags, und wenn ein String diese Zeichen enthält
                und in einem <acronym>HTML</acronym> Kontext ausgegeben wird, könnte der Inhalt
                zwischen Ihnen die Ausgabe oder Funktionalität der <acronym>HTML</acronym>
                Präsentation beeinflussen. Das auskommentieren der Zeichen entfernt die spezielle
                Bedeutung, damit Sie als literale Zeichen ausgegeben werden.
            </para>
        </listitem>
    </itemizedlist>

    <para>
        Um <classname>Zend_Filter_Input</classname> zu verwenden, müssen die folgenden Schritte
        unternommen werden:
    </para>

    <orderedlist numeration="arabic">
        <listitem><para>Filter und Prüfregeln deklarieren</para></listitem>
        <listitem><para>Filter und Prüfbearbeiter erstellen</para></listitem>
        <listitem><para>Eingabedaten bereitstellen</para></listitem>
        <listitem><para>Geprüfte Felder und andere Reports erhalten</para></listitem>
    </orderedlist>

    <para>
        Die folgenden Sektionen beschreiben die Schritte für die Verwendung dieser Klasse.
    </para>

    <section xml:id="zend.filter.input.declaring"><info><title>Filter und Prüfregeln deklarieren</title></info>
        

        <para>
            Vor der Erstellung einer Instanz von <classname>Zend_Filter_Input</classname>, muß ein
            Array von Filterregeln deklariert werden und auch ein Array von Prüfregeln. Dieses
            assoziative Array verbindet einen Regelnamen mit einem Filter oder Prüfer oder einer
            Kette von Filtern oder Prüfern.
        </para>

        <para>
            Das folgende Beispiel eines Sets von Filterregeln deklariert, daß das Feld 'month' von
            <classname>Zend_Filter_Digits</classname> gefiltert wird, und das Feld 'account' von
            <classname>Zend_Filter_StringTrim</classname> gefiltert wird. Anschließend wird ein Set
            von Prüfregeln deklariert welches prüft dass das Feld 'account' nur dann gültig ist wenn
            es nur alphabetische Zeichen enthält.
        </para>

        <programlisting language="php"><![CDATA[
$filters = array(
    'month'   => 'Digits',
    'account' => 'StringTrim'
);

$validators = array(
    'account' => 'Alpha'
);
]]></programlisting>

        <para>
            Jeder Schlüssel im obigen <varname>$filters</varname> Array ist der Name einer Regel die
            auf einen Filter für ein spezielles Datenfeld angewendet wird. Standardmäßig, ist der
            Name der Regel auch der Name des Feldes der Eingabedaten auf welche die Regel angewendet
            werden soll.
        </para>

        <para>
            Eine Regel kann in verschiedenen Formaten deklariert werden:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    Ein einfacher skalarer String, der einem Klassennamen entspricht:
                </para>

                <programlisting language="php"><![CDATA[
$validators = array(
    'month'   => 'Digits',
);
]]></programlisting>
            </listitem>

            <listitem>
                <para>
                    Die Instanz eines Objektes einer der Klassen die
                    <classname>Zend_Filter_Interface</classname> oder
                    <classname>Zend_Validate_Interface</classname> implementieren.
                </para>

                <programlisting language="php"><![CDATA[
$digits = new Zend_Validate_Digits();

$validators = array(
    'month'   => $digits
);
]]></programlisting>
            </listitem>

            <listitem>
                <para>
                    Ein Array um eine Kette von Filtern oder Prüfern zu deklarieren. Die Elemente
                    dieses Arrays können Strings sein die Klassennamen entsprechen oder
                    Filter/Prüfobjekte, wie in den oben beschriebenen Fällen. Zusätzlich kann eine
                    dritte Wahl verwendet werden: Ein Array das einen String enthält der dem
                    Klassennamen entspricht gefolgt von Argumenten die dessen Konstruktor übergeben
                    werden.
                </para>

                <programlisting language="php"><![CDATA[
$validators = array(
    'month'   => array(
        'Digits',                // String
        new Zend_Validate_Int(), // Objekt Instanz
        array('Between', 1, 12)  // String mit Konstruktor Argumenten
    )
);
]]></programlisting>
            </listitem>
        </itemizedlist>

        <note>
            <para>
                Wenn ein Filter oder Prüfer mit Konstruktor Argumenten in einem Array deklariert
                wird, muß ein Array für die Regel erstellt werden, selbst wenn die Regel nur einen
                Filter oder Prüfer enthält.
            </para>
        </note>

        <para>
            Es kann ein spezieller "Wildcard" Regelschlüssel <emphasis>'*'</emphasis>, entweder im
            Array des Filters oder im Array des Prüfers, verwendet werden. Das bedeutet das der
            Filter oder Prüfer der in dieser Regel deklariert wird allen Feldern der Eingabedaten
            zugewiesen wird. Es gilt zu beachten das die Reihenfolge der Einträge im Array des
            Filters oder im Array des Prüfers bedeutend ist; die Regeln werden in der gleichen
            Reihenfolge zugewiesen in dem diese deklariert wurden.
        </para>

        <programlisting language="php"><![CDATA[
$filters = array(
    '*'     => 'StringTrim',
    'month' => 'Digits'
);
]]></programlisting>
    </section>

    <section xml:id="zend.filter.input.running"><info><title>Filter und Prüfbearbeiter erstellen</title></info>
        

        <para>
            Nachdem die Filter und Prüfarrays deklariert wurden, können diese als Argumente im
            Konstruktor von <classname>Zend_Filter_Input</classname> verwendet werden. Das gibt ein
            Objekt zurück welches alle Filter- und Prüfregeln kennt, und das verwendet werden kann
            um ein oder mehrere Sets von Eingabedaten zu bearbeiten.
        </para>

        <programlisting language="php"><![CDATA[
$input = new Zend_Filter_Input($filters, $validators);
]]></programlisting>

        <para>
            Man kann Eingabedaten als drittes Argument im Konstruktor spezifizieren. Die
            Datenstruktur ist ein assoziatives Array. Die superglobalen Standardvariablen in
            <acronym>PHP</acronym>, <varname>$_GET</varname> und <varname>$_POST</varname>, sind
            Beispiele für dieses Format. Man kann jede dieser Variablen als Eingabedaten für
            <classname>Zend_Filter_Input</classname> verwenden.
        </para>

        <programlisting language="php"><![CDATA[
$data = $_GET;

$input = new Zend_Filter_Input($filters, $validators, $data);
]]></programlisting>

        <para>
            Alternativ kann die <methodname>setData()</methodname> Methode verwendet werden, indem
            ein assoziatives Array von Schlüssel/Werte Paaren, im selben Format wie oben
            beschrieben, übergeben wird.
        </para>

        <programlisting language="php"><![CDATA[
$input = new Zend_Filter_Input($filters, $validators);
$input->setData($newData);
]]></programlisting>

        <para>
            Die <methodname>setData()</methodname> Methode definiert Daten nocheinmal, in einem
            existierenden <classname>Zend_Filter_Input</classname> Objekt ohne die Filter- und
            Prüfregeln zu verändern. Wenn diese Methode verwendet wird können die selben Regeln, an
            anderen Sets von Eingabedaten, wieder verwendet werden.
        </para>
    </section>

    <section xml:id="zend.filter.input.results"><info><title>Geprüfte Felder und andere Reporte empfangen</title></info>
        

        <para>
            Nachdem Filter und Prüfer deklariert wurden und der Eingabeprozessor erstellt wurde,
            können Reporte von fehlenden, unbekannten und ungültigen Feldern empfangen werden. Man
            kann auch die Werte der Felder erhalten, nachdem die Filter angewendet wurden.
        </para>

        <section xml:id="zend.filter.input.results.isvalid"><info><title>Abfragen ob die Eingabe gültig ist</title></info>
            

            <para>
                Wenn alle Eingabedaten die Prüfregeln bestanden haben, gibt die
                <methodname>isValid()</methodname> Methode <constant>TRUE</constant> zurück. Wenn
                irgendein Feld ungültig ist oder ein benötigtes Feld fehlt, gibt die
                <methodname>isValid()</methodname> Methode <constant>FALSE</constant> zurück.
            </para>

            <programlisting language="php"><![CDATA[
if ($input->isValid()) {
  echo "OK\n";
}
]]></programlisting>

            <para>
                Diese Methode akzeptiert ein optionales String Argument, das ein individuelles Feld
                benennt. Wenn das spezifizierte Feld die Prüfung passiert und bereit ist um abgeholt
                zu werden, gibt <methodname>isValid('fieldName')</methodname> den Wert
                <constant>TRUE</constant> zurück.
            </para>

            <programlisting language="php"><![CDATA[
if ($input->isValid('month')) {
  echo "Feld 'month' ist OK\n";
}
]]></programlisting>
        </section>

        <section xml:id="zend.filter.input.results.reports"><info><title>Ungültige, fehlende oder unbekannte Felder erhalten</title></info>
            

            <itemizedlist>
                <listitem>
                    <para>
                        <emphasis>Ungültige</emphasis> Felder sind jene, die einen oder mehrere
                        Ihrer Prüfungen nicht bestehen.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <emphasis>Fehlende</emphasis> Felder sind jene die nicht in den
                        Eingabedaten vorhanden sind, aber im Metakommando
                        <command>'presence'=&gt;'required'</command> (Siehe die <link linkend="zend.filter.input.metacommands.presence">spätere Sektion</link>
                        über Metakommandos) deklariert wurden.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <emphasis>Unbekannte</emphasis> Felder sind jene die in keiner einzigen
                        Regel, im Array der Prüfer, deklariert wurden, aber in den Eingabedaten
                        vorkommen.
                    </para>
                </listitem>
            </itemizedlist>

            <programlisting language="php"><![CDATA[
if ($input->hasInvalid() || $input->hasMissing()) {
  $messages = $input->getMessages();
}

// getMessages() gibt einfach die Zusammenfassung von getInvalid()
// und getMissing() zurück

if ($input->hasInvalid()) {
  $invalidFields = $input->getInvalid();
}

if ($input->hasMissing()) {
  $missingFields = $input->getMissing();
}

if ($input->hasUnknown()) {
  $unknownFields = $input->getUnknown();
}
]]></programlisting>

            <para>
                Das Ergebnis der <methodname>getMessages()</methodname> Methode ist ein
                assoziatives Array, das die Regelnamen einem Array von Fehlermeldungen, relativ zu
                diesen Regeln, zuordnet. Es ist anzumerken das der Index dieses Arrays der Name der
                Regel ist die in der Regeldeklaration verwendet wird, und welche von den Namen der
                Felder, die von der Regel geprüft werden, unterschiedlich sein kann.
            </para>

            <para>
                Die <methodname>getMessages()</methodname> Methode gibt eine Zusammenfassung der
                Arrays zurück die von <methodname>getInvalid()</methodname> und
                <methodname>getMissing()</methodname> retourniert werden. Diese Methoden geben
                Subsets der Nachrichten zurück, relativ zu den Prüffehlern, oder Felder die als
                benötigt deklariert wurden aber in der Eingabe fehlen.
            </para>

            <para>
                Die <methodname>getErrors()</methodname> Methode gibt ein assoziatives Array
                zurück, in dem die Regelnamen einem Array von Fehler Identifizierern entsprechen.
                Fehler Identifizierer sind fixe Strings, um Gründe für eine fehlgeschlagene
                Prüfung, zu identifizieren, wobei Nachrichten selbst geändert werden können. Siehe
                <link linkend="zend.validate.introduction.using">dieses Kapitel</link> für mehr
                Informationen.
            </para>

            <para>
                Die Nachricht die von <methodname>getMissing()</methodname> zurückgegeben wird kann
                als Argument beim <classname>Zend_Filter_Input</classname> Konstruktor, oder durch
                verwenden der <methodname>setOptions()</methodname> Methode, spezifiziert werden.
            </para>

            <programlisting language="php"><![CDATA[
$options = array(
    'missingMessage' => "Feld '%field%' wird benötigt"
);

$input = new Zend_Filter_Input($filters, $validators, $data, $options);

// alternative Methode:

$input = new Zend_Filter_Input($filters, $validators, $data);
$input->setOptions($options);
]]></programlisting>

            <para>
                Und man kann auch einen Übersetzer hinzufügen der einem die Möglichkeit bietet
                mehrere Sprachen für die Meldungen anzubieten welche von
                <classname>Zend_Filter_Input</classname> zurückgegeben werden.
            </para>

            <programlisting language="php"><![CDATA[
$translate = new Zend_Translator_Adapter_Array(array(
    'content' => array(
        Zend_Filter_Input::MISSING_MESSAGE => "Wo ist das Feld?"
    )
);

$input = new Zend_Filter_Input($filters, $validators, $data);
$input->setTranslator($translate);
]]></programlisting>

            <para>
                Wenn man einen anwendungsweiten Übersetzer verwendet, dann wird dieser von
                <classname>Zend_Filter_Input</classname> verwendet. In diesem Fall muss man den
                Übersetzer nicht manuell setzen.
            </para>

            <para>
                Das Ergebnis der <methodname>getUnknown()</methodname> Methode ist ein assoziatives
                Array, in dem die Feldnamen den Feldwerten zugeordnet werden. Feldnamen werden in
                diesem Fall als Arrayschlüssel verwendet, statt als Regelnamen, weil keine Regel
                die Feld erwähnt die unbekannte Felder sind.
            </para>
        </section>

        <section xml:id="zend.filter.input.results.escaping"><info><title>Gültige Felder bekommen</title></info>
            

            <para>
                Alle Felder die entweder ungültig, fehlend oder unbekannt sind, werden als gültig
                angenommen. Man kann Werte für diese Felder erhalten indem ein magischer Accessor
                verwendet wird. Es gibt auch die nicht-magische Accessor Methoden
                <methodname>getEscaped()</methodname> und <methodname>getUnescaped()</methodname>.
            </para>

            <programlisting language="php"><![CDATA[
$m = $input->month;                 // Ausgabe vom magischen Accessor kommentieren
$m = $input->getEscaped('month');   // Ausgabe kommentieren
$m = $input->getUnescaped('month'); // nicht kommentieren
]]></programlisting>

            <para>
                Standardmäßig, wenn ein Wert empfangen wird, wird er mit
                <classname>Zend_Filter_HtmlEntities</classname> gefiltert. Das ist der Standard weil
                angenommen wird, das die am meisten übliche Verwendung, die Ausgabe von Werten von
                einem Feld in <acronym>HTML</acronym> ist. Der HtmlEntities Filter hilft ungewollten
                Ausgaben von Code vorzubeugen, welche zu Sicherheitsproblemen führen könnten.
            </para>

            <note>
                <para>
                    Wie oben gezeigt, kann man unkommentierte Werte erhalten undem die
                    <methodname>getUnescaped()</methodname> Methode verwendet wird, aber man muß
                    dafür Code schreiben um die Werte sicher zu verwenden, und
                    Sicherheitsprobleme, wie Verletzbarkeit für Seitenübergreifende Skript Attacken
                    zu vermeiden.
                </para>
            </note>

            <warning><info><title>Ungeprüfte Felder escapen</title></info>
                

                <para>
                    Wie vorher erwähnt gibt <methodname>getEscaped()</methodname> nur geprüfte
                    Felder zurück. Felder die keine zugeordnete Prüfung haben können auf diesem Weg
                    nicht empfangen werden. Trotzdem gibt es einen möglichen Weg. Man kann eine
                    leere Prüfung für alle Felder hinzufügen.
                </para>

                <programlisting language="php"><![CDATA[
$validators = array('*' => array());

$input = new Zend_Filter_Input($filters, $validators, $data, $options);
]]></programlisting>

                <para>
                    Aber es sei gewarnt das die Verwendung dieser Schreibweise eine Sicherheitslücke
                    eröffnet welche für Cross-Site Scripting Attacken verwendet werden könnte.
                    Deswegen sollte man immer individuelle Prüfungen für jedes Feld setzen.
                </para>
            </warning>

            <para>
                Es kann ein anderer Filter für das auskommentieren von Werten definiert werden,
                durch seine Spezifikation im Array der Optionen des Konstruktors:
            </para>

            <programlisting language="php"><![CDATA[
$options = array('escapeFilter' => 'StringTrim');
$input = new Zend_Filter_Input($filters, $validators, $data, $options);
]]></programlisting>

            <para>
                Alternativ kann die <methodname>setDefaultEscapeFilter()</methodname> Methode
                verwendet werden:
            </para>

            <programlisting language="php"><![CDATA[
$input = new Zend_Filter_Input($filters, $validators, $data);
$input->setDefaultEscapeFilter(new Zend_Filter_StringTrim());
]]></programlisting>

            <para>
                Bei jeder Verwendung, kann der Kommentarfilter als String Basisname der
                Filterklasse, oder als Objektinstanz einer Filterklasse, spezifiziert werden. Der
                Kommentarfilter kann eine Instanz einer Filterkette, oder ein Objekt der
                <classname>Zend_Filter</classname> Klasse sein.
            </para>

            <para>
                Filter die Ausgaben kommentieren sollen auf diesen Weg ausgeführt werden, um
                sicherzustellen das Sie nach der Prüfung ausgeführt werden. Andere Filter, die im
                Array der Filterregeln deklariert werden, werden bei den Eingabedaten angewendet
                bevor diese Daten geprüft werden. Wenn Kommentarfilter vor der Prüfung ausgeführt
                werden, würde der Prozess der Prüfung viel komplexer sein um sowohl kommentierte
                als auch unkommentierte Versionen der Daten anzubieten. Deswegen wird empfohlen,
                Filter die Ausgaben mit <methodname>setDefaultEscapeFilter()</methodname>
                kommentieren, nicht im <varname>$filters</varname> Array zu deklarieren.
            </para>

            <para>
                Es gibt nur eine <methodname>getEscaped()</methodname> Methode, und deswegen kann
                nur ein Filter für das kommentieren spezifiziert werden (trotzdem kann dieser
                Filter eine Filterkette sein). Wenn eine einzelne Instanz von
                <classname>Zend_Filter_Input</classname> benötigt wird, um kommentierte Ausgaben zu
                erhalten, und mehr als eine Filtermethode angewendet werden soll, sollte
                <classname>Zend_Filter_Input</classname> erweitert werden und neue Methoden in der
                Subklasse implementiert werden um Wert auf unterschiedlichen Wegen zu erhalten.
            </para>
        </section>
    </section>

    <section xml:id="zend.filter.input.metacommands"><info><title>Metakommandos verwenden um Filter oder Prüfregeln zu kontrollieren</title></info>
        

        <para>
            Zusätzlich zum deklarieren der Übereinstimmungen von Feldern zu Filtern oder Prüfer,
            können einige "Metakommandos" in der Array Deklaration spezifiziert werden um einige
            optionale Verhaltensweisen von <classname>Zend_Filter_Input</classname> zu
            kontrollieren. Metakommandos treten als String-indizierte Einträge in einem gegebenen
            Filter- oder Prüfarray Wert auf.
        </para>

        <section xml:id="zend.filter.input.metacommands.fields"><info><title>Das FIELDS Metakommando</title></info>
            

            <para>
                Wenn der Name der Regel für einen Filter oder Prüfer anders lautet als das Feld in
                welchem er angewendet werden soll, kann der Feldname mit dem 'fields' Metakommando
                spezifiziert werden.
            </para>

            <para>
                Dieses Metakommando kann durch Verwendung der Klassenkonstanten
                <constant>Zend_Filter_Input::FIELDS</constant> statt der Angabe eines Strings
                spezifiziert werden.
            </para>

            <programlisting language="php"><![CDATA[
$filters = array(
    'month' => array(
        'Digits',        // Namen als Integer Index [0] filtern
        'fields' => 'mo' // Namen als String Index ['fields'] filtern
    )
);
]]></programlisting>

            <para>
                Im obigen Beispiel wendet die Filterregel den 'digits' Filter am Eingabefeld, das
                'mo' heißt, an. Der String 'month' wird einfach ein mnemonischer Schlüsselfür diese
                Filterregel; er wird nicht als Filtername verwendet wenn der Filter mit dem 'fields'
                Metakommando spezifiziert wird, aber er wird als Regelname verwendet.
            </para>

            <para>
                Der Standardwert des 'fields' Metakommandos ist der Index der aktuellen Regel. Im
                obigen Beispiel wird die Regel, wenn das 'fields' Metakommando nicht spezifiziert
                wird, auf das Eingabefeld das 'month' heißt, angewendet.
            </para>

            <para>
                Eine weitere Verwendung des 'fields' Metakommandos ist es Felder für Filter oder
                Prüfer zu spezifizieren die mehrere Felder als Eingabe benötigen. Wenn das 'fields'
                Metakommando ein Array ist, ist das Argument des korrespondierenden Filters oder
                Prüfers ein Array mit den Werten dieser Felder. Zum Beispiel ist es für Benutzer
                üblich einen Passwort String in zwei Feldern zu spezifizieren, und diese müssen den
                selben String in beide Felder eingeben. Man kann zum Beispiel eine Prüfklasse
                implmentieren die ein Array Argument annimmt, und <constant>TRUE</constant>
                zurückgibt wenn alle Werte im Array identisch zum jeweils anderen sind.
            </para>

            <programlisting language="php"><![CDATA[
$validators = array(
    'password' => array(
        'StringEquals',
        'fields' => array('password1', 'password2')
    )
);
//  Inkludiert die hypotetische Klasse Zend_Validate_StringEquals,
// übergibt dieser ein Array Argument das den Wert der beiden Eingabe
// Datenfelder enthält die 'password1' und 'password2' heißen.
]]></programlisting>

            <para>
                Wenn die Prüfung dieser Regel fehlschlägt wird der Schlüssel der Regel
                ('password') im Rückgabewert von <methodname>getInvalid()</methodname>
                verwendet und nicht eine der benannten Felder im 'fields' Metakommando.
            </para>
        </section>

        <section xml:id="zend.filter.input.metacommands.presence"><info><title>Das PRESENCE Metakommando</title></info>
            

            <para>
                Jeder Eintrag im Prüfarray kann ein Metakommando haben das 'presence' heißt. Wenn
                der Wert dieses Metakommandos 'required' ist muß dieses Feld in den Eingabedaten
                existieren, andernfalls wird es als fehlendes Feld gemeldet.
            </para>

            <para>
                Das Metakommando kann auch spezifiziert werden indem die Klassenkonstante
                <constant>Zend_Filter_Input::PRESENCE</constant> statt dem String verwendet wird.
            </para>

            <programlisting language="php"><![CDATA[
$validators = array(
    'month' => array(
        'digits',
        'presence' => 'required'
    )
);
]]></programlisting>

            <para>
                Der Standardwert dieses Metakommandos ist 'optional'.
            </para>
        </section>

        <section xml:id="zend.filter.input.metacommands.default"><info><title>Das DEFAULT_VALUE Metakommando</title></info>
            

            <para>
                Wenn ein Feld, für das ein Wert mit dem 'default' Metakommando für diese Regel, in
                den Eigabedaten vorhanden ist, nimmt das Feld den Wert dieses Metakommandos.
            </para>

            <para>
                Dieses Metakommando kann auch spezifiziert werden indem die Klassenkonstante
                <constant>Zend_Filter_Input::DEFAULT_VALUE</constant> statt einem String verwendet
                wird.
            </para>

            <para>
                Der Standardwert wird dem Feld zugeordnet bevor irgendeiner der Prüfungen
                stattfindet. Der Standardwert wird dem Feld nur für die aktuelle Regel zugeordnet;
                wenn das selbe Weld in einer folgenden Regel referenziert wird, hat dieses Feld
                keinen Wert wenn diese Regel evaluiert wird. Deshalb können verschiedene Regeln auch
                verschiedene Standardwerte für ein gegebenes Feld deklarieren.
            </para>

            <programlisting language="php"><![CDATA[
$validators = array(
    'month' => array(
        'digits',
        'default' => '1'
    )
);

// kein Wert für das 'month' Feld
$data = array();

$input = new Zend_Filter_Input(null, $validators, $data);
echo $input->month; // gibt 1 aus
]]></programlisting>

            <para>
                Wenn eine Regel das <constant>FIELDS</constant> Metakommando verwendet um ein Array
                mit mehrfachen Feldern zu definieren, kann ein Array für das
                <constant>DEFAULT_VALUE</constant> Metakommando definiert werden und der Standard
                der korrespondierenden Schlüssel wird für alle fehlenden Felder verwendet. Wenn
                <constant>FIELDS</constant> mehrfache Felder definiert aber
                <constant>DEFAULT_VALUE</constant> nur ein skalarer Wert ist, dann wird dieser
                Standardwert als Wert für alle fehlenden Feldern im Array verwendet.
            </para>

            <para>
                Es gibt keinen Standardwert für dieses Metakommando.
            </para>
        </section>

        <section xml:id="zend.filter.input.metacommands.allow-empty"><info><title>Das ALLOW_EMPTY Metakommando</title></info>
            

            <para>
                Standardmäßig, wenn ein Feld in den Eingabedaten existiert, wird Ihm der Prüfer
                zugeordnet selbst wenn der Wert des Feldes ein leerer String ist
                (<emphasis>''</emphasis>). Das kann zu einem Fehler in der Prüfung führen. Zum
                Beispiel, wenn ein Prüfer auf Ziffern prüft und es keine gibt weil ein leerer String
                keine Zeichen hat, weil der Prüfer dann die Daten als fehlerhaft meldet.
            </para>

            <para>
                Wenn, in eigenen Fällen, ein leerer String als gültig angenommen werden soll, kann
                das Metakommando 'allowEmpty' auf <constant>TRUE</constant> gesetzt werden. Dann
                passieren die Eingabedaten die Prüfung wenn sie in den Eingabedaten vorhanden sind,
                aber der Wert ein leerer String ist.
            </para>

            <para>
                Dieses Metakommando kann spezifiziert werden indem die Klassenkonstante
                <constant>Zend_Filter_Input::ALLOW_EMPTY</constant> statt einem String verwendet
                wird.
            </para>

            <programlisting language="php"><![CDATA[
$validators = array(
    'address2' => array(
        'Alnum',
        'allowEmpty' => true
    )
);
]]></programlisting>

            <para>
                Der Standardwert dieses Metakommandos ist <constant>FALSE</constant>.
            </para>

            <para>
                Im unüblichen Fall das eine Prüfregel mit keinem Prüfer definiert wird, aber das
                'allowEmpty' Metakommando <constant>FALSE</constant> ist (was bedeutet, dass das
                Feld als ungültig angenommen wird wenn es leer ist), gibt
                <classname>Zend_Filter_Input</classname> eine Standard Fehlermeldung zurück die mit
                <methodname>getMessages()</methodname> empfangen werden kann. Diese Meldung kann
                spezifiziert werden indem die 'notEmptyMessage' als Argument für den
                <classname>Zend_Filter_Input</classname> Constructor verwendet wird oder indem die
                <methodname>setOptions()</methodname> Methode verwendet wird.
            </para>

            <programlisting language="php"><![CDATA[
$options = array(
    'notEmptyMessage' => "Ein nicht-leerer Wert wird für das Feld '%field%' benötigt"
);

$input = new Zend_Filter_Input($filters, $validators, $data, $options);

// alternative Methode:

$input = new Zend_Filter_Input($filters, $validators, $data);
$input->setOptions($options);
]]></programlisting>
        </section>

        <section xml:id="zend.filter.input.metacommands.break-chain"><info><title>Das BREAK_CHAIN Metakommando</title></info>
            

            <para>
                Standardmäßig, wenn eine Regel mehr als einen Prüfer hat werden alle Prüfer auf die
                Eingabe angewendet, und die resultierende Nachricht enthält alle Fehlermeldungen die
                durch die Eingabe verursacht wurden.
            </para>

            <para>
                Alternativ, wenn der Wert des 'breakChainOnFailure' Metakommandos
                <constant>TRUE</constant> ist, terminiert die Prüfkette nachdem der erste Prüfer
                fehlschlägt. Die Eingabedaten werden nicht gegen nachfolgende Prüfer in der Kette
                geprüft. Sie können also weitere Fehlschläge verursachen selbst wenn der eine, der
                gemeldet wurde, korrigiert wird.
            </para>

            <para>
                Dieses Metakommando kann spezifiziert werden indem die Klassenkonstante
                <constant>Zend_Filter_Input::BREAK_CHAIN</constant> statt einem String verwendet
                wird.
            </para>

            <programlisting language="php"><![CDATA[
$validators = array(
    'month' => array(
        'Digits',
        new Zend_Validate_Between(1,12),
        new Zend_Validate_GreaterThan(0),
        'breakChainOnFailure' => true
    )
);
$input = new Zend_Filter_Input(null, $validators);
]]></programlisting>

            <para>
                Der Standardwert dieses Metakommandos ist <constant>FALSE</constant>.
            </para>

            <para>
                Die Klasse der Prüfketten, <classname>Zend_Validate</classname>, ist flexibler was
                das Durchbrechen von ausgeführten Ketten betrifft als
                <classname>Zend_Filter_Input</classname>. Mit der ersten Klasse, kann eine Option
                gesetzt werden um die Kette, für jeden Prüfer in der Kette, bei Fehlern unabhängig
                von jedem anderen Prüfer abzubrechen. Mit der anderen Klasse wird der definierte
                Wert des 'breakChainOnFailure' Metakommandos für eine Regel, einheitlich für alle
                Regeln in der Regel, angewendet. Wenn eine flexiblere Verwendung benötigt wird,
                sollte die Prüfkette selbst erstellt werden und diese als Objekt in der Definition
                der Prüfregel verwendet werden:
            </para>

            <programlisting language="php"><![CDATA[
// Prüfkette mit nicht einheitlichen breakChainOnFailure Attributen
// erstellen
$chain = new Zend_Validate();
$chain->addValidator(new Zend_Validate_Digits(), true);
$chain->addValidator(new Zend_Validate_Between(1,12), false);
$chain->addValidator(new Zend_Validate_GreaterThan(0), true);

// Prüfregeln deklarieren welche die oben definierte Kette verwenden
$validators = array(
    'month' => $chain
);
$input = new Zend_Filter_Input(null, $validators);
]]></programlisting>
        </section>

        <section xml:id="zend.filter.input.metacommands.messages"><info><title>Das MESSAGES Metakommando</title></info>
            

            <para>
                Man kann Fehlermeldungen für jeden Prüfer in einer Regel spezifizieren indem das
                'messages' Metakommando verwendet wird. Der Wert dieses Metakommandos variiert, je
                nachdem ob man mehrere Prüfer in der Regel hat, oder ob man die Nachricht für eine
                spezielles Fehlerereignis in einem angegebenen Prüfer setzen will.
            </para>

            <para>
                Dieses Metakommando kann spezifiziert werden indem die Klassenkonstante
                <constant>Zend_Filter_Input::MESSAGES</constant> statt einem String verwendet
                wird.
            </para>

            <para>
                Anbei ist ein einfaches Beispiel wie eine Standard fehlermeldung für einen einzelnen
                Prüfer gesetzt wird.
            </para>

            <programlisting language="php"><![CDATA[
$validators = array(
    'month' => array(
        'digits',
        'messages' => 'Ein Monat darf nur aus Ziffern bestehen'
    )
);
]]></programlisting>

            <para>
                Wenn mehrere Prüfer vorhanden sind für die eine Fehlermeldung gesetzt werden soll,
                sollte ein Array für dem Wert des 'messages' Metakommandos verwendet werden.
            </para>

            <para>
                Jedes Element dieses Array wird dem Prüfer an der gleichen Indexposition zugeordnet.
                Man kann eine Nachricht für die Prüfung an der Position <emphasis>n</emphasis>
                spezifizieren indem der Wert von <emphasis>n</emphasis> als Array Index verwendet
                wird. So kann einigen Prüfern erlaubt werden Ihre eigenen Standardnachrichten zu
                verwenden, wärend die Nachricht für einen nachfolgenden Prüfer in der Kette gesetzt
                wird.
            </para>

            <programlisting language="php"><![CDATA[
$validators = array(
    'month' => array(
        'digits',
        new Zend_Validate_Between(1, 12),
        'messages' => array(
            // Standardnachricht für Prüfer [0] verwenden
            // Neue Nachricht für Prüfer [1] setzen
            1 => 'Der Wert für Monat muß zwischen 1 und 12 sein'
        )
    )
);
]]></programlisting>

            <para>
                Wenn einer der Prüfer mehrere Fehlermeldungen besitzt, werden diese durch
                Nachrichten Schlüssel identifiziert. Es gibt verschiedene Schlüssel in jeder
                Prüfklasse, welche als Identifizierer für Fehlernachrichten fungieren, die die
                entsprechende Prüfklasse erstellen kann. Jede Prüfklasse definiert Konstanten für
                Ihre Nachrichtenschlüssel. Diese Schlüssel können im 'messages' Metakommando
                verwendet werden indem Sie als assoziatives Array übergeben werden statt als String.
            </para>

            <programlisting language="php"><![CDATA[
$validators = array(
    'month' => array(
        'digits', new Zend_Validate_Between(1, 12),
        'messages' => array(
            'Ein Monat darf nur aus Ziffern bestehen',
            array(
                Zend_Validate_Between::NOT_BETWEEN =>
                    'Der Wert %value% vom Monat sollte zwischen ' .
                    '%min% und %max% sein',
                Zend_Validate_Between::NOT_BETWEEN_STRICT =>
                    'Der Wert %value% vom Monat darf nur zwischen ' .
                    '%min% und %max% sein'
            )
        )
    )
);
]]></programlisting>

            <para>
                Es sollte für jede Prüfklasse in die Dokumentation gesehen werden, um zu wissen ob
                diese mehrere Fehlernachrichten hat, welche Schlüssel die Nachrichten haben und
                welche Token im Nachrichtentemplate verwendet werden können.
            </para>

            <para>
                Wenn man nur eine Prüfung in der Prüfregel hat, oder aller verwendeten Prüfungen
                die gleiche Nachricht gesetzt haben, dann kann auf Sie ohne zusätzliche Erstellung
                eines Arrays referiert werden:
            </para>

            <programlisting language="php"><![CDATA[
$validators = array(
    'month' => array(
        new Zend_Validate_Between(1, 12),
        'messages' => array(
                        Zend_Validate_Between::NOT_BETWEEN =>
                            'Month value %value% must be between ' .
                            '%min% and %max%',
                        Zend_Validate_Between::NOT_BETWEEN_STRICT =>
                            'Month value %value% must be strictly between ' .
                            '%min% and %max%'
        )
    )
);
]]></programlisting>
        </section>

        <section xml:id="zend.filter.input.metacommands.global"><info><title>Verwenden von Optionen um Metakommandos für alle Regeln zu setzen</title></info>
            

            <para>
                Der Standardwert für die 'allowEmpty', 'breakChainOnFailure', und 'presence'
                Metakommandos kann für alle Regeln gesetzt werden indem das
                <varname>$options</varname> Argument für den Konstruktor von
                <classname>Zend_Filter_Input</classname> verwendet wird. Das erlaubt das Setzen des
                Standardwertes für alle Regeln, ohne dass das Metakommando für jede Regel gesetzt
                werden muß.
            </para>

            <programlisting language="php"><![CDATA[
// Der Standard wird bei allen Feldern gesetzt und erlaubt einen leeren String.
$options = array('allowEmpty' => true);

// Diese Regeldefinition kann überschrieben werden, wenn ein Feld keinen leeren
// String akzeptieren soll
$validators = array(
    'month' => array(
        'Digits',
        'allowEmpty' => false
    )
);

$input = new Zend_Filter_Input($filters, $validators, $data, $options);
]]></programlisting>

            <para>
                Die 'fields', 'messages', und 'default' Metakommandos können nicht mit dieser
                Technik gesetzt werden.
            </para>
        </section>
    </section>

    <section xml:id="zend.filter.input.namespaces"><info><title>Namensräume für Filterklassen hinzufügen</title></info>
        

        <para>
            Standardmäßig, wenn ein Filter oder Prüfer als String deklariert wird, sucht
            <classname>Zend_Filter_Input</classname> nach der korrespondierenden Klasse unter dem
            <classname>Zend_Filter</classname> oder <classname>Zend_Validate</classname> Namensraum.
            Ein Filter der zum Beispiel nach dem String 'digits' benannt ist wird in der Klasse
            <classname>Zend_Filter_Digits</classname> gefunden.
        </para>

        <para>
            Wenn eigene Filter oder Prüfklassen geschrieben werden, oder Filter oder Prüfer von
            Drittanbietern verwendet werden, können diese Klassen in einem anderen Namensraum als
            <classname>Zend_Filter</classname> oder <classname>Zend_Validate</classname> existieren.
            <classname>Zend_Filter_Input</classname> kann mitgeteilt werden, das in zusätzlichen
            Namensräumen gesucht werden soll. Namensräume können in den Konstruktor Optionen
            spezifiziert werden:
        </para>

        <programlisting language="php"><![CDATA[
$options = array('filterNamespace' => 'My_Namespace_Filter',
                 'validatorNamespace' => 'My_Namespace_Validate');
$input = new Zend_Filter_Input($filters, $validators, $data, $options);
]]></programlisting>

        <para>
            Alternativ kann die <methodname>addValidatorPrefixPath($prefix, $path)</methodname>
            oder die <methodname>addFilterPrefixPath($prefix, $path)</methodname> Methoden
            verwendet werden, welche direkt auf den Plugin Lader verweisen der von
            <classname>Zend_Filter_Input</classname> verwendet wird:
        </para>

        <programlisting language="php"><![CDATA[
$input->addValidatorPrefixPath('Other_Namespace', 'Other/Namespace');
$input->addFilterPrefixPath('Foo_Namespace', 'Foo/Namespace');

// Die Suchrichtung für die Prüfungen ist jetzt:
// 1. My_Namespace_Validate
// 1. My_Namespace
// 3. Zend_Validate

// Die Suchrichtung für die Filter ist jetzt:
// 1. My_Namespace_Filter
// 2. Foo_Namespace
// 3. Zend_Filter
]]></programlisting>

        <para>
            <classname>Zend_Filter</classname> <classname>und Zend_Validate</classname> können als
            Namensraum nicht entfernt werden, es können nur Namensräume hinzugefügt werden.
            Benutzerdefinierte Namensräume werden zuerst durchsucht, Zend Namensräume werden zuletzt
            durchsucht.
        </para>

        <note>
            <para>
                Ab der Version 1.5 sollte die Funktion
                <methodname>addNamespace($namespace)</methodname> nicht mehr verwendet werden und
                wurde durch den Plugin Lader getauscht. Und
                <methodname>addFilterPrefixPath()</methodname> sowie
                <methodname>addValidatorPrefixPath()</methodname> wurden hinzugefügt. Auch die
                Konstante <constant>Zend_Filter_Input::INPUT_NAMESPACE</constant> sollte jetzt nicht
                mehr verwendet werden. Die Konstanten
                <constant>Zend_Filter_Input::VALIDATOR_NAMESPACE</constant> und
                <constant>Zend_Filter_Input::FILTER_NAMESPACE</constant> sind seit den Releases
                nach 1.7.0 vorhanden.
            </para>
        </note>

        <note>
            <para>
                Seit Version 1.0.4 wurde <constant>Zend_Filter_Input::NAMESPACE</constant>, der
                den Wert <property>namespace</property> hatte, auf
                <constant>Zend_Filter_Input::INPUT_NAMESPACE</constant>, mit dem Wert
                <property>inputNamespace</property> geändert, um der Reservierung des
                Schlüsselwortes <property>namespace</property> ab <acronym>PHP</acronym> 5.3 gerecht
                zu werden.
            </para>
        </note>
    </section>
</section>
