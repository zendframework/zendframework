<?xml version="1.0" encoding="UTF-8"?>
<!-- Reviewed: no -->
<sect1 id="zend.db.adapter">

    <title>Zend_Db_Adapter</title>

    <para>
        <classname>Zend_Db</classname> and its related classes provide a simple SQL database
        interface for Zend Framework. The <classname>Zend_Db_Adapter</classname> is the basic class
        you use to connect your PHP application to an RDBMS. There is a different Adapter
        class for each brand of RDBMS.
    </para>

    <para>
        The <classname>Zend_Db</classname> adapters create a bridge from the vendor-specific PHP
        extensions to a common interface to help you write PHP applications
        once and deploy with multiple brands of RDBMS with very little effort.
    </para>

    <para>
        The interface of the adapter class is similar to the interface of the
        <ulink url="http://www.php.net/pdo">PHP Data Objects</ulink> extension.
        <classname>Zend_Db</classname> provides Adapter classes to PDO drivers for the following
        RDBMS brands:
    </para>

    <itemizedlist>
        <listitem>
            <para>
                IBM DB2 and Informix Dynamic Server (IDS), using the
                <ulink url="http://www.php.net/pdo-ibm">pdo_ibm</ulink> PHP extension
            </para>
        </listitem>
        <listitem>
            <para>
                MySQL, using the <ulink url="http://www.php.net/pdo-mysql">pdo_mysql</ulink> PHP
                extension
            </para>
        </listitem>
        <listitem>
            <para>
                Microsoft SQL Server, using the <ulink
                url="http://www.php.net/pdo-mssql">pdo_mssql</ulink> PHP extension
            </para>
        </listitem>
        <listitem>
            <para>
                Oracle, using the <ulink url="http://www.php.net/pdo-oci">pdo_oci</ulink> PHP
                extension
            </para>
        </listitem>
        <listitem>
            <para>
                PostgreSQL, using the <ulink url="http://www.php.net/pdo-pgsql">pdo_pgsql</ulink>
                PHP extension
            </para>
        </listitem>
        <listitem>
            <para>
                SQLite, using the <ulink url="http://www.php.net/pdo-sqlite">pdo_sqlite</ulink> PHP
                extension
            </para>
        </listitem>

    </itemizedlist>

    <para>
        In addition, <classname>Zend_Db</classname> provides Adapter classes that utilize PHP
        database extensions for the following RDBMS brands:
    </para>

    <itemizedlist>
        <listitem>
            <para>
                MySQL, using the <ulink url="http://www.php.net/mysqli">mysqli</ulink> PHP extension
            </para>
        </listitem>
        <listitem>
            <para>
                Oracle, using the <ulink url="http://www.php.net/oci8">oci8</ulink> PHP extension
            </para>
        </listitem>
        <listitem>
            <para>
                IBM DB2 and DB2/i5, using the <ulink
                    url="http://www.php.net/ibm_db2">ibm_db2</ulink> PHP extension
            </para>
        </listitem>
        <listitem>
            <para>
                Firebird/Interbase, using the <ulink
                    url="http://www.php.net/ibase">php_interbase</ulink> PHP extension
            </para>
        </listitem>
    </itemizedlist>

    <note>
        <para>
            Each <classname>Zend_Db</classname> Adapter uses a PHP extension. You must have the
            respective PHP extension enabled in your PHP environment to use a
            <classname>Zend_Db</classname> Adapter. For example, if you use any of the PDO
            <classname>Zend_Db</classname> Adapters, you need to enable both the PDO extension and
            the PDO driver for the brand of RDBMS you use.
        </para>
    </note>

    <sect2 id="zend.db.adapter.connecting">

        <title>Connecting to a Database Using an Adapter</title>

        <para>
            This section describes how to create an instance of a database Adapter.
            This corresponds to making a connection to your RDBMS server from your
            PHP application.
        </para>

        <sect3 id="zend.db.adapter.connecting.constructor">

            <title>Using a Zend_Db Adapter Constructor</title>

            <para>
                You can create an instance of an adapter using its constructor.
                An adapter constructor takes one argument, which is an array
                of parameters used to declare the connection.
            </para>

            <example id="zend.db.adapter.connecting.constructor.example">
                <title>Using an Adapter Constructor</title>
                <programlisting language="php"><![CDATA[
$db = new Zend_Db_Adapter_Pdo_Mysql(array(
    'host'     => '127.0.0.1',
    'username' => 'webuser',
    'password' => 'xxxxxxxx',
    'dbname'   => 'test'
));
]]></programlisting>
            </example>

        </sect3>

        <sect3 id="zend.db.adapter.connecting.factory">

            <title>Using the Zend_Db Factory</title>

            <para>
                As an alternative to using an adapter constructor directly, you
                can create an instance of an adapter using the static method
                <classname>Zend_Db::factory()</classname>. This method dynamically loads
                the adapter class file on demand using
                <link linkend="zend.loader.load.class">Zend_Loader::loadClass()</link>.
            </para>

            <para>
                The first argument is a string that names the base name of the
                adapter class. For example the string 'Pdo_Mysql' corresponds
                to the class Zend_Db_Adapter_Pdo_Mysql. The second argument is
                the same array of parameters you would have given to the
                adapter constructor.
            </para>

            <example id="zend.db.adapter.connecting.factory.example">
                <title>Using the Adapter Factory Method</title>
                <programlisting language="php"><![CDATA[
// We don't need the following statement because the
// Zend_Db_Adapter_Pdo_Mysql file will be loaded for us by the Zend_Db
// factory method.

// require_once 'Zend/Db/Adapter/Pdo/Mysql.php';

// Automatically load class Zend_Db_Adapter_Pdo_Mysql
// and create an instance of it.
$db = Zend_Db::factory('Pdo_Mysql', array(
    'host'     => '127.0.0.1',
    'username' => 'webuser',
    'password' => 'xxxxxxxx',
    'dbname'   => 'test'
));
]]></programlisting>
            </example>

            <para>
                If you create your own class that extends
                <classname>Zend_Db_Adapter_Abstract_Adapter</classname>, but you do not name your
                class with the "Zend_Db_Adapter" package prefix, you can use the
                <methodname>factory()</methodname> method to load your adapter if you
                specify the leading portion of the adapter class with the
                'adapterNamespace' key in the parameters array.
            </para>

            <example id="zend.db.adapter.connecting.factory.example2">
                <title>Using the Adapter Factory Method for a Custom Adapter Class</title>
                <programlisting language="php"><![CDATA[
// We don't need to load the adapter class file
// because it will be loaded for us by the Zend_Db factory method.

// Automatically load class MyProject_Db_Adapter_Pdo_Mysql and create
// an instance of it.
$db = Zend_Db::factory('Pdo_Mysql', array(
    'host'             => '127.0.0.1',
    'username'         => 'webuser',
    'password'         => 'xxxxxxxx',
    'dbname'           => 'test',
    'adapterNamespace' => 'MyProject_Db_Adapter'
));
]]></programlisting>
            </example>

        </sect3>

        <sect3 id="zend.db.adapter.connecting.factory-config">

            <title>Using Zend_Config with the Zend_Db Factory</title>

            <para>
                Optionally, you may specify either argument of the
                <methodname>factory()</methodname> method as an object of type
                <link linkend="zend.config">Zend_Config</link>.
            </para>

            <para>
                If the first argument is a config object, it is expected to
                contain a property named <code>adapter</code>, containing the
                string naming the adapter class name base. Optionally, the object
                may contain a property named <code>params</code>, with
                subproperties corresponding to adapter parameter names.
                This is used only if the second argument of the
                <methodname>factory()</methodname> method is absent.
            </para>

            <example id="zend.db.adapter.connecting.factory.example1">
                <title>Using the Adapter Factory Method with a Zend_Config Object</title>
                <para>
                    In the example below, a <classname>Zend_Config</classname> object is created
                    from an array. You can also load data from an external file using classes such
                    as <link linkend="zend.config.adapters.ini">Zend_Config_Ini</link>
                    and <link linkend="zend.config.adapters.xml">Zend_Config_Xml</link>.
                </para>
                <programlisting language="php"><![CDATA[
$config = new Zend_Config(
    array(
        'database' => array(
            'adapter' => 'Mysqli',
            'params'  => array(
                'host'     => '127.0.0.1',
                'dbname'   => 'test',
                'username' => 'webuser',
                'password' => 'secret',
            )
        )
    )
);

$db = Zend_Db::factory($config->database);
]]></programlisting>
            </example>

            <para>
                The second argument of the <methodname>factory()</methodname> method may be
                an associative array containing entries corresponding to
                adapter parameters. This argument is optional. If the first
                argument is of type <classname>Zend_Config</classname>, it is assumed to contain all
                parameters, and the second argument is ignored.
            </para>

        </sect3>

        <sect3 id="zend.db.adapter.connecting.parameters">

            <title>Adapter Parameters</title>

            <para>
                The following list explains common parameters recognized by
                <classname>Zend_Db</classname> Adapter classes.
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        <emphasis>host</emphasis>:
                        a string containing a hostname or IP address of the
                        database server. If the database is running on the
                        same host as the PHP application, you may use
                        'localhost' or '127.0.0.1'.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>username</emphasis>:
                        account identifier for authenticating a connection to the
                        RDBMS server.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>password</emphasis>:
                        account password credential for authenticating a
                        connection to the RDBMS server.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>dbname</emphasis>:
                        database instance name on the RDBMS server.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>port</emphasis>:
                        some RDBMS servers can accept network connections on a
                        administrator-specified port number. The port
                        parameter allow you to specify the port to which your
                        PHP application connects, to match the port configured
                        on the RDBMS server.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>charset</emphasis>:
                        specify the charset used for the connection.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>options</emphasis>:
                        this parameter is an associative array of options
                        that are generic to all <classname>Zend_Db_Adapter</classname> classes.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>driver_options</emphasis>:
                        this parameter is an associative array of additional
                        options that are specific to a given database
                        extension. One typical use of this parameter is to
                        set attributes of a PDO driver.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>adapterNamespace</emphasis>:
                        names the initial part of the class name for the
                        adapter, instead of 'Zend_Db_Adapter'. Use this if
                        you need to use the <methodname>factory()</methodname> method to
                        load a non-Zend database adapter class.
                    </para>
                </listitem>
            </itemizedlist>

            <example id="zend.db.adapter.connecting.parameters.example1">
                <title>Passing the Case-Folding Option to the Factory</title>
                <para>
                    You can specify this option by the constant
                    <classname>Zend_Db::CASE_FOLDING</classname>.
                    This corresponds to the <constant>ATTR_CASE</constant> attribute in
                    PDO and IBM DB2 database drivers, adjusting the case of
                    string keys in query result sets. The option takes values
                    <constant>Zend_Db::CASE_NATURAL</constant> (the default),
                    <constant>Zend_Db::CASE_UPPER</constant>, and
                    <constant>Zend_Db::CASE_LOWER</constant>.
                </para>
                <programlisting language="php"><![CDATA[
$options = array(
    Zend_Db::CASE_FOLDING => Zend_Db::CASE_UPPER
);

$params = array(
    'host'           => '127.0.0.1',
    'username'       => 'webuser',
    'password'       => 'xxxxxxxx',
    'dbname'         => 'test',
    'options'        => $options
);

$db = Zend_Db::factory('Db2', $params);
]]></programlisting>
            </example>

            <example id="zend.db.adapter.connecting.parameters.example2">
                <title>Passing the Auto-Quoting Option to the Factory</title>
                <para>
                    You can specify this option by the constant
                    <classname>Zend_Db::AUTO_QUOTE_IDENTIFIERS</classname>. If the value
                    is <constant>TRUE</constant> (the default), identifiers like table
                    names, column names, and even aliases are delimited in all
                    SQL syntax generated by the Adapter object. This makes it
                    simple to use identifiers that contain SQL keywords, or
                    special characters. If the value is <constant>FALSE</constant>,
                    identifiers are not delimited automatically. If you need
                    to delimit identifiers, you must do so yourself using the
                    <methodname>quoteIdentifier()</methodname> method.
                </para>
                <programlisting language="php"><![CDATA[
$options = array(
    Zend_Db::AUTO_QUOTE_IDENTIFIERS => false
);

$params = array(
    'host'           => '127.0.0.1',
    'username'       => 'webuser',
    'password'       => 'xxxxxxxx',
    'dbname'         => 'test',
    'options'        => $options
);

$db = Zend_Db::factory('Pdo_Mysql', $params);
]]></programlisting>
            </example>

            <example id="zend.db.adapter.connecting.parameters.example3">
                <title>Passing PDO Driver Options to the Factory</title>
                <programlisting language="php"><![CDATA[
$pdoParams = array(
    PDO::MYSQL_ATTR_USE_BUFFERED_QUERY => true
);

$params = array(
    'host'           => '127.0.0.1',
    'username'       => 'webuser',
    'password'       => 'xxxxxxxx',
    'dbname'         => 'test',
    'driver_options' => $pdoParams
);

$db = Zend_Db::factory('Pdo_Mysql', $params);

echo $db->getConnection()
        ->getAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY);
]]></programlisting>
            </example>

            <example id="zend.db.adapter.connecting.parameters.example4">
                <title>Passing Serialization Options to the Factory</title>
                <programlisting language="php"><![CDATA[
$options = array(
    Zend_Db::ALLOW_SERIALIZATION => false
);

$params = array(
    'host'           => '127.0.0.1',
    'username'       => 'webuser',
    'password'       => 'xxxxxxxx',
    'dbname'         => 'test',
    'options'        => $options
);

$db = Zend_Db::factory('Pdo_Mysql', $params);
]]></programlisting>
            </example>

        </sect3>

        <sect3 id="zend.db.adapter.connecting.getconnection">
            <title>Managing Lazy Connections</title>

            <para>
                Creating an instance of an Adapter class does not immediately
                connect to the RDBMS server. The Adapter saves the connection
                parameters, and makes the actual connection on demand, the
                first time you need to execute a query. This ensures that
                creating an Adapter object is quick and inexpensive. You can
                create an instance of an Adapter even if you are not certain
                that you need to run any database queries during the current
                request your application is serving.
            </para>

            <para>
                If you need to force the Adapter to connect to the RDBMS, use
                the <methodname>getConnection()</methodname> method. This method returns
                an object for the connection as represented by the respective
                PHP database extension. For example, if you use any of the
                Adapter classes for PDO drivers, then
                <methodname>getConnection()</methodname> returns the PDO object, after
                initiating it as a live connection to the specific database.
            </para>

            <para>
                It can be useful to force the connection if you want to catch
                any exceptions it throws as a result of invalid account
                credentials, or other failure to connect to the RDBMS server.
                These exceptions are not thrown until the connection is made,
                so it can help simplify your application code if you handle the
                exceptions in one place, instead of at the time of
                the first query against the database.
            </para>

            <para>
                Additionally, an adapter can get serialized to store it, for example,
                in a session variable. This can be very useful not only for the
                adapter itself, but for other objects that aggregate it, like a
                <classname>Zend_Db_Select</classname> object. By default, adapters are allowed
                to be serialized, if you don't want it, you should consider passing the
                <classname>Zend_Db::ALLOW_SERIALIZATION=false</classname> option, see the example
                above. To respect lazy connections principle, the adapter won't reconnect itself
                after being unserialized. You must then call
                <methodname>getConnection()</methodname>
                yourself. You can make the adapter auto-reconnect by passing the
                <classname>Zend_Db::AUTO_RECONNECT_ON_UNSERIALIZE=true</classname> as an adapter
                option.
            </para>

            <example id="zend.db.adapter.connecting.getconnection.example">
                <title>Handling Connection Exceptions</title>
                <programlisting language="php"><![CDATA[
try {
    $db = Zend_Db::factory('Pdo_Mysql', $parameters);
    $db->getConnection();
} catch (Zend_Db_Adapter_Exception $e) {
    // perhaps a failed login credential, or perhaps the RDBMS is not running
} catch (Zend_Exception $e) {
    // perhaps factory() failed to load the specified Adapter class
}
]]></programlisting>
            </example>

        </sect3>

    </sect2>

    <sect2 id="zend.db.adapter.example-database">

        <title>Example Database</title>

        <para>
            In the documentation for <classname>Zend_Db</classname> classes, we use a set of simple
            tables to illustrate usage of the classes and methods. These
            example tables could store information for tracking bugs in a
            software development project. The database contains four tables:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <emphasis>accounts</emphasis> stores
                    information about each user of the bug-tracking database.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis>products</emphasis> stores
                    information about each product for which a bug can be
                    logged.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis>bugs</emphasis> stores information
                    about bugs, including that current state of the bug, the
                    person who reported the bug, the person who is assigned to
                    fix the bug, and the person who is assigned to verify the
                    fix.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis>bugs_products</emphasis> stores a
                    relationship between bugs and products. This implements a
                    many-to-many relationship, because a given bug may be
                    relevant to multiple products, and of course a given
                    product can have multiple bugs.
                </para>
            </listitem>
        </itemizedlist>

        <para>
            The following SQL data definition language pseudocode describes the
            tables in this example database. These example tables are used
            extensively by the automated unit tests for <classname>Zend_Db</classname>.
        </para>

        <programlisting language="sql"><![CDATA[
CREATE TABLE accounts (
  account_name      VARCHAR(100) NOT NULL PRIMARY KEY
);

CREATE TABLE products (
  product_id        INTEGER NOT NULL PRIMARY KEY,
  product_name      VARCHAR(100)
);

CREATE TABLE bugs (
  bug_id            INTEGER NOT NULL PRIMARY KEY,
  bug_description   VARCHAR(100),
  bug_status        VARCHAR(20),
  reported_by       VARCHAR(100) REFERENCES accounts(account_name),
  assigned_to       VARCHAR(100) REFERENCES accounts(account_name),
  verified_by       VARCHAR(100) REFERENCES accounts(account_name)
);

CREATE TABLE bugs_products (
  bug_id            INTEGER NOT NULL REFERENCES bugs,
  product_id        INTEGER NOT NULL REFERENCES products,
  PRIMARY KEY       (bug_id, product_id)
);
]]></programlisting>

        <para>
            Also notice that the <code>bugs</code> table contains multiple
            foreign key references to the <code>accounts</code> table.
            Each of these foreign keys may reference a different row in the
            <code>accounts</code> table for a given bug.
        </para>

        <para>
            The diagram below illustrates the physical data model of the
            example database.
        </para>

        <para>
            <inlinegraphic width="387" scale="100" align="center" valign="middle"
                fileref="figures/zend.db.adapter.example-database.png" format="PNG" />
        </para>

    </sect2>

    <sect2 id="zend.db.adapter.select">

        <title>Reading Query Results</title>

        <para>
            This section describes methods of the Adapter class with which you
            can run SELECT queries and retrieve the query results.
        </para>

        <sect3 id="zend.db.adapter.select.fetchall">

            <title>Fetching a Complete Result Set</title>

            <para>
                You can run a SQL SELECT query and retrieve its results in one
                step using the <methodname>fetchAll()</methodname> method.
            </para>

            <para>
                The first argument to this method is a string containing a
                SELECT statement. Alternatively, the first argument can be an
                object of class <link linkend="zend.db.select">Zend_Db_Select</link>.
                The Adapter automatically converts this object to a string
                representation of the SELECT statement.
            </para>

            <para>
                The second argument to <methodname>fetchAll()</methodname> is an array of
                values to substitute for parameter placeholders in the SQL
                statement.
            </para>

            <example id="zend.db.adapter.select.fetchall.example">
                <title>Using fetchAll()</title>
                <programlisting language="php"><![CDATA[
$sql = 'SELECT * FROM bugs WHERE bug_id = ?';

$result = $db->fetchAll($sql, 2);
]]></programlisting>
            </example>

        </sect3>

        <sect3 id="zend.db.adapter.select.fetch-mode">

            <title>Changing the Fetch Mode</title>

            <para>
                By default, <methodname>fetchAll()</methodname> returns an array of
                rows, each of which is an associative array. The keys of the
                associative array are the columns or column aliases named in
                the select query.
            </para>

            <para>
                You can specify a different style of fetching results using the
                <methodname>setFetchMode()</methodname> method. The modes supported are
                identified by constants:
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        <emphasis>Zend_Db::FETCH_ASSOC</emphasis>:
                        return data in an array of associative arrays.
                        The array keys are column names, as strings. This is the default fetch mode
                        for <classname>Zend_Db_Adapter</classname> classes.
                    </para>
                    <para>
                        Note that if your select-list contains more than one
                        column with the same name, for example if they are from
                        two different tables in a JOIN, there can be only one
                        entry in the associative array for a given name.
                        If you use the FETCH_ASSOC mode, you should specify
                        column aliases in your SELECT query to ensure that the
                        names result in unique array keys.
                    </para>
                    <para>
                        By default, these strings are returned as they are
                        returned by the database driver. This is typically the
                        spelling of the column in the RDBMS server. You can
                        specify the case for these strings, using the
                        <classname>Zend_Db::CASE_FOLDING</classname> option.
                        Specify this when instantiating the Adapter.
                        See <xref linkend="zend.db.adapter.connecting.parameters.example1" />.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>Zend_Db::FETCH_NUM</emphasis>:
                        return data in an array of arrays. The arrays are
                        indexed by integers, corresponding to the position of
                        the respective field in the select-list of the query.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>Zend_Db::FETCH_BOTH</emphasis>:
                        return data in an array of arrays. The array keys are
                        both strings as used in the FETCH_ASSOC mode, and
                        integers as used in the FETCH_NUM mode. Note that the
                        number of elements in the array is double that which
                        would be in the array if you used either FETCH_ASSOC
                        or FETCH_NUM.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>Zend_Db::FETCH_COLUMN</emphasis>:
                        return data in an array of values. The value in each array
                        is the value returned by one column of the result set.
                        By default, this is the first column, indexed by 0.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>Zend_Db::FETCH_OBJ</emphasis>:
                        return data in an array of objects. The default class
                        is the PHP built-in class stdClass. Columns of the
                        result set are available as public properties of the
                        object.
                    </para>
                </listitem>
            </itemizedlist>

            <example id="zend.db.adapter.select.fetch-mode.example">
                <title>Using setFetchMode()</title>
                <programlisting language="php"><![CDATA[
$db->setFetchMode(Zend_Db::FETCH_OBJ);

$result = $db->fetchAll('SELECT * FROM bugs WHERE bug_id = ?', 2);

// $result is an array of objects
echo $result[0]->bug_description;
]]></programlisting>
            </example>

        </sect3>

        <sect3 id="zend.db.adapter.select.fetchassoc">

            <title>Fetching a Result Set as an Associative Array</title>

            <para>
                The <methodname>fetchAssoc()</methodname> method returns data in an array
                of associative arrays, regardless of what value you have set
                for the fetch mode.
            </para>

            <example id="zend.db.adapter.select.fetchassoc.example">
                <title>Using fetchAssoc()</title>
                <programlisting language="php"><![CDATA[
$db->setFetchMode(Zend_Db::FETCH_OBJ);

$result = $db->fetchAssoc('SELECT * FROM bugs WHERE bug_id = ?', 2);

// $result is an array of associative arrays, in spite of the fetch mode
echo $result[0]['bug_description'];
]]></programlisting>
            </example>

        </sect3>

        <sect3 id="zend.db.adapter.select.fetchcol">

            <title>Fetching a Single Column from a Result Set</title>

            <para>
                The <methodname>fetchCol()</methodname> method returns data in an array
                of values, regardless of the value you have set for the fetch mode.
                This only returns the first column returned by the query.
                Any other columns returned by the query are discarded.
                If you need to return a column other than the first, see
                <xref linkend="zend.db.statement.fetching.fetchcolumn" />.
            </para>

            <example id="zend.db.adapter.select.fetchcol.example">
                <title>Using fetchCol()</title>
                <programlisting language="php"><![CDATA[
$db->setFetchMode(Zend_Db::FETCH_OBJ);

$result = $db->fetchCol(
    'SELECT bug_description, bug_id FROM bugs WHERE bug_id = ?', 2);

// contains bug_description; bug_id is not returned
echo $result[0];
]]></programlisting>
            </example>

        </sect3>

        <sect3 id="zend.db.adapter.select.fetchpairs">

            <title>Fetching Key-Value Pairs from a Result Set</title>

            <para>
                The <methodname>fetchPairs()</methodname> method returns data in an array
                of key-value pairs, as an associative array with a single entry
                per row. The key of this associative array is taken from the
                first column returned by the SELECT query. The value is taken
                from the second column returned by the SELECT query. Any other
                columns returned by the query are discarded.
            </para>

            <para>
                You should design the SELECT query so that the first column
                returned has unique values. If there are duplicates values in
                the first column, entries in the associative array will be
                overwritten.
            </para>

            <example id="zend.db.adapter.select.fetchpairs.example">
                <title>Using fetchPairs()</title>
                <programlisting language="php"><![CDATA[
$db->setFetchMode(Zend_Db::FETCH_OBJ);

$result = $db->fetchPairs('SELECT bug_id, bug_status FROM bugs');

echo $result[2];
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.adapter.select.fetchrow">

            <title>Fetching a Single Row from a Result Set</title>

            <para>
                The <methodname>fetchRow()</methodname> method returns data using the
                current fetch mode, but it returns only the first row
                fetched from the result set.
            </para>

            <example id="zend.db.adapter.select.fetchrow.example">
                <title>Using fetchRow()</title>
                <programlisting language="php"><![CDATA[
$db->setFetchMode(Zend_Db::FETCH_OBJ);

$result = $db->fetchRow('SELECT * FROM bugs WHERE bug_id = 2');

// note that $result is a single object, not an array of objects
echo $result->bug_description;
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.adapter.select.fetchone">

            <title>Fetching a Single Scalar from a Result Set</title>

            <para>
                The <methodname>fetchOne()</methodname> method is like a combination
                of <methodname>fetchRow()</methodname> with <methodname>fetchCol()</methodname>,
                in that it returns data only for the first row fetched from
                the result set, and it returns only the value of the first
                column in that row. Therefore it returns only a single
                scalar value, not an array or an object.
            </para>

            <example id="zend.db.adapter.select.fetchone.example">
                <title>Using fetchOne()</title>
                <programlisting language="php"><![CDATA[
$result = $db->fetchOne('SELECT bug_status FROM bugs WHERE bug_id = 2');

// this is a single string value
echo $result;
]]></programlisting>
            </example>
        </sect3>

    </sect2>

    <sect2 id="zend.db.adapter.write">

        <title>Writing Changes to the Database</title>

        <para>
            You can use the Adapter class to write new data or change existing
            data in your database. This section describes methods to do these
            operations.
        </para>

        <sect3 id="zend.db.adapter.write.insert">

            <title>Inserting Data</title>

            <para>
                You can add new rows to a table in your database using the
                <methodname>insert()</methodname> method. The first argument is a string
                that names the table, and the second argument is an associative
                array, mapping column names to data values.
            </para>

            <example id="zend.db.adapter.write.insert.example">
                <title>Inserting in a Table</title>
                <programlisting language="php"><![CDATA[
$data = array(
    'created_on'      => '2007-03-22',
    'bug_description' => 'Something wrong',
    'bug_status'      => 'NEW'
);

$db->insert('bugs', $data);
]]></programlisting>
            </example>

            <para>
                Columns you exclude from the array of data are not specified to
                the database. Therefore, they follow the same rules that an
                SQL INSERT statement follows: if the column has a DEFAULT
                clause, the column takes that value in the row created,
                otherwise the column is left in a NULL state.
            </para>

            <para>
                By default, the values in your data array are inserted using
                parameters. This reduces risk of some types of security
                issues. You don't need to apply escaping or quoting to values
                in the data array.
            </para>

            <para>
                You might need values in the data array to be treated as SQL
                expressions, in which case they should not be quoted. By
                default, all data values passed as strings are treated as
                string literals. To specify that the value is an SQL
                expression and therefore should not be quoted, pass the value
                in the data array as an object of type <classname>Zend_Db_Expr</classname> instead
                of a plain string.
            </para>

            <example id="zend.db.adapter.write.insert.example2">
                <title>Inserting Expressions in a Table</title>
                <programlisting language="php"><![CDATA[
$data = array(
    'created_on'      => new Zend_Db_Expr('CURDATE()'),
    'bug_description' => 'Something wrong',
    'bug_status'      => 'NEW'
);

$db->insert('bugs', $data);
]]></programlisting>
            </example>

        </sect3>

        <sect3 id="zend.db.adapter.write.lastinsertid">

            <title>Retrieving a Generated Value</title>

            <para>
                Some RDBMS brands support auto-incrementing primary keys.
                A table defined this way generates a primary key value
                automatically during an INSERT of a new row. The return value
                of the <methodname>insert()</methodname> method is <emphasis>not</emphasis>
                the last inserted ID, because the table might not have an
                auto-incremented column. Instead, the return value is the
                number of rows affected (usually 1).
            </para>

            <para>
                If your table is defined with an auto-incrementing primary key,
                you can call the <methodname>lastInsertId()</methodname> method after the
                insert. This method returns the last value generated in the
                scope of the current database connection.
            </para>

            <example id="zend.db.adapter.write.lastinsertid.example-1">
                <title>Using lastInsertId() for an Auto-Increment Key</title>
                <programlisting language="php"><![CDATA[
$db->insert('bugs', $data);

// return the last value generated by an auto-increment column
$id = $db->lastInsertId();
]]></programlisting>
            </example>

            <para>
                Some RDBMS brands support a sequence object, which generates
                unique values to serve as primary key values. To support
                sequences, the <methodname>lastInsertId()</methodname> method accepts two
                optional string arguments. These arguments name the table and
                the column, assuming you have followed the convention that a
                sequence is named using the table and column names for which
                the sequence generates values, and a suffix "_seq". This is
                based on the convention used by PostgreSQL when naming
                sequences for SERIAL columns. For example, a table "bugs" with
                primary key column "bug_id" would use a sequence named
                "bugs_bug_id_seq".
            </para>

            <example id="zend.db.adapter.write.lastinsertid.example-2">
                <title>Using lastInsertId() for a Sequence</title>
                <programlisting language="php"><![CDATA[
$db->insert('bugs', $data);

// return the last value generated by sequence 'bugs_bug_id_seq'.
$id = $db->lastInsertId('bugs', 'bug_id');

// alternatively, return the last value generated by sequence 'bugs_seq'.
$id = $db->lastInsertId('bugs');
]]></programlisting>
            </example>

            <para>
                If the name of your sequence object does not follow this naming
                convention, use the <methodname>lastSequenceId()</methodname> method
                instead. This method takes a single string argument, naming
                the sequence literally.
            </para>

            <example id="zend.db.adapter.write.lastinsertid.example-3">
                <title>Using lastSequenceId()</title>
                <programlisting language="php"><![CDATA[
$db->insert('bugs', $data);

// return the last value generated by sequence 'bugs_id_gen'.
$id = $db->lastSequenceId('bugs_id_gen');
]]></programlisting>
            </example>

            <para>
                For RDBMS brands that don't support sequences, including MySQL,
                Microsoft SQL Server, and SQLite, the arguments to the
                lastInsertId() method are ignored, and the value returned is the
                most recent value generated for any table by INSERT operations
                during the current connection. For these RDBMS brands, the
                lastSequenceId() method always returns <constant>NULL</constant>.
            </para>

            <note>
                <title>Why Not Use "SELECT MAX(id) FROM table"?</title>
                <para>
                    Sometimes this query returns the most recent primary key
                    value inserted into the table. However, this technique
                    is not safe to use in an environment where multiple clients are
                    inserting records to the database. It is possible, and
                    therefore is bound to happen eventually, that another
                    client inserts another row in the instant between the
                    insert performed by your client application and your query
                    for the MAX(id) value. Thus the value returned does not
                    identify the row you inserted, it identifies the row
                    inserted by some other client. There is no way to know
                    when this has happened.
                </para>
                <para>
                    Using a strong transaction isolation mode such as
                    "repeatable read" can mitigate this risk, but some RDBMS
                    brands don't support the transaction isolation required for
                    this, or else your application may use a lower transaction
                    isolation mode by design.
                </para>
                <para>
                    Furthermore, using an expression like "MAX(id)+1" to generate
                    a new value for a primary key is not safe, because two clients
                    could do this query simultaneously, and then both use the same
                    calculated value for their next INSERT operation.
                </para>
                <para>
                    All RDBMS brands provide mechanisms to generate unique
                    values, and to return the last value generated. These
                    mechanisms necessarily work outside of the scope of
                    transaction isolation, so there is no chance of two clients
                    generating the same value, and there is no chance that the
                    value generated by another client could be reported to your
                    client's connection as the last value generated.
                </para>
            </note>

        </sect3>

        <sect3 id="zend.db.adapter.write.update">
            <title>Updating Data</title>

            <para>
                You can update rows in a database table using the
                <methodname>update()</methodname> method of an Adapter. This method takes
                three arguments: the first is the name of the table; the
                second is an associative array mapping columns to change to new
                values to assign to these columns.
            </para>

            <para>
                The values in the data array are treated as string literals.
                See <xref linkend="zend.db.adapter.write.insert" />
                for information on using SQL expressions in the data array.
            </para>

            <para>
                The third argument is a string containing an SQL expression
                that is used as criteria for the rows to change. The values
                and identifiers in this argument are not quoted or escaped.
                You are responsible for ensuring that any dynamic content is
                interpolated into this string safely.
                See <xref linkend="zend.db.adapter.quoting" />
                for methods to help you do this.
            </para>

            <para>
                The return value is the number of rows affected by the update
                operation.
            </para>

            <example id="zend.db.adapter.write.update.example">
                <title>Updating Rows</title>
                <programlisting language="php"><![CDATA[
$data = array(
    'updated_on'      => '2007-03-23',
    'bug_status'      => 'FIXED'
);

$n = $db->update('bugs', $data, 'bug_id = 2');
]]></programlisting>
            </example>

            <para>
                If you omit the third argument, then all rows in the database
                table are updated with the values specified in the data array.
            </para>

            <para>
                If you provide an array of strings as the third argument, these
                strings are joined together as terms in an expression separated
                by <constant>AND</constant> operators.
            </para>

            <example id="zend.db.adapter.write.update.example-array">
                <title>Updating Rows Using an Array of Expressions</title>
                <programlisting language="php"><![CDATA[
$data = array(
    'updated_on'      => '2007-03-23',
    'bug_status'      => 'FIXED'
);

$where[] = "reported_by = 'goofy'";
$where[] = "bug_status = 'OPEN'";

$n = $db->update('bugs', $data, $where);

// Resulting SQL is:
//  UPDATE "bugs" SET "update_on" = '2007-03-23', "bug_status" = 'FIXED'
//  WHERE ("reported_by" = 'goofy') AND ("bug_status" = 'OPEN')
]]></programlisting>
            </example>

        </sect3>

        <sect3 id="zend.db.adapter.write.delete">
            <title>Deleting Data</title>
            <para>
                You can delete rows from a database table using the
                <methodname>delete()</methodname> method. This method takes two arguments:
                the first is a string naming the table.
            </para>

            <para>
                The second argument is a string containing an SQL expression
                that is used as criteria for the rows to delete. The values
                and identifiers in this argument are not quoted or escaped.
                You are responsible for ensuring that any dynamic content is
                interpolated into this string safely.
                See <xref linkend="zend.db.adapter.quoting" />
                for methods to help you do this.
            </para>

            <para>
                The return value is the number of rows affected by the delete
                operation.
            </para>

            <example id="zend.db.adapter.write.delete.example">
                <title>Deleting Rows</title>
                <programlisting language="php"><![CDATA[
$n = $db->delete('bugs', 'bug_id = 3');
]]></programlisting>
            </example>

            <para>
                If you omit the second argument, the result is that all rows in
                the database table are deleted.
            </para>

            <para>
                If you provide an array of strings as the second argument, these
                strings are joined together as terms in an expression separated
                by <constant>AND</constant> operators.
            </para>

        </sect3>

    </sect2>

    <sect2 id="zend.db.adapter.quoting">

        <title>Quoting Values and Identifiers</title>

        <para>
            When you form SQL queries, often it is the case that you need to
            include the values of PHP variables in SQL expressions. This is
            risky, because if the value in a PHP string contains certain
            symbols, such as the quote symbol, it could result in invalid SQL.
            For example, notice the imbalanced quote characters in the
            following query:
            <programlisting language="php"><![CDATA[
$name = "O'Reilly";
$sql = "SELECT * FROM bugs WHERE reported_by = '$name'";

echo $sql;
// SELECT * FROM bugs WHERE reported_by = 'O'Reilly'
]]></programlisting>
        </para>

        <para>
            Even worse is the risk that such code mistakes might be exploited
            deliberately by a person who is trying to manipulate the function
            of your web application. If they can specify the value of a PHP
            variable through the use of an HTTP parameter or other mechanism,
            they might be able to make your SQL queries do things that you
            didn't intend them to do, such as return data to which the person
            should not have privilege to read. This is a serious and widespread
            technique for violating application security, known as "SQL Injection" (see <ulink
                url="http://en.wikipedia.org/wiki/SQL_Injection">http://en.wikipedia.org/wiki/SQL_Injection</ulink>).
        </para>

        <para>
            The <classname>Zend_Db</classname> Adapter class provides convenient functions to help
            you reduce vulnerabilities to SQL Injection attacks in your PHP code.
            The solution is to escape special characters such as quotes in PHP
            values before they are interpolated into your SQL strings.
            This protects against both accidental and deliberate manipulation
            of SQL strings by PHP variables that contain special characters.
        </para>

        <sect3 id="zend.db.adapter.quoting.quote">

            <title>Using quote()</title>

            <para>
                The <methodname>quote()</methodname> method accepts a single argument, a
                scalar string value. It returns the value with special
                characters escaped in a manner appropriate for the RDBMS you
                are using, and surrounded by string value delimiters. The
                standard SQL string value delimiter is the single-quote
                (<code>'</code>).
            </para>

            <example id="zend.db.adapter.quoting.quote.example">
                <title>Using quote()</title>
                <programlisting language="php"><![CDATA[
$name = $db->quote("O'Reilly");
echo $name;
// 'O\'Reilly'

$sql = "SELECT * FROM bugs WHERE reported_by = $name";

echo $sql;
// SELECT * FROM bugs WHERE reported_by = 'O\'Reilly'
]]></programlisting>
            </example>

            <para>
                Note that the return value of <methodname>quote()</methodname> includes the
                quote delimiters around the string. This is different from
                some functions that escape special characters but do not add
                the quote delimiters, for example <ulink
                    url="http://www.php.net/mysqli_real_escape_string">mysql_real_escape_string()</ulink>.
            </para>

            <para>
                Values may need to be quoted or not quoted according to the SQL
                datatype context in which they are used. For instance, in some
                RDBMS brands, an integer value must not be quoted as a string
                if it is compared to an integer-type column or expression.
                In other words, the following is an error in some SQL
                implementations, assuming <code>intColumn</code> has a SQL
                datatype of <constant>INTEGER</constant>

                <programlisting language="php"><![CDATA[
SELECT * FROM atable WHERE intColumn = '123'
]]></programlisting>
            </para>

            <para>
                You can use the optional second argument to the
                <methodname>quote()</methodname> method to apply quoting selectively for
                the SQL datatype you specify.
            </para>

            <example id="zend.db.adapter.quoting.quote.example-2">
                <title>Using quote() with a SQL Type</title>
                <programlisting language="php"><![CDATA[
$value = '1234';
$sql = 'SELECT * FROM atable WHERE intColumn = '
     . $db->quote($value, 'INTEGER');
]]></programlisting>
            </example>

            <para>
                Each <classname>Zend_Db_Adapter</classname> class has encoded the names of numeric
                SQL datatypes for the respective brand of RDBMS. You can also
                use the constants <classname>Zend_Db::INT_TYPE</classname>,
                <classname>Zend_Db::BIGINT_TYPE</classname>, and
                <classname>Zend_Db::FLOAT_TYPE</classname> to write code in a more
                RDBMS-independent way.
            </para>

            <para>
                <classname>Zend_Db_Table</classname> specifies SQL types to
                <methodname>quote()</methodname> automatically when generating SQL queries that
                reference a table's key columns.
            </para>

        </sect3>

        <sect3 id="zend.db.adapter.quoting.quote-into">

            <title>Using quoteInto()</title>

            <para>
                The most typical usage of quoting is to interpolate a PHP
                variable into a SQL expression or statement. You can use the
                <methodname>quoteInto()</methodname> method to do this in one step. This
                method takes two arguments: the first argument is a string
                containing a placeholder symbol (<code>?</code>), and the
                second argument is a value or PHP variable that should be
                substituted for that placeholder.
            </para>

            <para>
                The placeholder symbol is the same symbol used by many RDBMS
                brands for positional parameters, but the
                <methodname>quoteInto()</methodname> method only emulates query parameters.
                The method simply interpolates the value into the string,
                escapes special characters, and applies quotes around it.
                True query parameters maintain the separation between the SQL
                string and the parameters as the statement is parsed in the
                RDBMS server.
            </para>

            <example id="zend.db.adapter.quoting.quote-into.example">
                <title>Using quoteInto()</title>
                <programlisting language="php"><![CDATA[
$sql = $db->quoteInto("SELECT * FROM bugs WHERE reported_by = ?", "O'Reilly");

echo $sql;
// SELECT * FROM bugs WHERE reported_by = 'O\'Reilly'
]]></programlisting>
            </example>

            <para>
                You can use the optional third parameter of
                <methodname>quoteInto()</methodname> to specify the SQL datatype. Numeric
                datatypes are not quoted, and other types are quoted.
            </para>

            <example id="zend.db.adapter.quoting.quote-into.example-2">
                <title>Using quoteInto() with a SQL Type</title>
                <programlisting language="php"><![CDATA[
$sql = $db
    ->quoteInto("SELECT * FROM bugs WHERE bug_id = ?", '1234', 'INTEGER');

echo $sql;
// SELECT * FROM bugs WHERE reported_by = 1234
]]></programlisting>
            </example>

        </sect3>
        <sect3 id="zend.db.adapter.quoting.quote-identifier">

            <title>Using quoteIdentifier()</title>

            <para>
                Values are not the only part of SQL syntax that might need to
                be variable. If you use PHP variables to name tables, columns,
                or other identifiers in your SQL statements, you might need to
                quote these strings too. By default, SQL identifiers have
                syntax rules like PHP and most other programming languages.
                For example, identifiers should not contain spaces, certain
                punctuation or special characters, or international characters.
                Also certain words are reserved for SQL syntax, and should not
                be used as identifiers.
            </para>

            <para>
                However, SQL has a feature called <emphasis>delimited identifiers</emphasis>,
                which allows broader choices for the spelling of identifiers.
                If you enclose a SQL identifier in the proper types of quotes,
                you can use identifiers with spellings that would be invalid
                without the quotes. Delimited identifiers can contain spaces,
                punctuation, or international characters. You can also use SQL
                reserved words if you enclose them in identifier delimiters.
            </para>

            <para>
                The <methodname>quoteIdentifier()</methodname> method works like
                <methodname>quote()</methodname>, but it applies the identifier delimiter
                characters to the string according to the type of Adapter you
                use. For example, standard SQL uses double-quotes
                (<code>"</code>) for identifier delimiters, and most RDBMS
                brands use that symbol. MySQL uses back-quotes
                (<code>`</code>) by default. The
                <methodname>quoteIdentifier()</methodname> method also escapes special
                characters within the string argument.
            </para>

            <example id="zend.db.adapter.quoting.quote-identifier.example">
                <title>Using quoteIdentifier()</title>
                <programlisting language="php"><![CDATA[
// we might have a table name that is an SQL reserved word
$tableName = $db->quoteIdentifier("order");

$sql = "SELECT * FROM $tableName";

echo $sql
// SELECT * FROM "order"
]]></programlisting>
            </example>

            <para>
                SQL delimited identifiers are case-sensitive, unlike unquoted
                identifiers. Therefore, if you use delimited identifiers, you
                must use the spelling of the identifier exactly as it is stored
                in your schema, including the case of the letters.
            </para>

            <para>
                In most cases where SQL is generated within <classname>Zend_Db</classname> classes,
                the default is that all identifiers are delimited
                automatically. You can change this behavior with the option
                <classname>Zend_Db::AUTO_QUOTE_IDENTIFIERS</classname>. Specify this
                when instantiating the Adapter.
                See <xref linkend="zend.db.adapter.connecting.parameters.example2" />.
            </para>

        </sect3>

    </sect2>

    <sect2 id="zend.db.adapter.transactions">

        <title>Controlling Database Transactions</title>

        <para>
            Databases define transactions as logical units of work that can be
            committed or rolled back as a single change, even if they operate
            on multiple tables. All queries to a database are executed within
            the context of a transaction, even if the database driver manages
            them implicitly. This is called <emphasis>auto-commit</emphasis>
            mode, in which the database driver creates a transaction for every
            statement you execute, and commits that transaction after your
            SQL statement has been executed. By default, all <classname>Zend_Db</classname> Adapter
            classes operate in auto-commit mode.
        </para>

        <para>
            Alternatively, you can specify the beginning and resolution of a
            transaction, and thus control how many SQL queries are included in
            a single group that is committed (or rolled back) as a single
            operation. Use the <methodname>beginTransaction()</methodname> method to
            initiate a transaction. Subsequent SQL statements are executed in
            the context of the same transaction until you resolve it
            explicitly.
        </para>

        <para>
            To resolve the transaction, use either the <methodname>commit()</methodname> or
            <methodname>rollBack()</methodname> methods. The <methodname>commit()</methodname>
            method marks changes made during your transaction as committed, which
            means the effects of these changes are shown in queries run in
            other transactions.
        </para>

        <para>
            The <methodname>rollBack()</methodname> method does the opposite: it discards
            the changes made during your transaction. The changes are
            effectively undone, and the state of the data returns to how it was
            before you began your transaction. However, rolling back your
            transaction has no effect on changes made by other transactions
            running concurrently.
        </para>

        <para>
            After you resolve this transaction, <classname>Zend_Db_Adapter</classname>
            returns to auto-commit mode until you call
            <methodname>beginTransaction()</methodname> again.
        </para>

        <example id="zend.db.adapter.transactions.example">
            <title>Managing a Transaction to Ensure Consistency</title>
            <programlisting language="php"><![CDATA[
// Start a transaction explicitly.
$db->beginTransaction();

try {
    // Attempt to execute one or more queries:
    $db->query(...);
    $db->query(...);
    $db->query(...);

    // If all succeed, commit the transaction and all changes
    // are committed at once.
    $db->commit();

} catch (Exception $e) {
    // If any of the queries failed and threw an exception,
    // we want to roll back the whole transaction, reversing
    // changes made in the transaction, even those that succeeded.
    // Thus all changes are committed together, or none are.
    $db->rollBack();
    echo $e->getMessage();
}
]]></programlisting>
        </example>

    </sect2>

    <sect2 id="zend.db.adapter.list-describe">

        <title>Listing and Describing Tables</title>

        <para>
            The <methodname>listTables()</methodname> method returns an array of strings,
            naming all tables in the current database.
        </para>

        <para>
            The <methodname>describeTable()</methodname> method returns an associative
            array of metadata about a table. Specify the name of the table
            as a string in the first argument to this method. The second
            argument is optional, and names the schema in which the table
            exists.
        </para>

        <para>
            The keys of the associative array returned are the column names of
            the table. The value corresponding to each column is also an
            associative array, with the following keys and values:
        </para>

        <table frame="all" cellpadding="5" id="zend.db.adapter.list-describe.metadata">
            <title>Metadata Fields Returned by describeTable()</title>
            <tgroup cols="3" align="left" colsep="1" rowsep="1">
                <thead>
                    <row>
                        <entry>Key</entry>
                        <entry>Type</entry>
                        <entry>Description</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>SCHEMA_NAME</entry>
                        <entry>(string)</entry>
                        <entry>Name of the database schema in which this table exists.</entry>
                    </row>
                    <row>
                        <entry>TABLE_NAME</entry>
                        <entry>(string)</entry>
                        <entry>Name of the table to which this column belongs.</entry>
                    </row>
                    <row>
                        <entry>COLUMN_NAME</entry>
                        <entry>(string)</entry>
                        <entry>Name of the column.</entry>
                    </row>
                    <row>
                        <entry>COLUMN_POSITION</entry>
                        <entry>(integer)</entry>
                        <entry>Ordinal position of the column in the table.</entry>
                    </row>
                    <row>
                        <entry>DATA_TYPE</entry>
                        <entry>(string)</entry>
                        <entry>RDBMS name of the datatype of the column.</entry>
                    </row>
                    <row>
                        <entry>DEFAULT</entry>
                        <entry>(string)</entry>
                        <entry>Default value for the column, if any.</entry>
                    </row>
                    <row>
                        <entry>NULLABLE</entry>
                        <entry>(boolean)</entry>
                        <entry>
                            True if the column accepts SQL NULLs, false if the column has a NOT NULL
                            constraint.
                        </entry>
                    </row>
                    <row>
                        <entry>LENGTH</entry>
                        <entry>(integer)</entry>
                        <entry>Length or size of the column as reported by the RDBMS.</entry>
                    </row>
                    <row>
                        <entry>SCALE</entry>
                        <entry>(integer)</entry>
                        <entry>Scale of SQL NUMERIC or DECIMAL type.</entry>
                    </row>
                    <row>
                        <entry>PRECISION</entry>
                        <entry>(integer)</entry>
                        <entry>Precision of SQL NUMERIC or DECIMAL type.</entry>
                    </row>
                    <row>
                        <entry>UNSIGNED</entry>
                        <entry>(boolean)</entry>
                        <entry>True if an integer-based type is reported as UNSIGNED.</entry>
                    </row>
                    <row>
                        <entry>PRIMARY</entry>
                        <entry>(boolean)</entry>
                        <entry>True if the column is part of the primary key of this table.</entry>
                    </row>
                    <row>
                        <entry>PRIMARY_POSITION</entry>
                        <entry>(integer)</entry>
                        <entry>Ordinal position (1-based) of the column in the primary key.</entry>
                    </row>
                    <row>
                        <entry>IDENTITY</entry>
                        <entry>(boolean)</entry>
                        <entry>True if the column uses an auto-generated value.</entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <note>
            <title>How the IDENTITY Metadata Field Relates to Specific RDBMSs</title>
            <para>
                The IDENTITY metadata field was chosen as an 'idiomatic' term to
                represent a relation to surrogate keys. This field can be
                commonly known by the following values:-
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        <constant>IDENTITY</constant> - DB2, MSSQL
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <constant>AUTO_INCREMENT</constant> - MySQL
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <constant>SERIAL</constant> - PostgreSQL
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <constant>SEQUENCE</constant> - Oracle
                    </para>
                </listitem>
            </itemizedlist>
        </note>

        <para>
            If no table exists matching the table name and optional schema name
            specified, then <methodname>describeTable()</methodname> returns an empty array.
        </para>

    </sect2>

    <sect2 id="zend.db.adapter.closing">

        <title>Closing a Connection</title>

        <para>
            Normally it is not necessary to close a database connection. PHP
            automatically cleans up all resources and the end of a request.
            Database extensions are designed to close the connection as the
            reference to the resource object is cleaned up.
        </para>

        <para>
            However, if you have a long-duration PHP script that initiates many
            database connections, you might need to close the connection, to avoid
            exhausting the capacity of your RDBMS server. You can use the
            Adapter's <methodname>closeConnection()</methodname> method to explicitly close
            the underlying database connection.
        </para>

        <para>
            Since release 1.7.2, you could check you are currently connected to the RDBMS
            server with the method <methodname>isConnected()</methodname>. This means that a
            connection resource has been initiated and wasn't closed. This function is not
            currently able to test for example a server side closing of the connection. This is
            internally use to close the connection. It allow you to close the connection
            multiple times without errors. It was already the case before 1.7.2 for PDO
            adapters but not for the others.
        </para>

        <example id="zend.db.adapter.closing.example">
            <title>Closing a Database Connection</title>
            <programlisting language="php"><![CDATA[
$db->closeConnection();
]]></programlisting>
        </example>

        <note>
            <title>Does Zend_Db Support Persistent Connections?</title>
            <para>
                Yes, persistence is supported through the addition of
                the <code>persistent</code> flag set to true in the
                configuration (not driver_configuration) of an adapter
                in <classname>Zend_Db</classname>.
            </para>
            
            <example id="zend.db.adapter.connecting.persistence.example">
                <title>Using the Persitence Flag with the Oracle Adapter</title>
                <programlisting language="php"><![CDATA[
$db = Zend_Db::factory('Oracle', array(
    'host'       => '127.0.0.1',
    'username'   => 'webuser',
    'password'   => 'xxxxxxxx',
    'dbname'     => 'test',
    'persistent' => true
));
]]></programlisting>
            </example>
            
            <para>
                Please note that using persistent connections can cause an 
                excess of idle connections on the RDBMS server, which causes 
                more problems than any performance gain you might achieve by 
                reducing the overhead of making connections.
            </para>
            <para>
                Database connections have state. That is, some objects in the
                RDBMS server exist in session scope. Examples are locks, user
                variables, temporary tables, and information about the most
                recently executed query, such as rows affected, and last
                generated id value. If you use persistent connections, your
                application could access invalid or privileged data that were
                created in a previous PHP request.
            </para>
            <para>
                Currently, only Oracle, DB2, and the PDO adapters (where
                specified by PHP) support persistence in Zend_Db.
            </para>
        </note>

    </sect2>

    <sect2 id="zend.db.adapter.other-statements">

        <title>Running Other Database Statements</title>

        <para>
            There might be cases in which you need to access the connection
            object directly, as provided by the PHP database extension. Some
            of these extensions may offer features that are not surfaced by
            methods of <classname>Zend_Db_Adapter_Abstract</classname>.
        </para>

        <para>
            For example, all SQL statements run by <classname>Zend_Db</classname> are prepared, then
            executed. However, some database features are incompatible with
            prepared statements. DDL statements like CREATE and ALTER cannot
            be prepared in MySQL. Also, SQL statements don't benefit from the <ulink
                url="http://dev.mysql.com/doc/refman/5.1/en/query-cache-how.html">MySQL Query
                Cache</ulink>, prior to MySQL 5.1.17.
        </para>

        <para>
            Most PHP database extensions provide a method to execute SQL
            statements without preparing them. For example, in PDO, this
            method is <methodname>exec()</methodname>. You can access the connection
            object in the PHP extension directly using getConnection().
        </para>

        <example id="zend.db.adapter.other-statements.example">
            <title>Running a Non-Prepared Statement in a PDO Adapter</title>
            <programlisting language="php"><![CDATA[
$result = $db->getConnection()->exec('DROP TABLE bugs');
]]></programlisting>
        </example>

        <para>
            Similarly, you can access other methods or properties that are
            specific to PHP database extensions. Be aware, though, that by
            doing this you might constrain your application to the interface
            provided by the extension for a specific brand of RDBMS.
        </para>

        <para>
            In future versions of <classname>Zend_Db</classname>, there will be opportunities to
            add method entry points for functionality that is common to
            the supported PHP database extensions. This will not affect
            backward compatibility.
        </para>

    </sect2>

    <sect2 id="zend.db.adapter.server-version">
        <title>Retrieving Server Version</title>

        <para>
            Since release 1.7.2, you could retrieve the server version in PHP syntax
            style to be able to use <methodname>version_compare()</methodname>. If the information
            isn't available, you will receive <constant>NULL</constant>.
        </para>

        <example id="zend.db.adapter.server-version.example">
            <title>Verifying server version before running a query</title>
            <programlisting language="php"><![CDATA[
$version = $db->getServerVersion();
if (!is_null($version)) {
    if (version_compare($version, '5.0.0', '>=')) {
        // do something
    } else {
        // do something else
    }
} else {
    // impossible to read server version
}
]]></programlisting>
        </example>
    </sect2>

    <sect2 id="zend.db.adapter.adapter-notes">

        <title>Notes on Specific Adapters</title>

        <para>
            This section lists differences between the Adapter classes of which
            you should be aware.
        </para>

        <sect3 id="zend.db.adapter.adapter-notes.ibm-db2">
            <title>IBM DB2</title>
            <itemizedlist>
                <listitem>
                    <para>
                        Specify this Adapter to the factory() method with the
                        name 'Db2'.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        This Adapter uses the PHP extension ibm_db2.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        IBM DB2 supports both sequences and auto-incrementing
                        keys. Therefore the arguments to
                        <methodname>lastInsertId()</methodname> are optional. If you give
                        no arguments, the Adapter returns the last value
                        generated for an auto-increment key. If you give
                        arguments, the Adapter returns the last value generated
                        by the sequence named according to the convention
                        '<emphasis>table</emphasis>_<emphasis>column</emphasis>_seq'.
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>

        <sect3 id="zend.db.adapter.adapter-notes.mysqli">
            <title>MySQLi</title>
            <itemizedlist>
                <listitem>
                    <para>
                        Specify this Adapter to the <methodname>factory()</methodname>
                        method with the name 'Mysqli'.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        This Adapter utilizes the PHP extension mysqli.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        MySQL does not support sequences, so
                        <methodname>lastInsertId()</methodname> ignores its arguments and
                        always returns the last value generated for an
                        auto-increment key. The <methodname>lastSequenceId()</methodname>
                        method returns <constant>NULL</constant>.
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>

        <sect3 id="zend.db.adapter.adapter-notes.oracle">
            <title>Oracle</title>
            <itemizedlist>
                <listitem>
                    <para>
                        Specify this Adapter to the <methodname>factory()</methodname>
                        method with the name 'Oracle'.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        This Adapter uses the PHP extension oci8.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Oracle does not support auto-incrementing keys, so you
                        should specify the name of a sequence to
                        <methodname>lastInsertId()</methodname> or
                        <methodname>lastSequenceId()</methodname>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The Oracle extension does not support positional
                        parameters. You must use named parameters.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Currently the <classname>Zend_Db::CASE_FOLDING</classname> option
                        is not supported by the Oracle adapter. To use this
                        option with Oracle, you must use the PDO OCI adapter.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        By default, LOB fields are returned as OCI-Lob objects. You could
                        retrieve them as string for all requests by using driver options
                        <code>'lob_as_string'</code> or for particular request by using
                        <methodname>setLobAsString(boolean)</methodname> on adapter or on
                        statement.
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>

        <sect3 id="zend.db.adapter.adapter-notes.pdo-ibm">
            <title>PDO for IBM DB2 and Informix Dynamic Server (IDS)</title>
            <itemizedlist>
                <listitem>
                    <para>
                        Specify this Adapter to the <methodname>factory()</methodname>
                        method with the name 'Pdo_Ibm'.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        This Adapter uses the PHP extensions pdo and pdo_ibm.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        You must use at least PDO_IBM extension version 1.2.2.
                        If you have an earlier version of this extension, you
                        must upgrade the PDO_IBM extension from PECL.
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>

        <sect3 id="zend.db.adapter.adapter-notes.pdo-mssql">
            <title>PDO Microsoft SQL Server</title>
            <itemizedlist>
                <listitem>
                    <para>
                        Specify this Adapter to the <methodname>factory()</methodname>
                        method with the name 'Pdo_Mssql'.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        This Adapter uses the PHP extensions pdo and pdo_mssql.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Microsoft SQL Server does not support sequences, so
                        <methodname>lastInsertId()</methodname> ignores its arguments and
                        always returns the last value generated for an
                        auto-increment key. The <methodname>lastSequenceId()</methodname>
                        method returns <constant>NULL</constant>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        If you are working with unicode strings in an encoding other than UCS-2
                        (such as UTF-8), you may have to perform a conversion in your application
                        code or store the data in a binary column. Please refer to <ulink
                            url="http://support.microsoft.com/kb/232580">Microsoft's Knowledge
                            Base</ulink> for more information.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <classname>Zend_Db_Adapter_Pdo_Mssql</classname> sets
                        <constant>QUOTED_IDENTIFIER ON</constant> immediately after connecting to a
                        SQL Server database. This makes the driver use the standard SQL identifier
                        delimiter symbol (<code>"</code>) instead of the
                        proprietary square-brackets syntax SQL Server uses for
                        delimiting identifiers.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        You can specify <code>pdoType</code> as a key in the
                        options array. The value can be "mssql" (the default),
                        "dblib", "freetds", or "sybase". This option affects
                        the DSN prefix the adapter uses when constructing the
                        DSN string. Both "freetds" and "sybase" imply a prefix
                        of "sybase:", which is used for the
                        <ulink url="http://www.freetds.org/">FreeTDS</ulink> set
                        of libraries.
                        See also
                        <ulink url="http://www.php.net/manual/en/ref.pdo-dblib.connection.php">
                        http://www.php.net/manual/en/ref.pdo-dblib.connection.php</ulink>
                        for more information on the DSN prefixes used in this driver.
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>

        <sect3 id="zend.db.adapter.adapter-notes.pdo-mysql">
            <title>PDO MySQL</title>
            <itemizedlist>
                <listitem>
                    <para>
                        Specify this Adapter to the <methodname>factory()</methodname>
                        method with the name 'Pdo_Mysql'.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        This Adapter uses the PHP extensions pdo and pdo_mysql.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        MySQL does not support sequences, so
                        <methodname>lastInsertId()</methodname> ignores its arguments and
                        always returns the last value generated for an
                        auto-increment key. The <methodname>lastSequenceId()</methodname>
                        method returns <constant>NULL</constant>.
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>

        <sect3 id="zend.db.adapter.adapter-notes.pdo-oci">
            <title>PDO Oracle</title>
            <itemizedlist>
                <listitem>
                    <para>
                        Specify this Adapter to the <methodname>factory()</methodname>
                        method with the name 'Pdo_Oci'.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        This Adapter uses the PHP extensions pdo and pdo_oci.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Oracle does not support auto-incrementing keys, so you
                        should specify the name of a sequence to
                        <methodname>lastInsertId()</methodname> or
                        <methodname>lastSequenceId()</methodname>.
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>

        <sect3 id="zend.db.adapter.adapter-notes.pdo-pgsql">
            <title>PDO PostgreSQL</title>
            <itemizedlist>
                <listitem>
                    <para>
                        Specify this Adapter to the <methodname>factory()</methodname>
                        method with the name 'Pdo_Pgsql'.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        This Adapter uses the PHP extensions pdo and pdo_pgsql.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        PostgreSQL supports both sequences and auto-incrementing
                        keys. Therefore the arguments to
                        <methodname>lastInsertId()</methodname> are optional. If you give
                        no arguments, the Adapter returns the last value
                        generated for an auto-increment key. If you give
                        arguments, the Adapter returns the last value generated
                        by the sequence named according to the convention
                        '<emphasis>table</emphasis>_<emphasis>column</emphasis>_seq'.
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>

        <sect3 id="zend.db.adapter.adapter-notes.pdo-sqlite">
            <title>PDO SQLite</title>
            <itemizedlist>
                <listitem>
                    <para>
                        Specify this Adapter to the <methodname>factory()</methodname>
                        method with the name 'Pdo_Sqlite'.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        This Adapter uses the PHP extensions pdo and pdo_sqlite.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        SQLite does not support sequences, so
                        <methodname>lastInsertId()</methodname> ignores its arguments and
                        always returns the last value generated for an
                        auto-increment key. The <methodname>lastSequenceId()</methodname>
                        method returns <constant>NULL</constant>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        To connect to an SQLite2 database, specify
                        <code>'sqlite2'=>true</code> in the array of
                        parameters when creating an instance of the
                        Pdo_Sqlite Adapter.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        To connect to an in-memory SQLite database,
                        specify <code>'dbname'=>':memory:'</code> in the
                        array of parameters when creating an instance of
                        the Pdo_Sqlite Adapter.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Older versions of the SQLite driver for PHP do not seem
                        to support the PRAGMA commands necessary to ensure that
                        short column names are used in result sets. If you
                        have problems that your result sets are returned with
                        keys of the form "tablename.columnname" when you do a
                        join query, then you should upgrade to the current
                        version of PHP.
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>

        <sect3 id="zend.db.adapter.adapter-notes.firebird">
            <title>Firebird/Interbase</title>
            <itemizedlist>
                <listitem>
                    <para>
                        This Adapter uses the PHP extension php_interbase.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Firebird/interbase does not support auto-incrementing keys,
                        so you should specify the name of a sequence to
                        <methodname>lastInsertId()</methodname> or
                        <methodname>lastSequenceId()</methodname>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Currently the <classname>Zend_Db::CASE_FOLDING</classname> option
                        is not supported by the Firebird/interbase adapter.
                        Unquoted identifiers are automatically returned in
                        upper case.
                    </para>
                </listitem>

                <listitem>
                    <para>Adapter name is ZendX_Db_Adapter_Firebird.</para>
                    <para>
                        Remember to use the param adapterNamespace with value ZendX_Db_Adapter.
                    </para>
                    <para>
                        We recommend to update the gds32.dll (or linux equivalent) bundled with php,
                        to the same version of the server. For Firebird the equivalent gds32.dll is
                        fbclient.dll.
                    </para>
                    <para>
                        By default all identifiers (tables names, fields) are returned in upper
                        case.
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>

    </sect2>

</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
