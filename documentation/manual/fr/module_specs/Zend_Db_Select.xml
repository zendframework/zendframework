<?xml version="1.0" encoding="utf-8"?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="zend.db.select"><info><title>Zend_Db_Select</title></info>
    

    <section xml:id="zend.db.select.introduction"><info><title>Introduction</title></info>
        

        <para>
            L'objet <classname>Zend_Db_Select</classname> représente une instruction de
            requête <acronym>SQL</acronym> de type <constant>SELECT</constant>. La classe a des méthodes pour ajouter
            différentes parties à la requête. Vous pouvez indiquer quelques parties de la requête en
            utilisant des structures de données et des méthodes de <acronym>PHP</acronym>, et la classe forme la
            syntaxe correcte de <acronym>SQL</acronym> pour vous. Après avoir construit une requête, vous pouvez
            l'exécuter comme si vous l'aviez écrite comme une chaîne de caractères.
        </para>

        <para>
            Les possibilités offertes par <classname>Zend_Db_Select</classname> inclut :
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    des méthodes orientées objet pour spécifier des requêtes <acronym>SQL</acronym> morceau par
                    morceau ;
                </para>
            </listitem>

            <listitem>
                <para>
                    l'abstraction de certaines parties de la requête <acronym>SQL</acronym> indépendamment de la
                    base de données ;
                </para>
            </listitem>

            <listitem>
                <para>
                    l'échappement automatique des identificateurs de méta-données dans la
                    plupart des cas, pour supporter les identificateurs contenant les mots réservés
                    <acronym>SQL</acronym> et les caractères spéciaux ;
                </para>
            </listitem>

            <listitem>
                <para>
                    l'échappement des identificateurs et des valeurs, afin de réduire les
                    risques d'attaques par injection <acronym>SQL</acronym>.
                </para>
            </listitem>
        </itemizedlist>

        <para>
            L'utilisation de <classname>Zend_Db_Select</classname> n'est pas obligatoire. Pour
            de très simple requêtes SELECT , il est d'habitude plus simple de spécifier la requête
            <acronym>SQL</acronym> entière comme une chaîne et l'exécuter en utilisant des méthodes de l'adaptateur
            comme <methodname>query()</methodname> ou <methodname>fetchAll()</methodname>. L'utilisation de
            <classname>Zend_Db_Select</classname> est utile si vous devez assembler une requête
            SELECT par procédure, ou basé sur une logique conditionnelle dans votre
            application.
        </para>
    </section>

    <section xml:id="zend.db.select.creating"><info><title>Créer un objet Select</title></info>
        

        <para>
            Vous pouvez créer une instance d'un objet <classname>Zend_Db_Select</classname> en
            utilisant la méthode <methodname>select()</methodname> de l'objet
            <classname>Zend_Db_Adapter_Abstract</classname>.
        </para>

        <example xml:id="zend.db.select.creating.example-db"><info><title>Exemple d'utilisation de la méthode select()</title></info>
            

            <programlisting language="php"><![CDATA[
$db = Zend_Db::factory( ...options... );
$select = $db->select();
]]></programlisting>
        </example>

        <para>
            Une autre manière de créer un objet <classname>Zend_Db_Select</classname> est avec
            son constructeur, en indiquant l'adaptateur de base de données comme argument.
        </para>

        <example xml:id="zend.db.select.creating.example-new"><info><title>Exemple de création d'un nouvel objet Select</title></info>
            

            <programlisting language="php"><![CDATA[
$db = Zend_Db::factory( ...options... );
$select = new Zend_Db_Select($db);
]]></programlisting>
        </example>
    </section>

    <section xml:id="zend.db.select.building"><info><title>Construction de requêtes Select</title></info>
        

        <para>
            En construisant la requête, vous pouvez ajouter des clauses à la requête une par
            une. Il y a une méthode séparée pour ajouter chaque clause à l'objet
            <classname>Zend_Db_Select</classname>.
        </para>

        <example xml:id="zend.db.select.building.example"><info><title>Exemple d'utilisation des méthodes d'ajout de clauses</title></info>
            

            <programlisting language="php"><![CDATA[
// Créer un objet Zend_Db_Select
$select = $db->select();

// Ajouter une clause FROM
$select->from( ...spécifiez une table et des colonnes... )

// Ajouter une clause WHERE
$select->where( ...spécifiez des critères de recherche... )

// Ajouter une clause ORDER BY
$select->order( ...spécifiez des critères de tri... );
]]></programlisting>
        </example>

        <para>
            Vous pouvez également employer la plupart des méthodes de l'objet Zend_Db_Select
            avec une interface fluide et simple. Une <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://en.wikipedia.org/wiki/Fluent_interface">interface fluide</link> signifie
            que chaque méthode renvoie une référence à l'objet qui a été appelé, ainsi vous pouvez
            immédiatement appeler une autre méthode.
        </para>

        <example xml:id="zend.db.select.building.example-fluent"><info><title>Exemple d'utilisation de l'interface fluide</title></info>
            

            <programlisting language="php"><![CDATA[
$select = $db->select()
             ->from( ...spécifiez une table et des colonnes... )
             ->where( ...spécifiez des critères de recherche... )
             ->order( ...spécifiez des critères de tri... );
]]></programlisting>
        </example>

        <para>
            Les exemples de cette section montrent l'utilisation de l'interface fluide, mais
            vous pouvez employer une interface non-fluide dans tous les cas. Il est souvent
            nécessaire d'employer l'interface non-fluide, par exemple, si votre application doit
            exécuter de la logique avant d'ajouter une clause à une requête.
        </para>

        <section xml:id="zend.db.select.building.from"><info><title>Ajouter une clause FROM</title></info>
            

            <para>
                Indiquez la table pour la requête en utilisant la méthode <methodname>from()</methodname>.
                Vous pouvez indiquer le nom de table comme une chaîne de caractères.
                <classname>Zend_Db_Select</classname> applique l'échappement des identificateurs
                autour du nom de table, ainsi vous pouvez employer les caractères spéciaux.
            </para>

            <example xml:id="zend.db.select.building.from.example"><info><title>Exemple d'utilisation de la méthode from()</title></info>
                

                <programlisting language="php"><![CDATA[
// Construire cette requête :
//   SELECT *
//   FROM "produits"

$select = $db->select()
             ->from( 'produits' );
]]></programlisting>
            </example>

            <para>
                Vous pouvez également indiquer le nom de corrélation (parfois appelé "l'alias
                de table") pour une table. Au lieu d'une chaîne de caractère simple, employez un
                tableau associatif faisant correspondre le nom de corrélation au nom de table. Dans
                d'autres clauses de la requête <acronym>SQL</acronym>, employez ce nom de corrélation. Si votre requête
                réalise des jointures sur plus d'une table, <classname>Zend_Db_Select</classname>
                produit des noms uniques de corrélation basés sur les noms de table, pour chaque
                table pour lesquelles vous n'indiquez pas le nom de corrélation.
            </para>

            <example xml:id="zend.db.select.building.from.example-cname"><info><title>Exemple d'utilisation d'un alias de nom de table</title></info>
                

                <programlisting language="php"><![CDATA[
// Construire cette requête :
//   SELECT p.*
//   FROM "produits" AS p

$select = $db->select()
             ->from( array('p' => 'produits') );
]]></programlisting>
            </example>

            <para>
                Certaines marques de SGBDR supportent un spécificateur de schéma principal
                pour une table. Vous pouvez spécifiez un nom de table comme
                "<code>nomDuSchema.nomDeTable</code>", où <classname>Zend_Db_Select</classname>
                échappera chaque partie individuellement, ou vous pouvez spécifier le nom du schéma
                séparément. Un nom de schéma spécifié dans le nom de table sera prioritaire sur un
                schéma fourni séparément dans les cas où les deux seraient fournis.
            </para>

            <example xml:id="zend.db.select.building.from.example-schema"><info><title>Exemple d'utilisation d'un nom de schéma</title></info>
                

                <programlisting language="php"><![CDATA[
// Construire cette requête :
//   SELECT *
//   FROM "monschema"."produits"

$select = $db->select()
             ->from( 'monschema.produits' );

// ou

$select = $db->select()
             ->from('produits', '*', 'monschema');
]]></programlisting>
            </example>
        </section>

        <section xml:id="zend.db.select.building.columns"><info><title>Ajouter des colonnes</title></info>
            

            <para>
                Dans le deuxième argument de la méthode <methodname>from()</methodname>, vous pouvez
                indiquer les colonnes à choisir parmi les tables respectives. Si vous n'indiquez
                aucune colonne, la valeur par défaut est "<code>*</code>", la caractère de
                remplacement <acronym>SQL</acronym> pour "toutes les colonnes".
            </para>

            <para>
                Vous pouvez énumérer les colonnes dans un tableau simple de chaîne de
                caractère, ou en tant que tableau associatif faisant correspondre l'alias de la
                colonne au nom de la colonne. Si vous avez seulement une colonne à requêter, et vous
                n'avez pas besoin d'indiquer un alias de colonne, vous pouvez l'énumérer comme une
                chaîne simple au lieu d'un tableau.
            </para>

            <para>
                Si vous passez un tableau comme argument pour les colonnes, aucune colonne
                pour la table correspondante ne sera inclus dans le jeu de résultat. Voir un <link linkend="zend.db.select.building.join.example-no-columns">exemple de code</link>
                sous la section concernant la méthode <methodname>join()</methodname>.
            </para>

            <para>
                Vous pouvez indiquer le nom de colonne en tant que
                "<code>aliasDeTable.nomDeColonne</code>". <classname>Zend_Db_Select</classname>
                échappera chaque partie individuellement. Si vous n'indiquez pas un nom d'alias pour
                une colonne, elle emploie le nom de corrélation de la table nommée dans la méthode
                courante <methodname>from()</methodname>.
            </para>

            <example xml:id="zend.db.select.building.columns.example"><info><title>Exemples de spécification de colonnes</title></info>
                

                <programlisting language="php"><![CDATA[
// Construire cette requête :
//   SELECT p."produit_id", p."produit_nom"
//   FROM "produits" AS p

$select = $db->select()
             ->from(array('p' => 'produits'),
                    array('produit_id', 'produit_nom'));

// Construire la même requête, en spécifiant l'alias de table :
//   SELECT p."produit_id", p."produit_nom"
//   FROM "produits" AS p

$select = $db->select()
             ->from(array('p' => 'produits'),
                    array('p.produit_id', 'p.produit_nom'));

// Construire cette requête avec un alias pour une colonne :
//   SELECT p."produit_id" AS prodno, p."produit_nom"
//   FROM "produits" AS p

$select = $db->select()
             ->from(array('p' => 'produits'),
                    array('prodno' => 'produit_id', 'produit_nom'));
]]></programlisting>
            </example>
        </section>

        <section xml:id="zend.db.select.building.columns-expr"><info><title>Ajouter une expression de colonne</title></info>
            

            <para>
                Les colonnes dans les requêtes <acronym>SQL</acronym> sont parfois des expressions, pas
                simplement des noms de colonnes d'une table. Les expressions peuvent avoir des noms
                d'alias ou peuvent nécessiter d'être échappées. Si la chaîne de caractère désignant
                votre colonne contient des parenthèses, <classname>Zend_Db_Select</classname> la
                reconnaît comme une expression.
            </para>

            <para>
                Vous pouvez aussi créer un objet de type <classname>Zend_Db_Expr</classname>
                explicitement, pour éviter qu'une chaîne soit traitée comme un nom de colonne.
                <classname>Zend_Db_Expr</classname> est une classe minimale qui contient une unique
                chaîne de caractère. <classname>Zend_Db_Select</classname> reconnaît les objets de
                type <classname>Zend_Db_Expr</classname> et les convertit en chaînes de caractères,
                mais n'applique aucun changement, tel qu'un échappement ou un alias.
            </para>

            <note>
                <para>
                    Utiliser <classname>Zend_Db_Expr</classname> pour les noms de colonnes
                    n'est pas nécessaire si votre expression de colonne contient des parenthèses ;
                    <classname>Zend_Db_Select</classname> reconnaît les parenthèses et traite la
                    chaîne comme une expression en omettant l'échappement et les alias.
                </para>
            </note>

            <example xml:id="zend.db.select.building.columns-expr.example"><info><title>Exemples d'utilisation de colonnes contenant des expressions</title></info>
                

                <programlisting language="php"><![CDATA[
// Construire cette requête :
//   SELECT p."produit_id", LOWER(produit_nom)
//   FROM "produits" AS p
// Une expression avec parenthèses devient implicitement
// un objet Zend_Db_Expr.

$select = $db->select()
             ->from(array('p' => 'produits'),
                    array('produit_id', 'LOWER(produit_nom)'));

// Construire cette requête :
//   SELECT p."produit_id", (p.prix * 1.08) AS prix_avec_taxe
//   FROM "produits" AS p

$select = $db->select()
             ->from(array('p' => 'produits'),
                    array('produit_id',
                          'prix_avec_taxe' => '(p.prix * 1.08)'));

// Construire cette requête en utilisant explicitement Zend_Db_Expr :
//   SELECT p."produit_id", p.prix * 1.08 AS prix_avec_taxe
//   FROM "produits" AS p

$select = $db->select()
             ->from(array('p' => 'produits'),
                    array('produit_id',
                          'prix_avec_taxe' =>
                                new Zend_Db_Expr('p.prix * 1.08')));
]]></programlisting>
            </example>

            <para>
                Dans les cas ci-dessus, <classname>Zend_Db_Select</classname> ne change pas la
                chaîne pour appliquer des alias ou échapper les identificateurs. Si ces changements
                sont nécessaires pour résoudre l'ambiguïté, vous devez faire manuellement les
                changements dans la chaîne de caractères.
            </para>

            <para>
                Si vos noms de colonne sont des mots-clés de <acronym>SQL</acronym> ou contiennent les caractères
                spéciaux, vous devriez employer la méthode <methodname>quoteIdentifier()</methodname> de
                l'adaptateur et interpoler le résultat dans la chaîne de caractères. La méthode
                <methodname>quoteIdentifier()</methodname> utilise l'échappement <acronym>SQL</acronym> pour délimiter les
                identificateurs, qui indique clairement que c'est un identificateur pour une table
                ou une colonne, et non n'importe quelle autre partie de la syntaxe de <acronym>SQL</acronym>.
            </para>

            <para>
                Votre code est plus indépendant du SGBDR si vous utilisez la méthode
                <methodname>quoteIdentifier()</methodname> au lieu d'échapper littéralement dans votre chaîne,
                car quelques marques de SGBDR utilisent des symboles non standards pour échapper les
                identificateurs. La méthode <methodname>quoteIdentifier()</methodname> est conçue pour utiliser
                le symbole d'échappement approprié basé sur le type d'adaptateur. La méthode
                <methodname>quoteIdentifier()</methodname> échappe aussi tout caractère d'échappement qui
                apparaissent dans l'identificateur lui-même.
            </para>

            <example xml:id="zend.db.select.building.columns-quoteid.example"><info><title>Exemples d'échappement de colonnes dans une expression</title></info>
                

                <programlisting language="php"><![CDATA[
// Construire cette requête, en échappant une colonne spéciale
// nommée "from" dans une expression :
//   SELECT p."from" + 10 AS origine
//   FROM "produits" AS p

$select = $db->select()
             ->from(array('p' => 'produits'),
                    array('origine' => '(p.'
                                     . $db->quoteIdentifier('from')
                                     . ' + 10)'));
]]></programlisting>
            </example>
        </section>

        <section xml:id="zend.db.select.building.columns-atomic"><info><title>Ajouter des colonnes à une table FROM ou JOIN existante</title></info>
            

            <para>
                Il peut y avoir des cas où vous souhaitez ajouter des colonnes à une table
                FROM ou JOIN existante après que ces méthodes aient été appelées. La méthode
                <methodname>columns()</methodname> vous permet d'ajouter des colonnes spécifiques à n'importe
                quel moment avant que la requête ne soit exécutée. Vous pouvez fournir les colonnes
                en tant qu'une chaîne de caractères, une <classname>Zend_Db_Expr</classname> ou un
                tableau de ces derniers. Le second argument de cette méthode peut être omis,
                impliquant que les colonnes sont ajoutées à la table FROM, sinon un alias déjà
                défini doit être utilisé.
            </para>

            <example xml:id="zend.db.select.building.columns-atomic.example"><info><title>Exemples d'ajout de colonnes avec la méthode
                <methodname>columns()</methodname></title></info>
                

                <programlisting language="php"><![CDATA[
// Construire cette requête :
//   SELECT p."produit_id", p."produit_nom"
//   FROM "produits" AS p

$select = $db->select()
             ->from(array('p' => 'produits'), 'produit_id')
             ->columns('produit_nom');

// Construire la même requête, en spécifiant l'alias :
//   SELECT p."produit_id", p."produit_nom"
//   FROM "produits" AS p

$select = $db->select()
             ->from(array('p' => 'produits'), 'p.produit_id')
             ->columns('produit_nom', 'p');
             // Ou alternativement columns('p.produit_nom')
]]></programlisting>
            </example>
        </section>

        <section xml:id="zend.db.select.building.join"><info><title>Ajouter une autre table à la requête avec JOIN</title></info>
            

            <para>
                Beaucoup de requêtes utiles impliquent l'utilisation de <constant>JOIN</constant> pour
                combiner les lignes issues de tables multiples. Vous pouvez ajouter des tables à une
                requête en utilisant la méthode <methodname>join()</methodname>. L'utilisation de cette méthode
                est similaire à la méthode <methodname>from()</methodname>, excepté que vous pouvez aussi
                spécifier une condition join dans la plupart des cas.
            </para>

            <example xml:id="zend.db.select.building.join.example"><info><title>Exemple d'utilisation de la méthode join()</title></info>
                

                <programlisting language="php"><![CDATA[
// Construire cette requête :
//   SELECT p."produit_id", p."produit_nom", l.*
//   FROM "produits" AS p JOIN "ligne_items" AS l
//     ON p.produit_id = l.produit_id

$select = $db->select()
             ->from(array('p' => 'produits'),
                    array('produit_id', 'produit_nom'))
            ->join(array('l' => 'ligne_items'),
                   'p.produit_id = l.produit_id');
]]></programlisting>
            </example>

            <para>
                Le deuxième argument de <methodname>join()</methodname> est une chaîne qui représente la
                condition join. C'est une expression qui déclare les critères par lesquels les
                lignes d'une table correspondent aux lignes dans une autre table. Vous pouvez
                utiliser un nom d'alias dans cette expression.
            </para>

            <note>
                <para>
                    Aucun échappement n'est appliqué à une expression que vous spécifiez pour
                    une condition join ; si vous avez des noms de colonnes qui nécessitent
                    d'être échappées, vous devez utiliser <methodname>quoteIdentifier()</methodname> quand vous
                    préparez la chaîne pour une condition join.
                </para>
            </note>

            <para>
                Le troisième argument de <methodname>join()</methodname> est un tableau des noms de
                colonnes, comme c'est utilisé dans la méthode <methodname>from()</methodname>. La valeur par
                défaut est "<code>*</code>", la méthode supporte les alias, les expressions, et les
                objets <classname>Zend_Db_Expr</classname> de la même manière que le tableau de noms
                de colonnes de la méthode <methodname>from()</methodname>.
            </para>

            <para>
                Pour ne choisir aucune colonne à partir d'une table, utilisez un tableau vide
                pour la liste de colonnes. Cette utilisation fonctionnerait aussi avec la méthode
                <methodname>from()</methodname>, mais typiquement vous pouvez avoir besoin de colonnes issues de
                la table primaire dans vos requêtes, tandis que vous pourriez ne vouloir aucune
                colonne de la table jointe.
            </para>

            <example xml:id="zend.db.select.building.join.example-no-columns"><info><title>Exemple avec aucune colonne spécifiée</title></info>
                

                <programlisting language="php"><![CDATA[
// Construire cette requête :
//   SELECT p."produit_id", p."produit_nom"
//   FROM "produits" AS p JOIN "ligne_items" AS l
//     ON p.produit_id = l.produit_id

$select = $db->select()
             ->from(array('p' => 'produits'),
                    array('produit_id', 'produit_name'))
             ->join(array('l' => 'ligne_items'),
                    'p.produit_id = l.produit_id',
                    array() ); // liste de colonnes vide
]]></programlisting>

                <para>
                    Notez le tableau vide (<methodname>array()</methodname>) dans l'exemple ci-dessus à la
                    place de la liste de colonnes de la table jointe.
                </para>
            </example>

            <para>
                Le <acronym>SQL</acronym> a plusieurs types de jointures. Voyez la liste ci-dessous des méthodes
                supportant les différents types de jointures dans
                <classname>Zend_Db_Select</classname>.
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        <command>INNER JOIN</command> avec les méthodes <code>join(table,
                        jointure, [colonnes])</code> ou <code>joinInner(table, jointure,
                        [colonnes])</code>.
                    </para>

                    <para>
                        Ceci est le type de jointure le plus commun. Les lignes de chaque
                        table sont comparées en utilisant la condition join spécifiée. Le résultat
                        inclut seulement les lignes qui vérifient la condition join. Le résultat
                        peut être vide si aucune ligne ne satisfait la condition.
                    </para>

                    <para>Tous les marques de SGBDR supportent ce type de jointure.</para>
                </listitem>

                <listitem>
                    <para>
                        <command>LEFT JOIN</command> avec la méthode <code>joinLeft(table,
                        condition, [colonnes])</code>.
                    </para>

                    <para>
                        Toutes les lignes issues de la table opérande de gauche sont inclues,
                        les lignes correspondantes de la table de droite sont inclues, et les
                        colonnes de la table opérande de droite sont remplies de NULL si aucune
                        ligne existante ne correspond à la table de gauche.
                    </para>

                    <para>Tous les marques de SGBDR supportent ce type de jointure.</para>
                </listitem>

                <listitem>
                    <para>
                        <command>RIGHT JOIN</command> avec la méthode <code>joinRight(table,
                        condition, [colonnes])</code>.
                    </para>

                    <para>
                        La jointure étrangère droite est le complément de la jointure
                        étrangère gauche. Toutes les lignes issues de la table opérande de droite
                        sont inclues, les lignes correspondantes de la table de gauche sont inclues,
                        et les colonnes de la table opérande de gauche sont remplies de NULL si
                        aucune ligne existante ne correspond à la table de droite.
                    </para>

                    <para>
                        Certaines marques de SGBDR ne supportent pas ce type de jointure, mais
                        en général toute jointure droite peut être représentée comme une jointure
                        gauche en inversant l'ordre des tables.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <command>FULL JOIN</command> avec la méthode <code>joinFull(table,
                        condition, [colonnes])</code>.
                    </para>

                    <para>
                        Une jointure étrangère complète est comme la combinaison d'une
                        jointure étrangère gauche et d'une jointure étrangère droite. Toutes les
                        lignes des deux tables sont inclues, appairées ensemble dans la même ligne
                        de résultat si elles satisfont la condition de jointure, et sinon appairées
                        avec des valeurs NULL à la place des colonnes de l'autre table.
                    </para>

                    <para>
                        Certaines marques de SGBDR ne supportent pas ce type de
                        jointure.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <command>CROSS JOIN</command> avec la méthode <code>joinCross(table,
                        [colonnes])</code>.
                    </para>

                    <para>
                        Une jointure croisée est un produit cartésien. Chaque ligne de la
                        première table est assortie avec chaque ligne de la seconde. Ainsi le nombre
                        de lignes du résultat est équivalent au produit du nombre de lignes de
                        chacune des tables. Vous pouvez filtrer le résultat en utilisant une clause
                        WHERE ; dans ce cas une jointure croisée est semblable à l'ancienne syntaxe
                        de jointure SQL-89.
                    </para>

                    <para>
                        La méthode <methodname>joinCross()</methodname> n'a pas de paramètres pour
                        spécifier la condition de jointure. Certaines marques de SGBDR ne supportent
                        pas ce type de jointure.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <command>NATURAL JOIN</command> avec la méthode
                        <methodname>joinNatural(table, [colonnes])</methodname>.
                    </para>

                    <para>
                        Une jointure naturelle compare chaque(s) colonne(s) qui apparaissent
                        avec le même nom dans les deux tables. La comparaison est l'égalité pour
                        toute(s) la(es) colonne(s) ; la comparaison des colonnes utilisant
                        l'inégalité n'est pas une jointure naturelle. Seules les jointures internes
                        (NdT : INNER) naturelles sont supportées par cette <acronym>API</acronym>, même si la syntaxe
                        <acronym>SQL</acronym> permet aussi bien des jointures naturelles étrangères (NdT :
                        OUTER).
                    </para>

                    <para>
                        La méthode <methodname>joinNatural()</methodname> n'a pas de paramètres pour
                        spécifier la condition de jointure.
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                En plus de ces méthodes join, vous pouvez simplifier vos requêtes en utilisant
                les méthodes de type <code>join*Using</code>. Au lieu de fournir une condition
                complète à votre jointure, vous fournissez simplement le nom de la colonne sur
                laquelle réaliser la jointure et l'objet <classname>Zend_Db_Select</classname>
                complète la condition pour vous.
            </para>

            <example xml:id="zend.db.select.building.joinusing.example"><info><title>Exemple avec la méthode <methodname>joinUsing()</methodname></title></info>
                

                <programlisting language="php"><![CDATA[
// Construire cette requête :
//   SELECT *
//   FROM "table1"
//   JOIN "table2"
//   ON "table1".colonne1 = "table2".colonne1
//   WHERE colonne2 = 'foo'

$select = $db->select()
             ->from('table1')
             ->joinUsing('table2', 'colonne1')
             ->where('column2 = ?', 'foo');
]]></programlisting>
            </example>

            <para>
                Chacune des méthodes join applicables du composant
                <classname>Zend_Db_Select</classname> possède une méthode correspondante
                "using".
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        <methodname>joinUsing(table, join, [columns])</methodname> et
                        <methodname>joinInnerUsing(table, join, [columns])</methodname>
                    </para>
                </listitem>

                <listitem>
                    <para><methodname>joinLeftUsing(table, join, [columns])</methodname></para>
                </listitem>

                <listitem>
                    <para><methodname>joinRightUsing(table, join, [columns])</methodname></para>
                </listitem>

                <listitem>
                    <para><methodname>joinFullUsing(table, join, [columns])</methodname></para>
                </listitem>
            </itemizedlist>
        </section>

        <section xml:id="zend.db.select.building.where"><info><title>Ajouter une clause WHERE</title></info>
            

            <para>
                Vous pouvez spécifier des critères pour restreindre le nombre de lignes du
                résultat en utilisant la méthode <methodname>where()</methodname>. Le premier argument de cette
                méthode est une expression <acronym>SQL</acronym>, et cette expression est utilisée dans une clause
                <constant>WHERE</constant> dans la requête.
            </para>

            <example xml:id="zend.db.select.building.where.example"><info><title>Exemple d'utilisation de la méthode where()</title></info>
                

                <programlisting language="php"><![CDATA[
// Construire cette requête :
//   SELECT produit_id, produit_nom, prix
//   FROM "produits"
//   WHERE prix > 100.00

$select = $db->select()
             ->from('produits',
                    array('produit_id', 'produit_nom', 'prix'))
             ->where('prix > 100.00');
]]></programlisting>
            </example>

            <note>
                <para>
                    Aucun échappement n'est appliqué aux expressions passées aux méthodes
                    <methodname>where()</methodname> ou <methodname>orWhere()</methodname>. Si vous avez des noms de
                    colonnes qui nécessitent d'être échappés, vous devez utiliser
                    <methodname>quoteIdentifier()</methodname> quand vous générez la chaîne pour la
                    condition.
                </para>
            </note>

            <para>
                Le second argument de la méthode <methodname>where()</methodname> est optionnel. C'est une
                valeur à substituer dans l'expression. <classname>Zend_Db_Select</classname> échappe
                cette valeur et la substitue au caractère point ("<code>?</code>") d'interrogation
                dans l'expression.
            </para>

            <example xml:id="zend.db.select.building.where.example-param"><info><title>Exemple d'un paramètre dans la méthode where()</title></info>
                

                <programlisting language="php"><![CDATA[
// Construire cette requête :
//   SELECT produit_id, produit_nom, prix
//   FROM "produits"
//   WHERE (prix > 100.00)

$prixminimum = 100;

$select = $db->select()
             ->from('produits',
                    array('produit_id', 'produit_nom', 'prix'))
             ->where('prix > ?', $prixminimum);
]]></programlisting>
            </example>

            <para>
                Vous pouvez fournir un tableau en tant que second paramètre de la méthode
                <methodname>where()</methodname> quand vous utilisez l'opérateur SQL "IN".
            </para>

            <example xml:id="zend.db.select.building.where.example-array"><info><title>Exemple d'un paramètre de type tableau pour la méthode where()</title></info>
                

                <programlisting language="php"><![CDATA[
// Construire cette requête :
//   SELECT produit_id, produit_nom, prix
//   FROM "produits"
//   WHERE (produit_id IN (1, 2, 3))

$productIds = array(1, 2, 3);

$select = $db->select()
             ->from('produits',
                    array('produit_id', 'produit_nom', 'prix'))
             ->where('produit_id IN (?)', $productIds);
]]></programlisting>

            </example>

            <para>
                Vous pouvez appeler la méthode <methodname>where()</methodname> plusieurs fois sur la même
                objet <classname>Zend_Db_Select</classname>. La requête résultante combine les
                différents termes ensemble en utilisant <constant>AND</constant> entre eux.
            </para>

            <example xml:id="zend.db.select.building.where.example-and"><info><title>Exemple avec plusieurs appels de where()</title></info>
                

                <programlisting language="php"><![CDATA[
// Construire cette requête :
//   SELECT produit_id, produit_nom, prix
//   FROM "produits"
//   WHERE (prix > 100.00)
//     AND (prix < 500.00)

$prixminimum = 100;
$prixmaximum = 500;

$select = $db->select()
             ->from('produits',
                    array('produit_id', 'produit_nom', 'prix'))
             ->where('prix > ?', $prixminimum)
             ->where('prix < ?', $prixmaximum);
]]></programlisting>
            </example>

            <para>
                Si vous devez combiner ensemble des termes en utilisant <code>OR</code>,
                utilisez la méthode <methodname>orWhere()</methodname>. Cette méthode est utilisée de la même
                manière que la méthode <methodname>where()</methodname>, excepté que le terme spécifié est
                précédé par <code>OR</code>, au lieu de <constant>AND</constant>.
            </para>

            <example xml:id="zend.db.select.building.where.example-or"><info><title>Exemple d'utilisation de la méthode orWhere()</title></info>
                

                <programlisting language="php"><![CDATA[
// Construire cette requête :
//   SELECT produit_id, produit_nom, prix
//   FROM "produits"
//   WHERE (prix < 100.00)
//     OR (prix > 500.00)

$prixminimum = 100;
$prixmaximum = 500;

$select = $db->select()
             ->from('produits',
                    array('produit_id', 'produit_nom', 'prix'))
             ->where('prix < ?', $prixminimum)
             ->orWhere('prix > ?', $prixmaximum);
]]></programlisting>
            </example>

            <para>
                <classname>Zend_Db_Select</classname> met automatiquement des parenthèses
                autour de chaque expression spécifiée en utilisant les méthodes <methodname>where()</methodname>
                ou <methodname>orWhere()</methodname>. Ceci permet de s'assurer que la priorité de l'opérateur
                booléen n'entraîne pas de résultats inattendus.
            </para>

            <example xml:id="zend.db.select.building.where.example-parens"><info><title>Exemple de mise en parenthèse d'expressions booléennes</title></info>
                

                <programlisting language="php"><![CDATA[
// Construire cette requête :
//   SELECT produit_id, produit_nom, prix
//   FROM "produits"
//   WHERE (prix < 100.00 OR prix > 500.00)
//     AND (produit_nom = 'Pomme')

$prixminimum = 100;
$prixmaximum = 500;
$prod = 'Pomme';

$select = $db->select()
             ->from('produits',
                    array('produit_id', 'produit_nom', 'prix'))
             ->where("prix < $prixminimum OR prix > $prixmaximum")
             ->where('produit_nom = ?', $prod);
]]></programlisting>
            </example>

            <para>
                Dans l'exemple ci-dessus, le résultat serait tout à fait différent sans
                parenthèses, car <constant>AND</constant> a une plus grande priorité que <code>OR</code>.
                <classname>Zend_Db_Select</classname> applique les parenthèses avec pour effet de
                relier de manière plus étroite chaque expression dans les appels successifs de
                <methodname>where()</methodname> qu'avec <constant>AND</constant> qui combine les expressions.
            </para>
        </section>

        <section xml:id="zend.db.select.building.group"><info><title>Ajouter une clause GROUP BY</title></info>
            

            <para>
                Dans la syntaxe <acronym>SQL</acronym>, la clause <code>GROUP BY</code> vous permet de réduire le
                nombre de lignes du résultat de la requête à une ligne par valeur unique trouvé dans
                une(des) colonne(s) nommées) dans la clause <code>GROUP BY</code>.
            </para>

            <para>
                Dans <classname>Zend_Db_Select</classname>, vous pouvez spécifier la(es)
                colonne(s) à utiliser pour calculer les groupes de lignes en utilisant la méthode
                <methodname>group()</methodname>. L'argument de cette méthode est une colonne ou un tableau de
                colonnes à utiliser dans la clause <code>GROUP BY</code>.
            </para>

            <example xml:id="zend.db.select.building.group.example"><info><title>Exemple d'utilisation de la méthode group()</title></info>
                

                <programlisting language="php"><![CDATA[
// Construire cette requête :
//   SELECT p."produit_id", COUNT(*) AS ligne_items_par_produit
//   FROM "produits" AS p JOIN "ligne_items" AS l
//     ON p.produit_id = l.produit_id
//   GROUP BY p.produit_id

$select = $db->select()
             ->from(array('p' => 'produits'),
                    array('produit_id'))
             ->join(array('l' => 'ligne_items'),
                    'p.produit_id = l.produit_id',
                    array('ligne_items_par_produit' => 'COUNT(*)'))
            ->group('p.produit_id');
]]></programlisting>
            </example>

            <para>
                Comme le tableau de colonnes de la méthode <methodname>from()</methodname>, vous pouvez
                utiliser des noms d'alias dans le nom de la colonne, et la colonne est échappée
                comme un identificateur à moins que la chaîne ne contiennent des parenthèses ou que
                ce soit un objet de type <classname>Zend_Db_Expr</classname>.
            </para>
        </section>

        <section xml:id="zend.db.select.building.having"><info><title>Ajouter une clause HAVING</title></info>
            

            <para>
                Dans la syntaxe <acronym>SQL</acronym>, la clause <constant>HAVING</constant> applique une restriction
                sur un groupe de lignes. Ceci est similaire à la manière dont la clause
                <constant>WHERE</constant> applique une restriction sur des lignes. Mais les deux clauses
                sont différentes car les conditions <constant>WHERE</constant> sont appliquées avant que les
                groupes de lignes ne soient définis, alors que les conditions <constant>HAVING</constant>
                sont appliquées après que les groupes aient été définis.
            </para>

            <para>
                Dans <classname>Zend_Db_Select</classname>, vous pouvez spécifier des
                conditions pour restreindre des groupes en utilisant la méthode
                <methodname>having()</methodname>. Son utilisation est similaire à celle de la méthode
                <methodname>where()</methodname>. Le premier argument est une chaîne contenant une expression
                <acronym>SQL</acronym>. Le second argument facultatif est une valeur qui est utilisé pour remplacer le
                caractère de substitution positionné dans l'expression <acronym>SQL</acronym>. Les expressions passées
                dans de multiples appels de la méthode <methodname>having()</methodname> sont combinées en
                utilisant l'opérateur booléen <constant>AND</constant>, ou l'opérateur <code>OR</code> si
                vous utilisez la méthode <methodname>orHaving()</methodname>.
            </para>

            <example xml:id="zend.db.select.building.having.example"><info><title>Exemple d'utilisation de la méthode having()</title></info>
                

                <programlisting language="php"><![CDATA[
// Construire cette requête :
//   SELECT p."produit_id", COUNT(*) AS ligne_items_par_produit
//   FROM "produits" AS p JOIN "ligne_items" AS l
//     ON p.produit_id = l.produit_id
//   GROUP BY p.produit_id
//   HAVING ligne_items_par_produit > 10

$select = $db->select()
             ->from(array('p' => 'produits'),
                    array('produit_id'))
             ->join(array('l' => 'ligne_items'),
                    'p.produit_id = l.produit_id',
                    array('ligne_items_par_produit' => 'COUNT(*)'))
             ->group('p.produit_id')
             ->having('ligne_items_par_produit > 10');
]]></programlisting>
            </example>

            <note>
                <para>
                    Aucun échappement n'est appliqué aux expressions fournies aux méthodes
                    <methodname>having()</methodname> ou <methodname>orHaving()</methodname>. Si vous avez des noms de
                    colonnes qui nécessitent d'être échappées, vous devez utiliser
                    <methodname>quoteIdentifier()</methodname> quand vous générez la chaîne de cette
                    condition.
                </para>
            </note>
        </section>

        <section xml:id="zend.db.select.building.order"><info><title>Ajouter une clause ORDER BY</title></info>
            

            <para>
                Dans la syntaxe <acronym>SQL</acronym>, la clause <code>ORDER BY</code> spécifie une ou plusieurs
                colonnes ou expressions suivant lesquelles le résultat d'une requête doit être trié.
                Si plusieurs colonnes sont listées, les colonnes secondaires sont utilisées pour
                résoudre les égalités ; l'ordre du tri est déterminé par les colonnes secondaires si
                les colonnes précédentes contiennent des valeurs identiques. Le tri par défaut est
                ascendant (du plus petit vers le plus grand). Vous pouvez aussi appliqué un tri
                descendant (du plus grand vers le plus petit) pour une colonne en spécifiant le
                mot-clé <constant>DESC</constant> après la colonne.
            </para>

            <para>
                Dans <classname>Zend_Db_Select</classname>, vous pouvez utiliser la méthode
                <methodname>order()</methodname> pour spécifier une colonne ou un tableau de colonnes par
                lesquelles vous voulez trier. Chaque élément du tableau est une chaîne nommant une
                colonne, facultativement suivi les mots-clés <constant>ASC</constant> ou <constant>DESC</constant>
                en séparant avec un espace.
            </para>

            <para>
                Comme pour les méthodes <methodname>from()</methodname> et <methodname>group()</methodname>, les noms
                de colonnes sont échappées comme des identificateurs, à moins qu'elles ne
                contiennent des parenthèses ou ne soient des objets de type
                <classname>Zend_Db_Expr</classname>.
            </para>

            <example xml:id="zend.db.select.building.order.example"><info><title>Exemple d'utilisation de la méthode order()</title></info>
                

                <programlisting language="php"><![CDATA[
// Construire cette requête :
//   SELECT p."produit_id", COUNT(*) AS ligne_items_par_produit
//   FROM "produits" AS p JOIN "ligne_items" AS l
//     ON p.produit_id = l.produit_id
//   GROUP BY p.produit_id
//   ORDER BY "ligne_items_par_produit" DESC, "produit_id"

$select = $db->select()
             ->from(array('p' => 'produits'),
                    array('produit_id'))
             ->join(array('l' => 'ligne_items'),
                    'p.produit_id = l.produit_id',
                    array('ligne_items_par_produit' => 'COUNT(*)'))
             ->group('p.produit_id')
             ->order(array('ligne_items_par_produit DESC',
                           'produit_id'));
]]></programlisting>
            </example>
        </section>

        <section xml:id="zend.db.select.building.limit"><info><title>Ajouter une clause LIMIT</title></info>
            

            <para>
                Certaines marques de SGBDR étendent la syntaxe <acronym>SQL</acronym> avec une clause
                <constant>LIMIT</constant>. Cette clause réduit le nombre de lignes d'un résultat à un
                nombre maximum que vous spécifiez. Vous pouvez de plus indiquer un nombre de lignes
                à éviter avant de commencer à produire le résultat. Cette fonctionnalité facilite
                l'extraction d'un sous-ensemble d'un résultat, par exemple quand vous affichez des
                résultats avec un défilement de pages.
            </para>

            <para>
                Dans <classname>Zend_Db_Select</classname>, vous pouvez utiliser la méthode
                <methodname>limit()</methodname> pour spécifier le nombre de lignes ainsi que le nombre de
                lignes à omettre. Le premier argument de cette méthode est le nombre de lignes
                désirées. Le second argument est le nombre de lignes à omettre.
            </para>

            <example xml:id="zend.db.select.building.limit.example"><info><title>Exemple d'utilisation de la méthode limit()</title></info>
                

                <programlisting language="php"><![CDATA[
// Construire cette requête :
//   SELECT p."produit_id", p."produit_nom"
//   FROM "produits" AS p
//   LIMIT 10, 20

$select = $db->select()
             ->from(array('p' => 'produits'),
                    array('produit_id', 'produit_nom'))
             ->limit(10, 20);
]]></programlisting>
            </example>

            <note>
                <para>
                    La syntaxe <constant>LIMIT</constant> n'est pas supporté par toutes les marques de
                    SGBDR. Quelques SGBDR nécessite une syntaxe différente pour supporter une
                    fonctionnalité similaire. Chaque classe
                    <classname>Zend_Db_Adapter_Abstract</classname> inclue une méthode pour produire
                    le code <acronym>SQL</acronym> approprié à ce SGBDR.
                </para>
            </note>

            <para>
                Utilisez de manière alternative la méthode <methodname>limitPage()</methodname> pour
                spécifier le nombre de lignes et le décalage. Cette méthode vous permet de limiter
                le jeu de résultats à une série d'un nombre fixé de résultats issus du jeu total de
                résultats de la requête. En d'autres termes, vous spécifiez la taille de la "page"
                de résultats, et le nombre ordinal de la page unique de résultats que vous souhaitez
                voir retourner par la requête. Le numéro de la page est le premier argument de la
                méthode <methodname>limitPage()</methodname>, et la taille de la page est le second argument.
                Les deux arguments sont obligatoires ; ils n'ont pas de valeurs par défaut.
            </para>

            <example xml:id="zend.db.select.building.limit.example2"><info><title>Exemple d'utilisation de la méthode limitPage()</title></info>
                

                <programlisting language="php"><![CDATA[
// Construire cette requête :
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p
//   LIMIT 10, 20

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id', 'product_name'))
             ->limitPage(2, 10);
]]></programlisting>
            </example>
        </section>

        <section xml:id="zend.db.select.building.distinct"><info><title>Ajouter le modificateur de requête DISTINCT</title></info>
            

            <para>
                La méthode <methodname>distinct()</methodname> vous permet d'ajouter le mot-clé
                <constant>DISTINCT</constant> à votre requête <acronym>SQL</acronym>.
            </para>

            <example xml:id="zend.db.select.building.distinct.example"><info><title>Exemple d'utilisation de la méthode distinct()</title></info>
                

                <programlisting language="php"><![CDATA[
// Construire cette requête :
//   SELECT DISTINCT p."produit_nom"
//   FROM "produits" AS p

$select = $db->select()
             ->distinct()
             ->from(array('p' => 'produits'), 'produit_nom');
]]></programlisting>
            </example>
        </section>

        <section xml:id="zend.db.select.building.for-update"><info><title>Ajouter le modificateur de requête FOR UPDATE</title></info>
            

            <para>
                La méthode <methodname>forUpdate()</methodname> vous permet d'ajouter le modificateur
                <code>FOR UPDATE</code> à votre requête <acronym>SQL</acronym>.
            </para>

            <example xml:id="zend.db.select.building.for-update.example"><info><title>Exemple d'utilisation de la méthode forUpdate()</title></info>
                

                <programlisting language="php"><![CDATA[
// Construire cette requête :
//   SELECT FOR UPDATE p.*
//   FROM "produits" AS p

$select = $db->select()
             ->forUpdate()
             ->from(array('p' => 'produits'));
]]></programlisting>
            </example>
        </section>

        <section xml:id="zend.db.select.building.union"><info><title>Construire une requête UNION</title></info>
            

            <para>
                Vous pouvez construire des requêtes de type union avec
                <classname>Zend_Db_Select</classname> en fournissant un tableau de
                <classname>Zend_Db_Select</classname> ou de chaînes de requêtes SQL à la méthode
                <methodname>union()</methodname>. En second paramètre, vous pouvez fournir les
                constantes <constant>Zend_Db_Select::SQL_UNION</constant> ou
                <constant>Zend_Db_Select::SQL_UNION_ALL</constant> pour spécifier le type d'union
                que vous souhaitez réaliser.
            </para>

            <example xml:id="zend.db.select.building.union.example"><info><title>Exemple avec la méthode union()</title></info>
                

                <programlisting language="php"><![CDATA[
$sql1 = $db->select();
$sql2 = "SELECT ...";

$select = $db->select()
    ->union(array($sql1, $sql2))
    ->order("id");
]]></programlisting>
            </example>
        </section>
    </section>

    <section xml:id="zend.db.select.execute"><info><title>Exécuter des requêtes Select</title></info>
        

        <para>
            Cette section décrit comment exécuter une requête représentée par un objet
            <classname>Zend_Db_Select</classname>.
        </para>

        <section xml:id="zend.db.select.execute.query-adapter"><info><title>Exécuter des requêtes Select à partir de l'adaptateur Db</title></info>
            

            <para>
                Vous pouvez exécuter la requête représentée par l'objet
                <classname>Zend_Db_Select</classname> en le passant comme premier argument de la
                méthode <methodname>query()</methodname> d'un objet
                <classname>Zend_Db_Adapter_Abstract</classname>. Utilisez les objets
                <classname>Zend_Db_Select</classname> plutôt qu'une simple chaîne de requête.
            </para>

            <para>
                La méthode <methodname>query()</methodname> retourne un objet de type
                <classname>Zend_Db_Statement</classname> ou <code>PDOStatement</code>, dépendant du
                type d'adaptateur.
            </para>

            <example xml:id="zend.db.select.execute.query-adapter.example"><info><title>Exemple d'utilisation de la méthode query() de l'adaptateur Db</title></info>
                

                <programlisting language="php"><![CDATA[
$select = $db->select()
             ->from('produits');

$stmt = $db->query($select);
$result = $stmt->fetchAll();
]]></programlisting>
            </example>
        </section>

        <section xml:id="zend.db.select.execute.query-select"><info><title>Exécuter des requêtes Select à partir de objet Select</title></info>
            

            <para>
                Comme alternative à l'emploi de la méthode <methodname>query()</methodname>de l'objet
                adaptateur, vous pouvez utiliser la méthode <methodname>query()</methodname> de l'objet
                <classname>Zend_Db_Select</classname>. Les deux méthodes retourne un objet de type
                <classname>Zend_Db_Statement</classname> ou <code>PDOStatement</code>, dépendant du
                type d'adaptateur.
            </para>

            <example xml:id="zend.db.select.execute.query-select.example"><info><title>Exemple d'utilisation de la méthode query() de l'objet Select</title></info>
                

                <programlisting language="php"><![CDATA[
$select = $db->select()
    ->from('produits');

$stmt = $select->query();
$result = $stmt->fetchAll();
]]></programlisting>
            </example>
        </section>

        <section xml:id="zend.db.select.execute.tostring"><info><title>Convertir un objet Select en une chaîne SQL</title></info>
            

            <para>
                Si vous devez accéder à la chaîne représentant la requête <acronym>SQL</acronym> correspondant à
                un objet <classname>Zend_Db_Select</classname>, utilisez la méthode
                <methodname>__toString()</methodname>.
            </para>

            <example xml:id="zend.db.select.execute.tostring.example"><info><title>Exemple d'utilisation de la méthode __toString()</title></info>
                

                <programlisting language="php"><![CDATA[
$select = $db->select()
             ->from('produits');

$sql = $select->__toString();
echo "$sql\n";

// L'affichage est la chaîne :
//   SELECT * FROM "produits"
]]></programlisting>
            </example>
        </section>
    </section>

    <section xml:id="zend.db.select.other"><info><title>Autres méthodes</title></info>
        

        <para>
            Cette section décrit les autres méthodes de la classe
            <classname>Zend_Db_Select</classname> qui ne sont pas couvertes ci-dessus :
            <methodname>getPart()</methodname> et <methodname>reset()</methodname>.
        </para>

        <section xml:id="zend.db.select.other.get-part"><info><title>Récupérer des parties de l'objet Select</title></info>
            

            <para>
                La méthode <methodname>getPart()</methodname> retourne une représentation d'une partie de
                votre requête <acronym>SQL</acronym>. Par exemple, vous pouvez utiliser cette méthode pour retourner un
                tableau d'expressions pour la clause <constant>WHERE</constant>, ou un tableau de colonnes
                (ou d'expressions de colonnes) qui sont dans l'élément <constant>SELECT</constant>, ou les
                valeurs de nombre et de décalage pour la clause <constant>LIMIT</constant>.
            </para>

            <para>
                La valeur retournée n'est pas une chaîne de caractère contenant un fragment de
                syntaxe <acronym>SQL</acronym>. La valeur retournée est une représentation interne, qui est typiquement
                une structure de type tableau contenant des valeurs et des expressions. Chaque
                partie de la requête a une structure différente.
            </para>

            <para>
                L'argument unique de la méthode <methodname>getPart()</methodname> est une chaîne qui
                identifie quelle partie de la requête Select doit être retournée. Par exemple, la
                chaîne "<code>from</code>" identifie la partie de l'objet Select qui stocke
                l'information concernant les tables dans la clause <constant>FROM</constant>, incluant les
                tables jointes.
            </para>

            <para>
                La classe Zend_Db_Select définit des constantes que vous pouvez utiliser pour
                les parties de la requête <acronym>SQL</acronym>. Vous pouvez utiliser ces constantes ou des chaînes de
                caractères littérales.
            </para>

            <table xml:id="zend.db.select.other.get-part.table"><info><title>Constantes utilisées par getPart() et reset()</title></info>
                

                <tgroup cols="2">
                    <thead>
                        <row>
                            <entry>Constante</entry>
                            <entry>Chaîne correspondante</entry>
                        </row>
                    </thead>

                    <tbody>
                        <row>
                            <entry><classname>Zend_Db_Select::DISTINCT</classname></entry>
                            <entry><code>'distinct'</code></entry>
                        </row>

                        <row>
                            <entry><classname>Zend_Db_Select::FOR_UPDATE</classname></entry>
                            <entry><code>'forupdate'</code></entry>
                        </row>

                        <row>
                            <entry><classname>Zend_Db_Select::COLUMNS</classname></entry>
                            <entry><code>'columns'</code></entry>
                        </row>

                        <row>
                            <entry><classname>Zend_Db_Select::FROM</classname></entry>
                            <entry><code>'from'</code></entry>
                        </row>

                        <row>
                            <entry><classname>Zend_Db_Select::WHERE</classname></entry>
                            <entry><code>'where'</code></entry>
                        </row>

                        <row>
                            <entry><classname>Zend_Db_Select::GROUP</classname></entry>
                            <entry><code>'group'</code></entry>
                        </row>

                        <row>
                            <entry><classname>Zend_Db_Select::HAVING</classname></entry>
                            <entry><code>'having'</code></entry>
                        </row>

                        <row>
                            <entry><classname>Zend_Db_Select::ORDER</classname></entry>
                            <entry><code>'order'</code></entry>
                        </row>

                        <row>
                            <entry><classname>Zend_Db_Select::LIMIT_COUNT</classname></entry>
                            <entry><code>'limitcount'</code></entry>
                        </row>

                        <row>
                            <entry><classname>Zend_Db_Select::LIMIT_OFFSET</classname></entry>
                            <entry><code>'limitoffset'</code></entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

            <example xml:id="zend.db.select.other.get-part.example"><info><title>Exemple d'utilisation de la méthode getPart()</title></info>
                

                <programlisting language="php"><![CDATA[
$select = $db->select()
             ->from('produits')
             ->order('produit_id');

// Vous pouvez spécifier une chaîne littérale
$orderData = $select->getPart( 'order' );

// Vous pouvez utiliser une constante
$orderData = $select->getPart( Zend_Db_Select::ORDER );

// La valeur retournée peut être une structure tableau, pas une chaîne.
// Chaque partie a une structure différente
print_r( $orderData );
]]></programlisting>
            </example>
        </section>

        <section xml:id="zend.db.select.other.reset"><info><title>Effacer des parties de l'objet Select</title></info>
            

            <para>
                La méthode <methodname>reset()</methodname> vous permet de vider une partie spécifique de
                la requête <acronym>SQL</acronym>, ou toutes les parties si vous omettez l'argument.
            </para>

            <para>
                L'argument unique est facultatif. Vous pouvez spécifier la partie de la
                requête à effacer, en utilisant les mêmes chaînes que vous utilisez en tant
                qu'argument de la méthode <methodname>getPart()</methodname>. La partie de la requête que vous
                spécifiez est initialisée à l'état par défaut.
            </para>

            <para>
                Si vous omettez le paramètre, <methodname>reset()</methodname> initialise toutes les
                parties de la requête à leurs valeurs par défaut. Ceci rend l'objet Zend_Db_Select
                équivalent à un nouvel objet, comme si vous l'aviez tout juste instancié.
            </para>

            <example xml:id="zend.db.select.other.reset.example"><info><title>Exemple d'utilisation de la méthode reset()</title></info>
                

                <programlisting language="php"><![CDATA[
// Construire cette requête :
//   SELECT p.*
//   FROM "produits" AS p
//   ORDER BY "produit_nom"

$select = $db->select()
             ->from(array('p' => 'produits')
             ->order('produit_nom');

// Changer la condition d'ordre avec une colonne différente :
//   SELECT p.*
//   FROM "produits" AS p
//   ORDER BY "produit_id"

// Vider la partie afin de la redéfinir
$select->reset( Zend_Db_Select::ORDER );

// Et spécifier une colonne différente
$select->order('produit_id');

// Vider toutes les parties de la requête
$select->reset();
]]></programlisting>
            </example>
        </section>
    </section>
</section>
