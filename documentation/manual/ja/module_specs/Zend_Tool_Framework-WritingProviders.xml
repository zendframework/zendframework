<?xml version="1.0" encoding="UTF-8"?>
<!-- Reviewed: no -->
<!-- EN-Revision: 16444 -->
<sect1 id="zend.tool.framework.writing-providers">
    <title>Zend_Tool_Frameworkを利用してプロバイダを作成する</title>

    <para>
        一般的に、プロバイダそれ自体は、
        コマンドラインでクライアント（またはそれ以外）をディスパッチすることを求めるいくらかの能力をバンドルするための、
        開発者のためのシェル以外の何物でもありません。
        MVCアプリケーションの中での「コントローラ」と似ています。
    </para>

    <sect2 id="zend.tool.framework.writing-providers.basic">
        <title>プロバイダを作成するための基本命令</title>

        <para>
            例えば、サード・パーティのコンポーネントが働かせる
            データファイルのバージョンを示す能力を開発者が加えたければ、
            開発者が実装する必要があるクラスが１つだけあります。
            もしコンポーネントが<code>My_Component</code>と呼ばれるなら、
            <code>include_path</code>上のどこかに<code>HelloProvider.php</code>という名前のファイルで
            <code>My_Component_HelloProvider</code>という名のクラスを作成するでしょう。
            このクラスは<classname>Zend_Tool_Framework_Provider_Interface</classname>を実装します、
            そして、このファイルの本体は以下のように見えなければならないだけです:
        </para>

        <programlisting language="php"><![CDATA[
class My_Component_HelloProvider
    implements Zend_Tool_Framework_Provider_Interface
{
    public function say()
    {
        echo 'Hello from my provider!';
    }
}
]]></programlisting>

        <para>
            上記のコードが与えられて、
            コンソール・クライアントを通じて開発者がこの機能にアクセスしたけれ、
            呼び出しはこのように見えるでしょう:
        </para>

        <programlisting language="sh"><![CDATA[
% zf say hello
Hello from my provider!
]]></programlisting>
    </sect2>

    <sect2 id="zend.tool.framework.writing-providers.advanced">
        <title>先進の開発情報</title>

        <para>
            上記の例の "Hello World" は、単純なコマンドとして有名です、
            しかし、より進んだ何かについてはどうでしょうか？
            スクリプトを書くこととツーリングの必要性が高まるにつれ、
            変数を扱う能力を必要とすると気付くかもしれません。
            だいたいのファンクション・シグニチャにはパラメータがあるように、
            ツーリング・リクエストはパラメータを受け入れることもできます。
        </para>

        <para>
            各々のツーリング・リクエストがクラス内でメソッドに分離されることができると、
            ツーリング・リクエストのパラメータはきわめて周知の立場で分離されることもできます。
            プロバイダのアクション・メソッドのパラメータは、
            クライアントがそのプロバイダとアクションの組合せを呼ぶとき、
            利用することを望む同じパラメータを含むことができます。
            たとえば、あなたが上記の例で名前を扱いたいならば、
            あなたは多分オブジェクト指向コードでこうするでしょう:
        </para>

        <programlisting language="php"><![CDATA[
class My_Component_HelloProvider
    implements Zend_Tool_Framework_Provider_Interface
{
    public function say($name = 'Ralph')
    {
        echo 'Hello' . $name . ', from my provider!';
    }
}
]]></programlisting>

        <para>
            それから上記の例は、コマンドライン<code>zf say hello Joe</code>によって呼ぶことができます。
            "Joe" は、メソッド呼び出しのパラメータとして、プロバイダに供給されます。
            また注意すべきこととして、
            パラメータが任意だとあなたがわかるように、
            <code>zf say hello</code>がさらに機能して、名前 "Ralph" にデフォルト設定するように、
            コマンドライン上で選択できることを意味します。
        </para>

        <para>
            あなたが実装したいかもしれないもう一つの面白い特徴は、<emphasis>pretendability</emphasis>です。
            Pretendabilty は、
            まるでそれがリクエストされたアクションとプロバイダの組み合わせを実行しているようなふりをして、
            実際にそれを実行せずに、それが実行するで<emphasis>あろう</emphasis>ことについて沢山の情報をユーザーに与えることが
            プロバイダにできるようにします。
            これ以外の場合にはユーザーが実行したくないかもしれない重いデータベースや、
            ファイルシステム修正をするときに重要な小道具であるかもしれません。
        </para>

        <para>
            Pretendability は簡単に実装できます。
            このフィーチャーには2つの要素があります:
            1) プロバイダが「ふりをする」能力を持つことを示します。
            2) 現在のリクエストが本当に、
            「ふりをする」よう要求されたことを確実にするために、リクエストをチェックします。
            このフィーチャーは下記のコードサンプルで示されます。
        </para>

        <programlisting language="php"><![CDATA[
class My_Component_HelloProvider
    extends    Zend_Tool_Framework_Provider_Abstract
    implements Zend_Tool_Framework_Provider_Pretendable
{
    public function say($name = 'Ralph')
    {
        if ($this->_registry->getRequest()->isPretend()) {
            echo 'I would say hello to ' . $name . '.';
        } else {
            echo 'Hello' . $name . ', from my provider!';
        }
    }
}
]]></programlisting>
    </sect2>
</sect1>
