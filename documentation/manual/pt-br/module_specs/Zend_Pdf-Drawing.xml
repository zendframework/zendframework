<?xml version="1.0" encoding="utf-8"?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="zend.pdf.drawing"><info><title>Desenhando</title></info>
    

    <section xml:id="zend.pdf.drawing.geometry"><info><title>Geometria</title></info>
        

        <para>
            O <acronym>PDF</acronym> usa a mesma geometria do PostScript. A geometria começa no
            canto inferior esquerdo da página e, por padrão, é medida em pontos (1/72 de polegada).
        </para>

        <para>
            O tamanho da página pode ser recuperado de um objeto página:
        </para>

        <programlisting language="php"><![CDATA[
$width  = $pdfPage->getWidth();
$height = $pdfPage->getHeight();
]]></programlisting>
    </section>

    <section xml:id="zend.pdf.drawing.color"><info><title>Cores</title></info>
        

        <para>
            O <acronym>PDF</acronym> possui uma poderosa capacidade para a representação de cores.
            O módulo <classname>Zend_Pdf</classname> dá suporte à Escala de Cinza, RGB e CMYK.
            Qualquer um deles pode ser usado em qualquer lugar onde um
            <classname>Zend_Pdf_Color</classname> for requisitado. As classes
            <classname>Zend_Pdf_Color_GrayScale</classname>,
            <classname>Zend_Pdf_Color_Rgb</classname> e <classname>Zend_Pdf_Color_Cmyk</classname>
            fornecem a seguinte funcionalidade:
        </para>

        <programlisting language="php"><![CDATA[
// $grayLevel (float number). 0.0 (black) - 1.0 (white)
$color1 = new Zend_Pdf_Color_GrayScale($grayLevel);

// $r, $g, $b (float numbers). 0.0 (min intensity) - 1.0 (max intensity)
$color2 = new Zend_Pdf_Color_Rgb($r, $g, $b);

// $c, $m, $y, $k (float numbers). 0.0 (min intensity) - 1.0 (max intensity)
$color3 = new Zend_Pdf_Color_Cmyk($c, $m, $y, $k);
]]></programlisting>

        <para>
            O estilo de cores do <acronym>HTML</acronym> também é fornecido na classe
            <classname>Zend_Pdf_Color_Html</classname>:
        </para>

        <programlisting language="php"><![CDATA[
$color1 = new Zend_Pdf_Color_Html('#3366FF');
$color2 = new Zend_Pdf_Color_Html('silver');
$color3 = new Zend_Pdf_Color_Html('forestgreen');
]]></programlisting>
    </section>

    <section xml:id="zend.pdf.drawing.shape-drawing"><info><title>Desenhando Formas</title></info>
        

        <para>
            Todas as operações de desenho podem ser feitas no contexto de uma página
            <acronym>PDF</acronym>.
        </para>

        <para>
            A classe <classname>Zend_Pdf_Page</classname> provê um conjunto de formas básicas para
            desenho:
        </para>

        <programlisting language="php"><![CDATA[
/**
 * Desenha uma linha de x1,y1 até x2,y2.
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 * @return Zend_Pdf_Page
 */
public function drawLine($x1, $y1, $x2, $y2);
]]></programlisting>

        <programlisting language="php"><![CDATA[
/**
 * Desenha um retângulo.
 *
 * Tipos de preenchimento:
 * Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE - preenche o retângulo
 *                                             e o traço (padrão)
 * Zend_Pdf_Page::SHAPE_DRAW_STROKE          - traço do retângulo
 * Zend_Pdf_Page::SHAPE_DRAW_FILL            - preenche o retângulo
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 * @param integer $fillType
 * @return Zend_Pdf_Page
 */
public function drawRectangle($x1, $y1, $x2, $y2,
                    $fillType = Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE);
]]></programlisting>

        <programlisting language="php"><![CDATA[
/**
 * Desenha um retângulo arredondado.
 *
 * Tipos de preenchimento:
 * Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE - preenche o retângulo
 *                                             e o traço (padrão)
 * Zend_Pdf_Page::SHAPE_DRAW_STROKE          - traço do retângulo
 * Zend_Pdf_Page::SHAPE_DRAW_FILL            - preenche o retângulo
 *
 * radius é um inteiro que representa o raio dos quatro cantos, ou uma matriz
 * de quatro números inteiros que representam o raio a partir do superior
 * esquerdo, indo no sentido horário
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 * @param integer|array $radius
 * @param integer $fillType
 * @return Zend_Pdf_Page
 */
public function drawRoundedRectangle($x1, $y1, $x2, $y2, $radius,
                       $fillType = Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE);
]]></programlisting>

        <programlisting language="php"><![CDATA[
/**
 * Desenha um polígono.
 *
 * If $fillType is Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE or
 * Zend_Pdf_Page::SHAPE_DRAW_FILL, then polygon is automatically closed.
 * See detailed description of these methods in a PDF documentation
 * (section 4.4.2 Path painting Operators, Filling)
 *
 * @param array $x  - array of float (the X co-ordinates of the vertices)
 * @param array $y  - array of float (the Y co-ordinates of the vertices)
 * @param integer $fillType
 * @param integer $fillMethod
 * @return Zend_Pdf_Page
 */
public function drawPolygon($x, $y,
                            $fillType =
                                Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE,
                            $fillMethod =
                                Zend_Pdf_Page::FILL_METHOD_NON_ZERO_WINDING);
]]></programlisting>

        <programlisting language="php"><![CDATA[
/**
 * Draw a circle centered on x, y with a radius of radius.
 *
 * Angles are specified in radians
 *
 * Method signatures:
 * drawCircle($x, $y, $radius);
 * drawCircle($x, $y, $radius, $fillType);
 * drawCircle($x, $y, $radius, $startAngle, $endAngle);
 * drawCircle($x, $y, $radius, $startAngle, $endAngle, $fillType);
 *
 *
 * It's not a really circle, because PDF supports only cubic Bezier
 * curves. But very good approximation.
 * It differs from a real circle on a maximum 0.00026 radiuses (at PI/8,
 * 3*PI/8, 5*PI/8, 7*PI/8, 9*PI/8, 11*PI/8, 13*PI/8 and 15*PI/8 angles).
 * At 0, PI/4, PI/2, 3*PI/4, PI, 5*PI/4, 3*PI/2 and 7*PI/4 it's exactly
 * a tangent to a circle.
 *
 * @param float $x
 * @param float $y
 * @param float $radius
 * @param mixed $param4
 * @param mixed $param5
 * @param mixed $param6
 * @return Zend_Pdf_Page
 */
public function  drawCircle($x,
                            $y,
                            $radius,
                            $param4 = null,
                            $param5 = null,
                            $param6 = null);
]]></programlisting>

        <programlisting language="php"><![CDATA[
/**
 * Draw an ellipse inside the specified rectangle.
 *
 * Method signatures:
 * drawEllipse($x1, $y1, $x2, $y2);
 * drawEllipse($x1, $y1, $x2, $y2, $fillType);
 * drawEllipse($x1, $y1, $x2, $y2, $startAngle, $endAngle);
 * drawEllipse($x1, $y1, $x2, $y2, $startAngle, $endAngle, $fillType);
 *
 * Angles are specified in radians
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 * @param mixed $param5
 * @param mixed $param6
 * @param mixed $param7
 * @return Zend_Pdf_Page
 */
public function drawEllipse($x1,
                            $y1,
                            $x2,
                            $y2,
                            $param5 = null,
                            $param6 = null,
                            $param7 = null);
]]></programlisting>
    </section>

    <section xml:id="zend.pdf.drawing.text-drawing"><info><title>Desenhando Texto</title></info>
        

        <para>
            As operações de desenho de texto também existem no contexto de uma página
            <acronym>PDF</acronym>. Você pode desenhar uma linha de texto em qualquer posição da
            página ao fornecer as coordenadas x e y. A fonte e o tamanho da fonte atuais são usadas
            para a operação de desenho (veja a descrição detalhada abaixo).
        </para>

        <programlisting language="php"><![CDATA[
/**
 * Draw a line of text at the specified position.
 *
 * @param string $text
 * @param float $x
 * @param float $y
 * @param string $charEncoding (optional) Character encoding of source
 *               text.Defaults to current locale.
 * @throws Zend_Pdf_Exception
 * @return Zend_Pdf_Page
 */
public function drawText($text, $x, $y, $charEncoding = '');
]]></programlisting>

        <example xml:id="zend.pdf.drawing.text-drawing.example-1"><info><title>Desenhar uma string na página</title></info>
            

            <programlisting language="php"><![CDATA[
...
$pdfPage->drawText('Olá mundo!', 72, 720);
...
]]></programlisting>
        </example>

        <para>
            Por padrão, as strings de texto são interpretadas usando o método de decodificação e
            caracteres local. Se você tiver uma string que use um método de codificação diferente
            (como uma string UTF-8 sendo lida de um arquivo no disco, ou uma string MacRoman obtida
            de um bando de dados legado), você pode a codificação na hora de desenhar e a
            <classname>Zend_Pdf</classname> irá tratar a comunicação para você. Você pode fornecer
            as strings em qualquer método de codificação suportada pela função <code><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.php.net/manual/function.iconv.php">iconv()</link></code> do
            <acronym>PHP</acronym>:
        </para>

        <example xml:id="zend.pdf.drawing.text-drawing.example-2"><info><title>Desenhar uma string codificada em UTF-8 em uma página</title></info>
            

            <programlisting language="php"><![CDATA[
...
// Read a UTF-8-encoded string from disk
$unicodeString = fread($fp, 1024);

// Draw the string on the page
$pdfPage->drawText($unicodeString, 72, 720, 'UTF-8');
...
]]></programlisting>
        </example>
    </section>

    <section xml:id="zend.pdf.drawing.using-fonts"><info><title>Usando fontes</title></info>
        

        <para>
            O método <methodname>Zend_Pdf_Page::drawText()</methodname> usa a fonte atual da página,
            que é configurada através do método <methodname>Zend_Pdf_Page::setFont()</methodname>:
        </para>

        <programlisting language="php"><![CDATA[
/**
 * Set current font.
 *
 * @param Zend_Pdf_Resource_Font $font
 * @param float $fontSize
 * @return Zend_Pdf_Page
 */
public function setFont(Zend_Pdf_Resource_Font $font, $fontSize);
]]></programlisting>

        <para>
            Documentos <acronym>PDF</acronym> suportam as fontes PostScript Type 1 e TrueType, assim
            como dois tipos especiais do <acronym>PDF</acronym>, o Type 3 e as fontes compostas.
            Existem também 14 fontes padrão Type 1 inclusas em todos os visualizadores de
            <acronym>PDF</acronym>: Courier (4 estilos), Helvetica (4 estilos), Times (4 estilos),
            Symbol, e Zapf Dingbats.
        </para>

        <para>
            <classname>Zend_Pdf</classname> atualmente dá suporte às 14 fontes
            <acronym>PDF</acronym> padrão, assim como às suas fontes personalizadas TrueType.
            Objetos do tipo Font são obtidos via um dos dois métodos fábrica:
            <methodname>Zend_Pdf_Font::fontWithName($fontName)</methodname> para as 14 fontes padrão
            do <acronym>PDF</acronym> ou
            <methodname>Zend_Pdf_Font::fontWithPath($filePath)</methodname> para fontes
            personalizadas.
        </para>

        <example xml:id="zend.pdf.drawing.using-fonts.example-1"><info><title>Criar uma fonte padrão</title></info>
            

            <programlisting language="php"><![CDATA[
...
// Create new font
$font = Zend_Pdf_Font::fontWithName(Zend_Pdf_Font::FONT_HELVETICA);

// Apply font
$pdfPage->setFont($font, 36);
...
]]></programlisting>
        </example>

        <para>
            As constantes para as 14 fontes <acronym>PDF</acronym> padrão são definidas na classe
            <classname>Zend_Pdf_Font</classname>:

            <itemizedlist>
                <listitem><para>Zend_Pdf_Font::FONT_COURIER</para></listitem>
                <listitem><para>Zend_Pdf_Font::FONT_COURIER_BOLD</para></listitem>
                <listitem><para>Zend_Pdf_Font::FONT_COURIER_ITALIC</para></listitem>
                <listitem><para>Zend_Pdf_Font::FONT_COURIER_BOLD_ITALIC</para></listitem>
                <listitem><para>Zend_Pdf_Font::FONT_TIMES</para></listitem>
                <listitem><para>Zend_Pdf_Font::FONT_TIMES_BOLD</para></listitem>
                <listitem><para>Zend_Pdf_Font::FONT_TIMES_ITALIC</para></listitem>
                <listitem><para>Zend_Pdf_Font::FONT_TIMES_BOLD_ITALIC</para></listitem>
                <listitem><para>Zend_Pdf_Font::FONT_HELVETICA</para></listitem>
                <listitem><para>Zend_Pdf_Font::FONT_HELVETICA_BOLD</para></listitem>
                <listitem><para>Zend_Pdf_Font::FONT_HELVETICA_ITALIC</para></listitem>
                <listitem><para>Zend_Pdf_Font::FONT_HELVETICA_BOLD_ITALIC</para></listitem>
                <listitem><para>Zend_Pdf_Font::FONT_SYMBOL</para></listitem>
                <listitem><para>Zend_Pdf_Font::FONT_ZAPFDINGBATS</para></listitem>
            </itemizedlist>
        </para>

        <para>
            Você também pode usar qualquer fonte individual TrueType (que normalmente possui a
            extensão '.ttf') ou uma fonte OpenType (de extensão '.otf') se ela contiver o mesmo
            contorno das TrueType. Atualmente sem suporte, mas planejadas para um lançamento futuro
            são os arquivos .dfont do Mac OS X e os arquivos Microsoft TrueType Collection (extensão
            '.ttc').
        </para>

        <para>
            Para usar uma fonte TrueType, você deve fornecer o caminho completo para a fonte. Se a
            fonte não puder ser lida por algum motivo, ou se ela não for uma fonte TrueType, o
            método fábrica irá lançar uma exceção:
        </para>

        <example xml:id="zend.pdf.drawing.using-fonts.example-2"><info><title>Criar uma fonte TrueType</title></info>
            

            <programlisting language="php"><![CDATA[
...
// Create new font
$goodDogCoolFont = Zend_Pdf_Font::fontWithPath('/path/to/GOODDC__.TTF');

// Apply font
$pdfPage->setFont($goodDogCoolFont, 36);
...
]]></programlisting>
        </example>

        <para>
            Por padrão, fontes personalizadas serão embarcadas no documento <acronym>PDF</acronym>
            resultante. Isso permite que as pessoas que receberem o arquivo poderão visualizá-lo
            corretamente, mesmo que não possuam as fontes apropriadas instaladas em seus sistemas.
            Se você estiver preocupado com o tamanho do arquivo você pode solicitar que a fonte não
            seja incluída através de uma opção 'não embarque' do método fábrica:
        </para>

        <example xml:id="zend.pdf.drawing.using-fonts.example-3"><info><title>Criar uma fonte TrueType, mas não embarcá-la no documento PDF</title></info>
            

            <programlisting language="php"><![CDATA[
...
// Create new font
$goodDogCoolFont = Zend_Pdf_Font::fontWithPath('/path/to/GOODDC__.TTF',
                                               Zend_Pdf_Font::EMBED_DONT_EMBED);

// Apply font
$pdfPage->setFont($goodDogCoolFont, 36);
...
]]></programlisting>
        </example>

        <para>
            Se o programa da fonte não for embarcado, mas o recebedor do arquivo
            <acronym>PDF</acronym> tiver a fonte instalada em seu sistema ele irá ver o documento
            corretamente. Caso ele não possua a fonte correta instalada, o visualizador
            <acronym>PDF</acronym> fará o melhor para sintetizar uma substituição.
        </para>

        <para>
            Algumas fontes possuem regras de licença específicas que evitam que elas sejam
            embarcadas em documentos <acronym>PDF</acronym>. Então, para que você não seja pego de
            surpresa por isso, se você tentar usar uma fonte que não pode ser embarcada, o método
            fábrica irá lançar uma exceção.
        </para>

        <para>
            Você ainda pode usar estas fontes, mas deve passar a opção 'não embarque' como foi
            descrito acima, ou então você pode simplesmente suprimir a exceção:
        </para>

        <example xml:id="zend.pdf.drawing.using-fonts.example-4"><info><title>Não lançar uma exceção para fontes que não podem ser embarcadas</title></info>
            

            <programlisting language="php"><![CDATA[
...
$font = Zend_Pdf_Font::fontWithPath(
           '/path/to/unEmbeddableFont.ttf',
           Zend_Pdf_Font::EMBED_SUPPRESS_EMBED_EXCEPTION
        );
...
]]></programlisting>
        </example>

        <para>
            Esta técnica de supressão é preferível se você permitir que o usuário final escolha sua
            própria fonte. Fontes que podem ser embarcadas no documento <acronym>PDF</acronym> vão
            ser; aquelas que não puderem, não serão.
        </para>

        <para>
            Programas de fonte podem ser um tanto grandes, alguns alcançam dezenas de megabytes. Por
            padrão, todas as fontes embarcadas são comprimidas usando o esquema de compressão Flate,
            resultando, em média, em uma economia de espaço de 50%. Se, por alguma razão, você não
            quer comprimir o programa da fonte, você pode desabilitar isso através de uma opção:
        </para>

        <example xml:id="zend.pdf.drawing.using-fonts.example-5"><info><title>Não comprimir uma fonte embarcada</title></info>
            

            <programlisting language="php"><![CDATA[
...
$font = Zend_Pdf_Font::fontWithPath('/path/to/someReallyBigFont.ttf',
                                    Zend_Pdf_Font::EMBED_DONT_COMPRESS);
...
]]></programlisting>
        </example>

        <para>
            Finalmente, quando necessário, você pode combinar as opções de embarque usando o
            operador binário OR:
        </para>

        <example xml:id="zend.pdf.drawing.using-fonts.example-6"><info><title>Combinando opções de embarque de fonte</title></info>
            

            <programlisting language="php"><![CDATA[
...
$font = Zend_Pdf_Font::fontWithPath(
            $someUserSelectedFontPath,
            (Zend_Pdf_Font::EMBED_SUPPRESS_EMBED_EXCEPTION |
            Zend_Pdf_Font::EMBED_DONT_COMPRESS));
...
]]></programlisting>
        </example>
    </section>

    <section xml:id="zend.pdf.drawing.standard-fonts-limitations"><info><title>Standard PDF fonts limitations</title></info>
        

        <para>
            Standard <acronym>PDF</acronym> fonts use several single byte encodings internally
            (see <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.adobe.com/devnet/acrobat/pdfs/pdf_reference_1-7.pdf">PDF
                Reference, Sixth Edition, version 1.7</link> Appendix D for details). They are
            generally equal to Latin1 character set (except Symbol and ZapfDingbats fonts).
        </para>

        <para>
            <classname>Zend_Pdf</classname> uses CP1252 (WinLatin1) for drawing text with standard
            fonts.
        </para>

        <para>
            Text still can be provided in any other encoding, which must be specified if it differs
            from a current locale. Only WinLatin1 characters will be actually drawn.
        </para>

        <example xml:id="zend.pdf.drawing.using-fonts.example-7"><info><title>Combining font embedding options</title></info>
            

            <programlisting language="php"><![CDATA[
...
$font = Zend_Pdf_Font::fontWithName(Zend_Pdf_Font::FONT_COURIER);
$pdfPage->setFont($font, 36)
        ->drawText('Euro sign - €', 72, 720, 'UTF-8')
        ->drawText('Text with umlauts - à è ì', 72, 650, 'UTF-8');
...
]]></programlisting>
        </example>
    </section>

    <section xml:id="zend.pdf.drawing.extracting-fonts"><info><title>Extracting fonts</title></info>
        

        <para>
            <classname>Zend_Pdf</classname> module provides a possibility to extract fonts from
            loaded documents.
        </para>

        <para>
            It may be useful for incremental document updates. Without this functionality you have
            to attach and possibly embed font into a document each time you want to update it.
        </para>

        <para>
            <classname>Zend_Pdf</classname> and <classname>Zend_Pdf_Page</classname> objects provide
            special methods to extract all fonts mentioned within a document or a page:
        </para>

        <example xml:id="zend.pdf.drawing.extracting-fonts.example-1"><info><title>Extracting fonts from a loaded document</title></info>
            

            <programlisting language="php"><![CDATA[
...
$pdf = Zend_Pdf::load($documentPath);
...
// Get all document fonts
$fontList = $pdf->extractFonts();
$pdf->pages[] = ($page = $pdf->newPage(Zend_Pdf_Page::SIZE_A4));
$yPosition = 700;
foreach ($fontList as $font) {
    $page->setFont($font, 15);
    $fontName = $font->getFontName(Zend_Pdf_Font::NAME_POSTSCRIPT,
                                   'en',
                                   'UTF-8');
    $page->drawText($fontName . ': The quick brown fox jumps over the lazy dog',
                    100,
                    $yPosition,
                    'UTF-8');
    $yPosition -= 30;
}
...
// Get fonts referenced within the first document page
$firstPage = reset($pdf->pages);
$firstPageFonts = $firstPage->extractFonts();
...
]]></programlisting>
        </example>

        <example xml:id="zend.pdf.drawing.extracting-fonts.example-2"><info><title>Extracting font from a loaded document by specifying font name</title></info>
            

            <programlisting language="php"><![CDATA[
...
$pdf = new Zend_Pdf();
...
$pdf->pages[] = ($page = $pdf->newPage(Zend_Pdf_Page::SIZE_A4));

$font = Zend_Pdf_Font::fontWithPath($fontPath);
$page->setFont($font, $fontSize);
$page->drawText($text, $x, $y);
...
// This font name should be stored somewhere...
$fontName = $font->getFontName(Zend_Pdf_Font::NAME_POSTSCRIPT,
                               'en',
                               'UTF-8');
...
$pdf->save($docPath);
...
]]></programlisting>

            <programlisting language="php"><![CDATA[
...
$pdf = Zend_Pdf::load($docPath);
...
$pdf->pages[] = ($page = $pdf->newPage(Zend_Pdf_Page::SIZE_A4));

/* $srcPage->extractFont($fontName) can also be used here */
$font = $pdf->extractFont($fontName);

$page->setFont($font, $fontSize);
$page->drawText($text, $x, $y);
...
$pdf->save($docPath, true /* incremental update mode */);
...
]]></programlisting>
        </example>

        <para>
            Extracted fonts can be used in the place of any other font with the following
            limitations:

            <itemizedlist>
                <listitem>
                    <para>
                        Extracted font can be used only in the context of the document from which it
                        was extracted.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Possibly embedded font program is actually not extracted. So extracted font
                        can't provide correct font metrics and original font has to be used for text
                        width calculations:
                    </para>

                    <programlisting language="php"><![CDATA[
...
$font = $pdf->extractFont($fontName);
$originalFont = Zend_Pdf_Font::fontWithPath($fontPath);

$page->setFont($font /* use extracted font for drawing */, $fontSize);
$xPosition = $x;
for ($charIndex = 0; $charIndex < strlen($text); $charIndex++) {
    $page->drawText($text[$charIndex], xPosition, $y);

    // Use original font for text width calculation
    $width = $originalFont->widthForGlyph(
                 $originalFont->glyphNumberForCharacter($text[$charIndex])
             );
    $xPosition += $width/$originalFont->getUnitsPerEm()*$fontSize;
}
...
]]></programlisting>
                </listitem>
            </itemizedlist>
        </para>
    </section>

    <section xml:id="zend.pdf.drawing.image-drawing"><info><title>Desenhando Imagens</title></info>
        

        <para>
            A classe <classname>Zend_Pdf_Page</classname> fornece o método drawImage() para o
            desenho de imagens:
        </para>

        <programlisting language="php"><![CDATA[
/**
 * Draw an image at the specified position on the page.
 *
 * @param Zend_Pdf_Resource_Image $image
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 * @return Zend_Pdf_Page
 */
public function drawImage(Zend_Pdf_Resource_Image $image, $x1, $y1, $x2, $y2);
]]></programlisting>

        <para>
            Objetos de imagem devem ser criados com o método
            <methodname>Zend_Pdf_Image::imageWithPath($filePath)</methodname> (imagens JPG, PNG e
            TIFF são suportadas agora):
        </para>

        <example xml:id="zend.pdf.drawing.image-drawing.example-1"><info><title>Desenhando imagens</title></info>
            

            <programlisting language="php"><![CDATA[
...
// load image
$image = Zend_Pdf_Image::imageWithPath('my_image.jpg');

$pdfPage->drawImage($image, 100, 100, 400, 300);
...
]]></programlisting>
        </example>

        <para>
            <emphasis>Importante! O suporte a JPEG requer que a extensão <acronym>PHP</acronym> GD
                esteja configurada.</emphasis> <emphasis>Importante! O suporte a PNG requer que
                extensão ZLIB esteja configurada para trabalhar com imagens com canal
                Alpha.</emphasis>
        </para>

        <para>
            Consulte a documentação do <acronym>PHP</acronym> para informações detalhadas (<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.php.net/manual/en/ref.image.php">http://www.php.net/manual/en/ref.image.php</link>).
            (<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.php.net/manual/en/ref.zlib.php">http://www.php.net/manual/en/ref.zlib.php</link>).
        </para>
    </section>

    <section xml:id="zend.pdf.drawing.line-drawing-style"><info><title>Estilo de desenho de linhas</title></info>
        

        <para>
            O desenho de linhas é definido pela largura, cor e padrão de traços. Todos estes
            parâmetros podem ser atribuídos pelos seguintes métodos da classe
            <classname>Zend_Pdf_Page</classname>:
        </para>

        <programlisting language="php"><![CDATA[
/** Set line color. */
public function setLineColor(Zend_Pdf_Color $color);

/** Set line width. */
public function setLineWidth(float $width);

/**
 * Set line dashing pattern.
 *
 * Pattern is an array of floats:
 *     array(on_length, off_length, on_length, off_length, ...)
 * Phase is shift from the beginning of line.
 *
 * @param array $pattern
 * @param array $phase
 * @return Zend_Pdf_Page
 */
public function setLineDashingPattern($pattern, $phase = 0);
]]></programlisting>
    </section>

    <section xml:id="zend.pdf.drawing.fill-style"><info><title>Estilo de preenchimento</title></info>
        

        <para>
            Os métodos <methodname>Zend_Pdf_Page::drawRectangle()</methodname>,
            <methodname>Zend_Pdf_Page::drawPolygon()</methodname>,
            <methodname>Zend_Pdf_Page::drawCircle()</methodname> e
            <methodname>Zend_Pdf_Page::drawEllipse()</methodname> usam o argumento
            <varname>$fillType</varname> como um parâmetro opcional. Ele pode ser:
        </para>

        <itemizedlist>
            <listitem>
                <para>Zend_Pdf_Page::SHAPE_DRAW_STROKE - pincelamento</para>
            </listitem>

            <listitem>
                <para>Zend_Pdf_Page::SHAPE_DRAW_FILL - apenas preenchimento</para>
            </listitem>

            <listitem>
                <para>
                    Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE - preenchimento e pincelamento
                    (comportamento padrão)
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Os métodos <methodname>Zend_Pdf_Page::drawPolygon()</methodname> também recebem um
            parâmetro adicional <varname>$fillMethod</varname>:
        </para>

        <itemizedlist>
            <listitem>
                <para>Zend_Pdf_Page::FILL_METHOD_NON_ZERO_WINDING (comportamento padrão)</para>

                <para>
                    A <citetitle>referência do PDF</citetitle> descreve esta regra como:

                    <blockquote>
                        <para>
                            A regra "nonzero winding number" determina se um dado ponto está dentro
                            de um caminho por conceitualmente desenhar um raio a partir desse ponto
                            até o infinito em qualquer direção e, em seguida, analisar os lugares
                            onde um segmento do caminho atravessa o raio. Começando a contagem do 0,
                            a regra acrescenta 1 cada vez que um segmento cruza o raio da esquerda
                            para a direita e subtrai 1 cada vez que um segmento cruza da direita
                            para a esquerda. Após a contagem de todos os cruzamentos, se o resultado
                            for 0 então o ponto está fora do caminho; de outra forma está dentro.
                            Nota: O método descrito não especifica o que fazer se um caminho
                            segmento coincide ou é tangente ao escolhido raio. Uma vez que a
                            direção do raio é arbitrária, a regra simplesmente escolhe um raio que
                            não encontra tais problemas de interseção. Para simples caminhos
                            convexos, a regra "nonzero winding number" define o interior e o
                            exterior como esperado intuitivamente. Os casos mais interessantes são
                            os envolvem caminhos complexos ou com auto-intersecção, como os que são
                            apresentados na Figura 4.10 (na Referência do <acronym>PDF</acronym>).
                            Para um caminho que consiste em uma estrela de cinco pontas, desenhada
                            com cinco linhas retas conectadas se inter-seccionando, a regra
                            considera como sendo o interior toda a área delimitada pela estrela,
                            incluindo o pentágono no centro. Para um caminho composto de dois
                            círculos concêntricos, as áreas delimitadas por ambos os círculos são
                            consideradas como sendo o interior, desde que ambos os círculos sejam
                            desenhados na mesma direção. Se os círculos forem desenhados em direções
                            opostas, apenas a forma da "rosquinha" entre eles está no interior, de
                            acordo com a regra; o "buraco da rosquinha" está no exterior.
                        </para>
                    </blockquote>
                </para>
            </listitem>

            <listitem>
                <para>Zend_Pdf_Page::FILL_METHOD_EVEN_ODD</para>

                <para>
                    A <citetitle>referência do PDF</citetitle> descreve esta regra como:

                    <blockquote>
                        <para>
                            Uma alternativa à regra "nonzero winding number" é a regra "even-odd".
                            Esta regra determina a "interiorização" de um ponto através do desenho
                            de um raio daquele ponto em qualquer direção e simplesmente contando a
                            quantidade de segmentos de caminhos que cruzam o raio, independentemente
                            da direção. Se a quantidade for ímpar, o ponto está no interior; se for
                            par está no exterior. Isto gera os mesmos resultados da regra "nonzero
                            winding number" para caminhos com formas simples, mas produz resultados
                            diferentes para os mais de forma mais complexa. A Figura 4.11 (na
                            Referência do <acronym>PDF</acronym>) mostra os efeitos da aplicação da
                            regra "even-odd" para caminhos complexos. Para a estrela de cinco
                            pontas, a regra considera os pontos triangulares como estando no
                            interior do caminho, mas não o pentágono no centro. Para os dois
                            círculos concêntricos, apenas a forma da "rosquinha" entre os círculos é
                            considerada como interior, independentemente das direções em que eles
                            foram desenhados.
                        </para>
                    </blockquote>
                </para>
            </listitem>
        </itemizedlist>
    </section>

    <section xml:id="zend.pdf.drawing.linear-transformations"><info><title>Transformações Lineares</title></info>
        

        <section xml:id="zend.pdf.drawing.linear-transformations.rotations"><info><title>Rotações</title></info>
            

            <para>
                A página <acronym>PDF</acronym> pode ser rotacionada antes do uso de qualquer
                operação de desenho. Isso pode ser feito pelo método
                <methodname>Zend_Pdf_Page::rotate()</methodname>:
            </para>

            <programlisting language="php"><![CDATA[
/**
 * Rotate the page.
 *
 * @param float $x  - the X co-ordinate of rotation point
 * @param float $y  - the Y co-ordinate of rotation point
 * @param float $angle - rotation angle
 * @return Zend_Pdf_Page
 */
public function rotate($x, $y, $angle);
]]></programlisting>
        </section>

        <section xml:id="zend.pdf.drawing.linear-transformations.scale"><info><title>Starting from ZF 1.8, scaling</title></info>
            

            <para>
                Scaling transformation is provided by
                <methodname>Zend_Pdf_Page::scale()</methodname> method:
            </para>

            <programlisting language="php"><![CDATA[
/**
 * Scale coordination system.
 *
 * @param float $xScale - X dimention scale factor
 * @param float $yScale - Y dimention scale factor
 * @return Zend_Pdf_Page
 */
public function scale($xScale, $yScale);
]]></programlisting>
        </section>

        <section xml:id="zend.pdf.drawing.linear-transformations.translate"><info><title>Starting from ZF 1.8, translating</title></info>
            

            <para>
                Coordinate system shifting is performed by
                <methodname>Zend_Pdf_Page::translate()</methodname> method:
            </para>

            <programlisting language="php"><![CDATA[
/**
 * Translate coordination system.
 *
 * @param float $xShift - X coordinate shift
 * @param float $yShift - Y coordinate shift
 * @return Zend_Pdf_Page
 */
public function translate($xShift, $yShift);
]]></programlisting>
        </section>

        <section xml:id="zend.pdf.drawing.linear-transformations.skew"><info><title>Starting from ZF 1.8, skewing</title></info>
            

            <para>
                Page skewing can be done using <methodname>Zend_Pdf_Page::skew()</methodname>
                method:
            </para>

            <programlisting language="php"><![CDATA[
/**
 * Translate coordination system.
 *
 * @param float $x  - the X co-ordinate of axis skew point
 * @param float $y  - the Y co-ordinate of axis skew point
 * @param float $xAngle - X axis skew angle
 * @param float $yAngle - Y axis skew angle
 * @return Zend_Pdf_Page
 */
public function skew($x, $y, $xAngle, $yAngle);
]]></programlisting>
        </section>
    </section>

    <section xml:id="zend.pdf.drawing.save-restore"><info><title>Salvar/restaurar estados gráficos</title></info>
        

        <para>
            A qualquer hora os estados gráficos de uma página (fonte atual, tamanho da fonte, cor
            das linhas, cor de preenchimento, estilo de linha, rotação da página, e área de corte)
            podem ser salvos e então restaurados. Operações "Salvar" colocam os dados em uma pilha,
            as restaurações recuperam os estados da pilha.
        </para>

        <para>
            Existem dois métodos na classe <classname>Zend_Pdf_Page</classname> para essas
            operações:
        </para>

        <programlisting language="php"><![CDATA[
/**
 * Save the graphics state of this page.
 * This takes a snapshot of the currently applied style, position,
 * clipping area and any rotation/translation/scaling that has been
 * applied.
 *
 * @return Zend_Pdf_Page
 */
public function saveGS();

/**
 * Restore the graphics state that was saved with the last call to
 * saveGS().
 *
 * @return Zend_Pdf_Page
 */
public function restoreGS();
]]></programlisting>
    </section>

    <section xml:id="zend.pdf.drawing.clipping"><info><title>Recorte de área de desenho</title></info>
        

        <para>
            O <acronym>PDF</acronym> e o módulo <classname>Zend_Pdf</classname> dão suporte ao
            recorte de áreas de desenho. O recorte da área atual limita as regiões da página que
            serão afetadas por operações de pintura. Inicialmente é a página toda.
        </para>

        <para>
            A classe <classname>Zend_Pdf_Page</classname> fornece um conjunto de métodos para
            operações de recorte.
        </para>

        <programlisting language="php"><![CDATA[
/**
 * Intersect current clipping area with a rectangle.
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 * @return Zend_Pdf_Page
 */
public function clipRectangle($x1, $y1, $x2, $y2);
]]></programlisting>

        <programlisting language="php"><![CDATA[
/**
 * Intersect current clipping area with a polygon.
 *
 * @param array $x  - array of float (the X co-ordinates of the vertices)
 * @param array $y  - array of float (the Y co-ordinates of the vertices)
 * @param integer $fillMethod
 * @return Zend_Pdf_Page
 */
public function clipPolygon($x,
                            $y,
                            $fillMethod =
                                Zend_Pdf_Page::FILL_METHOD_NON_ZERO_WINDING);
]]></programlisting>

        <programlisting language="php"><![CDATA[
/**
 * Intersect current clipping area with a circle.
 *
 * @param float $x
 * @param float $y
 * @param float $radius
 * @param float $startAngle
 * @param float $endAngle
 * @return Zend_Pdf_Page
 */
public function clipCircle($x,
                           $y,
                           $radius,
                           $startAngle = null,
                           $endAngle = null);
]]></programlisting>

        <programlisting language="php"><![CDATA[
/**
 * Intersect current clipping area with an ellipse.
 *
 * Method signatures:
 * drawEllipse($x1, $y1, $x2, $y2);
 * drawEllipse($x1, $y1, $x2, $y2, $startAngle, $endAngle);
 *
 * @todo process special cases with $x2-$x1 == 0 or $y2-$y1 == 0
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 * @param float $startAngle
 * @param float $endAngle
 * @return Zend_Pdf_Page
 */
public function clipEllipse($x1,
                            $y1,
                            $x2,
                            $y2,
                            $startAngle = null,
                            $endAngle = null);
]]></programlisting>
    </section>

    <section xml:id="zend.pdf.drawing.styles"><info><title>Estilos</title></info>
        

        <para>
            A classe <classname>Zend_Pdf_Style</classname> fornece funcionalidades de estilo.
        </para>

        <para>
            Estilos podem ser usados para o armazenamento de um conjunto de parâmetros do estado
            gráfico e aplicá-los à uma página <acronym>PDF</acronym> com uma operação:
        </para>

        <programlisting language="php"><![CDATA[
/**
 * Set the style to use for future drawing operations on this page
 *
 * @param Zend_Pdf_Style $style
 * @return Zend_Pdf_Page
 */
public function setStyle(Zend_Pdf_Style $style);

/**
 * Return the style, applied to the page.
 *
 * @return Zend_Pdf_Style|null
 */
public function getStyle();
]]></programlisting>

        <para>
            A classe <classname>Zend_Pdf_Style</classname> fornece um conjunto de métodos para
            configurar ou recuperar diferentes parâmetros do estado gráfico:
        </para>

        <programlisting language="php"><![CDATA[
/**
 * Set line color.
 *
 * @param Zend_Pdf_Color $color
 * @return Zend_Pdf_Page
 */
public function setLineColor(Zend_Pdf_Color $color);
]]></programlisting>

        <programlisting language="php"><![CDATA[
/**
 * Get line color.
 *
 * @return Zend_Pdf_Color|null
 */
public function getLineColor();
]]></programlisting>

        <programlisting language="php"><![CDATA[
/**
 * Set line width.
 *
 * @param float $width
 * @return Zend_Pdf_Page
 */
public function setLineWidth($width);
]]></programlisting>

        <programlisting language="php"><![CDATA[
/**
 * Get line width.
 *
 * @return float
 */
public function getLineWidth();
]]></programlisting>

        <programlisting language="php"><![CDATA[
/**
 * Set line dashing pattern
 *
 * @param array $pattern
 * @param float $phase
 * @return Zend_Pdf_Page
 */
public function setLineDashingPattern($pattern, $phase = 0);
]]></programlisting>

        <programlisting language="php"><![CDATA[
/**
 * Get line dashing pattern
 *
 * @return array
 */
public function getLineDashingPattern();
]]></programlisting>

        <programlisting language="php"><![CDATA[
/**
 * Get line dashing phase
 *
 * @return float
 */
public function getLineDashingPhase();
]]></programlisting>

        <programlisting language="php"><![CDATA[
/**
 * Set fill color.
 *
 * @param Zend_Pdf_Color $color
 * @return Zend_Pdf_Page
 */
public function setFillColor(Zend_Pdf_Color $color);
]]></programlisting>

        <programlisting language="php"><![CDATA[
/**
 * Get fill color.
 *
 * @return Zend_Pdf_Color|null
 */
public function getFillColor();
]]></programlisting>

        <programlisting language="php"><![CDATA[
/**
 * Set current font.
 *
 * @param Zend_Pdf_Resource_Font $font
 * @param float $fontSize
 * @return Zend_Pdf_Page
 */
public function setFont(Zend_Pdf_Resource_Font $font, $fontSize);
]]></programlisting>

        <programlisting language="php"><![CDATA[
/**
 * Modify current font size
 *
 * @param float $fontSize
 * @return Zend_Pdf_Page
 */
public function setFontSize($fontSize);
]]></programlisting>

        <programlisting language="php"><![CDATA[
/**
 * Get current font.
 *
 * @return Zend_Pdf_Resource_Font $font
 */
public function getFont();
]]></programlisting>

        <programlisting language="php"><![CDATA[
/**
 * Get current font size
 *
 * @return float $fontSize
 */
public function getFontSize();
]]></programlisting>
    </section>

    <section xml:id="zend.pdf.drawing.alpha"><info><title>Transparency</title></info>
        

        <para>
            <classname>Zend_Pdf</classname> module supports transparency handling.
        </para>

        <para>
            Transparency may be set using <methodname>Zend_Pdf_Page::setAlpha()</methodname> method:
        </para>

        <programlisting language="php"><![CDATA[
/**
 * Set the transparency
 *
 * $alpha == 0  - transparent
 * $alpha == 1  - opaque
 *
 * Transparency modes, supported by PDF:
 * Normal (default), Multiply, Screen, Overlay, Darken, Lighten,
 * ColorDodge, ColorBurn, HardLight, SoftLight, Difference, Exclusion
 *
 * @param float $alpha
 * @param string $mode
 * @throws Zend_Pdf_Exception
 * @return Zend_Pdf_Page
 */
public function setAlpha($alpha, $mode = 'Normal');
]]></programlisting>
    </section>
</section>
