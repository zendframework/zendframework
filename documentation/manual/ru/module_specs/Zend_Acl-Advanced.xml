<?xml version="1.0" encoding="utf-8"?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="zend.acl.advanced"><info><title>Расширенное использование</title></info>

    

    <section xml:id="zend.acl.advanced.storing"><info><title>Постоянное хранение данных ACL</title></info>

        

        <para>
            <classname>Zend_Acl</classname> спроектирован таким образом, что не требует для хранения
            данных <acronym>ACL</acronym> использования строго определенных технологий хранения -
            таких, как база данных или сервер кеша. Его реализация на чистом <acronym>PHP</acronym>
            позволяет создавать административные инструменты под управлением
            <classname>Zend_Acl</classname> с относительной простотой и гибкостью.
            Многие ситуации требуют некоторой интерактивной поддержки от <acronym>ACL</acronym>, и
            <classname>Zend_Acl</classname> предоставляет методы для настройки, произведения запросов,
            контроля доступа приложением.
       </para>

        <para>
            Тем не менее, хранение данных <acronym>ACL</acronym> остается задачей разработчика,
            т.к. случаи использования могут сильно варьироваться в различных
            ситуациях. Поскольку <classname>Zend_Acl</classname> доступен для сериализации, то можно
            сериализовать объекты <acronym>ACL</acronym> через PHP-функцию
            <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://php.net/serialize"><code>serialize()</code></link>,
            и результаты можно хранить там, где пожелает разработчик - например,
            в файле, базе данных или с помощью механизма кэширования.
     </para>

    </section>

    <section xml:id="zend.acl.advanced.assertions"><info><title>Написание условных правил ACL с утверждениями</title></info>

        

        <para>
            Иногда правило разрешения или запрета доступа роли к ресурсу должно
            быть не безусловным, а зависеть от различных критериев. Например,
            определенный доступ должен быть разрешен, но только с 8:00 до 17:00.
            Другой пример - доступ должен быть запрещен, если запрос поступил
            с IP-адреса, находящегося в "черном списке". <classname>Zend_Acl</classname> имеет
            встроеную поддержку для применения правил, основанных на любых
            нужных разработчику условиях.
        </para>

        <para>
            <classname>Zend_Acl</classname> предоставляет поддержку условных правил с помощью
            интерфейса <classname>Zend_Acl_Assert_Interface</classname>.
            Чтобы использовать интерфейс утверждений, разработчик должен
            написать класс, который реализует метод <code>assert()</code>
            интерфейса:
         </para>

        <programlisting language="php"><![CDATA[
class CleanIPAssertion implements Zend_Acl_Assert_Interface
{
    public function assert(Zend_Acl $acl,
                           Zend_Acl_Role_Interface $role = null,
                           Zend_Acl_Resource_Interface $resource = null,
                           $privilege = null)
    {
        return $this->_isCleanIP($_SERVER['REMOTE_ADDR']);
    }

    protected function _isCleanIP($ip)
    {
        // ...
    }
}
]]></programlisting>

        <para>
            После объявления класса утверждения разработчик должен передавать
            экземпляр этого класса при определении условных правил. Правило,
            которое создается с утверждением, применяется
            только тогда, когда метод утверждения возвращает true.
        </para>

        <programlisting language="php"><![CDATA[
$acl = new Zend_Acl();
$acl->allow(null, null, null, new CleanIPAssertion());
]]></programlisting>

        <para>
            Код выше создает условное правило, разрешающее
            всем доступ ко всем привилегиям всех ресурсов, за исключением
            случаев, когда IP-адрес запрашивающего занесен в "черный список".
            Если запрос приходит с IP-адреса, который не определяется как
            "белый", то правило не применяется.
            Поскольку правило применяется ко всем ролям, всем ресурсам и всем
            привилегиям, то "черный" IP приведет к запрещению доступа.
            Тем не менее, это особый случай, и следует понимать, что во всех
            других случаях (например, когда для правила были указаны роль,
            ресурс, или привилегия), невыполнение утверждения приводит к тому,
            что правило не применяется, и для определения того, реазрешить ли
            доступ или запретить, могут использоваться другие правила.
        </para>

        <para>
            Методу <code>assert()</code> объекта утверждения передаются ACL,
            роль, ресурс и привилегия, к которым применяется запрос на
            авторизацию (например, <code>isAllowed()</code>). Это нужно для
            предоставления контекста классу утверждения и определения его
            условий там, где это нужно.
        </para>

    </section>

</section>
