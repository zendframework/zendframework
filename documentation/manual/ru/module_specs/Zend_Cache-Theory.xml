<?xml version="1.0" encoding="UTF-8"?>
<!-- Reviewed: no -->
<sect1 id="zend.cache.theory">
    <title>Теория кэширования</title>
    <para>
        Есть три ключевых понятия в <classname>Zend_Cache</classname>. Первое — уникальный
        идентификатор (строка), который служит для идентификации записей кэша.
        Второе — это директива <code>'lifetime'</code>, которую вы могли видеть
        в предыдущих примерах; она определяет, в течение какого времени
        кэшируемый ресурс считается "свежим". Третье понятие — условное
        исполнение, используемое для того, чтобы части вашего кода могли быть
        пропущены целиком, этим повышается производительность. Основной метод
        фронтэнда (например, <code>Zend_Cache_Core::get()</code>) всегда
        спроектирован так, чтобы возвращать <code>false</code> при промахе кэша,
        если это имеет смысл для данного фронэнда. Это дает конечным
        пользователям возможность включать части кода, которые нужно
        кэшировать (и затем пропускать) в операторы <code>if(){ ... }</code>,
        где условием является сам метод <classname>Zend_Cache</classname>. Но в конце
        этих блоков вы должны сохранять то, что было сгенерировано (например,
        методом <code>Zend_Cache_Core::save()</code>).
    </para>
    <note><para>
        Для некоторых фронтэндов включение условного исполнения в
        код не нужно, так как вся логика уже реализована в них
        (например, <code>Function</code>).
    </para></note>
    <note><para>
        "Попадание в кэш" — термин для определения того состояния, когда запись
        кэша найдена, является корректной и "свежей" (другими словами, для
        которой не закончился срок действия). Иначе имеет место "промах кэша".
        Когда происходит "промах кэша", вы должны сгенерировать свои данные,
        которые помещаются в кэш. С другой стороны, если есть "попадание",
        то бэкэнд автоматически извлечет запись из кэша.
    </para></note>
    <sect2 id="zend.cache.factory">
        <title>Фабричный метод Zend_Cache</title>
        <para>
            Корректным способом создания рабочего экземпляра
            фронтэнда <classname>Zend_Cache</classname> является код показанный в
            следующем примере:
        </para>
        <programlisting role="php"><![CDATA[
// Выбираем бэкэнд (например, 'File' или 'Sqlite'...)
$backendName = '[...]';

// Выбираем фронтэнд (например, 'Core', 'Output', 'Page'...)
$frontendName = '[...]';

// Устанавливаем массив опций для выбранного фронтэнда
$frontendOptions = array([...]);

// Устанавливаем массив опций для выбранного бэкэнда
$backendOptions = array([...]);

// Создаем экземпляр
// (два последних аргумента являются необязательными)
$cache = Zend_Cache::factory($frontendName,
                             $backendName,
                             $frontendOptions,
                             $backendOptions);
]]></programlisting>
        <para>
            В последующих примерах мы предполагаем, что переменная
            <code>$cache</code> содержит инстанцированный, как показано в
            примере, фронтэнд, и что вы понимаете, как передавать параметры
            выбранному вами бэкэнду.
        </para>
        <note><para>
            Всегда используйте <code>Zend_Cache::factory()</code> для получения
            экземпляров фронтэнда. Непосредственно созданные экземпляры
            фронтэндов и бэкэндов будут работать не так, как ожидается.
        </para></note>
    </sect2>

    <sect2 id="zend.cache.tags">
        <title>Добавление тегов к записям</title>
        <para>
            Теги являются средством категоризации записей кэша. Когда вы
            производите сохранение в кэш методом <code>save()</code>, то можете
            установить массив тегов к данной записи. После этого вы можете
            удалить все записи кэша, помеченные данным тегом (тегами).
        </para>
        <programlisting role="php"><![CDATA[
$cache->save($huge_data, 'myUniqueID', array('tagA', 'tagB', 'tagC'));
]]></programlisting>
        <note>
            <para>
                Метод <code>save()</code> принимает также необязательный
                четвертый параметр: <code>$specificLifetime</code>. Если он не
                равен <code>false</code>, то устанавливается время жизни
                текущей записи кэша.
            </para>
        </note>
    </sect2>
    <sect2 id="zend.cache.clean">
        <title>Очистка кэша</title>
        <para>
            Для того, чтобы удалить или сделать недействительной запись с
            определенным идентификатором, вы можете использовать метод
            <code>remove()</code>:
        </para>
        <programlisting role="php"><![CDATA[
$cache->remove('idToRemove');
]]></programlisting>
        <para>
            Для того, чтобы одновременно удалить или сделать
            недействительными несколько записей кэша, вы можете использовать
            метод <code>clean()</code>. Например, чтобы удалить все записи кэша:
        </para>
        <programlisting role="php"><![CDATA[
// удаление всех записей
$cache->clean(Zend_Cache::CLEANING_MODE_ALL);

// удаление только устаревших записей
$cache->clean(Zend_Cache::CLEANING_MODE_OLD);
]]></programlisting>
        <para>
            Если вы хотите удалить записи кэша, помеченные тегами 'tagA' и 'tagC':
        </para>
        <programlisting role="php"><![CDATA[
$cache->clean(
    Zend_Cache::CLEANING_MODE_MATCHING_TAG,
    array('tagA', 'tagC')
);
]]></programlisting>
        <para>
            Если вы хотите удалить записи кэша, <emphasis>не</emphasis> помеченные тегами 'tagA' и 'tagC':
            If you want to remove cache entries not matching the tags 'tagA' or 'tagC':
        </para>
        <programlisting role="php"><![CDATA[
$cache->clean(
    Zend_Cache::CLEANING_MODE_NOT_MATCHING_TAG,
    array('tagA', 'tagC')
);
]]></programlisting>
        <para>
            Если вы хотите удалить записи кэша, помеченные тегами 'tagA' <emphasis>или</emphasis> 'tagC':
        </para>
        <programlisting role="php"><![CDATA[
$cache->clean(
    Zend_Cache::CLEANING_MODE_MATCHING_ANY_TAG,
    array('tagA', 'tagC')
);
]]></programlisting>
        <para>
            Доступные режимы очищения: <code>CLEANING_MODE_ALL</code> (удалить
            все), <code>CLEANING_MODE_OLD</code> (удалить устаревшие),
            <code>CLEANING_MODE_MATCHING_TAG</code> (удалить помеченные тегом)
            и <code>CLEANING_MODE_NOT_MATCHING_TAG</code> (удалить не помеченные
            тегом). Последние два, как ясно из названия, передаются вместе с
            массивом тегов.
        </para>
    </sect2>
</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
